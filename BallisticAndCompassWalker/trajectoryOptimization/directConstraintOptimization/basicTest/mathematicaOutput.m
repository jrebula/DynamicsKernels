function xdot = fstatederivative(t, x)

% Define constants

% Define forces: 

% State assignments
q1 = x(1); q2 = x(2); 
u1 = x(3); u2 = x(4); 

c1 = cos(q1); c2 = cos(q2); s1 = sin(q1); s2 = sin(q2); c1m2 = cos(q1 - q2); s1m2 = sin(q1 - q2); 

MM = zeros(2,2); rhs = zeros(2,1);

% Mass Matrix
MM(1,1) = inertia + M; MM(1,2) = 0; 
MM(2,1) = MM(1,2); MM(2,2) = inertia + M; 

% righthand side terms
rhs(1) = inputTorque + s1m2*contactForce*Lc*power(3.25 + 3.*c1 - 2*c1m2*Lc - ...
3.*c2*Lc + Lc*Lc,-0.5) + s1*(-(g*M) - 1.5*contactForce*power(3.25 + 3.*c1 - ...
2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5)) + contactForce*power(3.25 + 3.*c1 - ...
2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5)*(s1m2*Lc*(1 - ...
contactCircleRadius*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5)) ...
+ s1*(-1.5 + 1.5*contactCircleRadius*power(3.25 + 3.*c1 - 2*c1m2*Lc - ...
3.*c2*Lc + Lc*Lc,-0.5))) - contactForce*Lc*power(3.25 + 3.*c1 - 2*c1m2*Lc - ...
3.*c2*Lc + Lc*Lc,-0.5)*(s1m2*(1 - contactCircleRadius*power(3.25 + 3.*c1 - ...
2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5)) + s2*(-1.5 + ...
1.5*contactCircleRadius*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + ...
Lc*Lc,-0.5))) + 1.5*contactForce*(s1 - s2*Lc)*power(3.25 + 3.*c1 - 2*c1m2*Lc ...
- 3.*c2*Lc + Lc*Lc,-1)*(-contactCircleRadius + power(3.25 + 3.*c1 - 2*c1m2*Lc ...
- 3.*c2*Lc + Lc*Lc,0.5)); 
rhs(2) = 0. + (-1.*s1m2*contactCircleRadius + ...
1.5*s2*contactCircleRadius)*contactForce*Lc*power(3.25 + 3.*c1 - 2*c1m2*Lc - ...
3.*c2*Lc + Lc*Lc,-1) - s1m2*contactForce*power(3.25 + 3.*c1 - 2*c1m2*Lc - ...
3.*c2*Lc + Lc*Lc,-0.5) + s2*(-(g*M) + 1.5*contactForce*power(3.25 + 3.*c1 - ...
2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5)) - contactForce*power(3.25 + 3.*c1 - ...
2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5)*(1.5*s1*contactCircleRadius*power(3.25 + ...
3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5) + s1m2*(-1 + Lc - ...
contactCircleRadius*Lc*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + ...
Lc*Lc,-0.5))) - 1.5*contactForce*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + ...
Lc*Lc,-0.5)*(-(s1*contactCircleRadius*power(3.25 + 3.*c1 - 2*c1m2*Lc - ...
3.*c2*Lc + Lc*Lc,-0.5)) + s2*(1 + Lc*(-1 + contactCircleRadius*power(3.25 + ...
3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5)))); 

udot = MM\rhs;
xdot = [x(2+1:2*2); udot];

constraintJacobianContact(1,1) = 1.5*s1*power(3.25 + 3.*c1 - 2*c1m2*Lc - ...
3.*c2*Lc + Lc*Lc,-0.5) - s1m2*Lc*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + ...
Lc*Lc,-0.5); constraintJacobianContact(1,2) = s1m2*Lc*power(3.25 + 3.*c1 - ...
2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5) - 1.5*s2*Lc*power(3.25 + 3.*c1 - 2*c1m2*Lc ...
- 3.*c2*Lc + Lc*Lc,-0.5); 


constraintJacobianContactDot(1,1) = -0.75*s1*(-3.*s1*u1 + 2*s1m2*(u1 - u2)*Lc ...
+ 3.*s2*u2*Lc)*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-1.5) + ...
(s1m2*Lc*(-3.*s1*u1 + 2*s1m2*(u1 - u2)*Lc + 3.*s2*u2*Lc)*power(3.25 + 3.*c1 - ...
2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-1.5))/2. + 1.5*c1*u1*power(3.25 + 3.*c1 - ...
2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5) - c1m2*(u1 - u2)*Lc*power(3.25 + 3.*c1 - ...
2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5); constraintJacobianContactDot(1,2) = ...
-(s1m2*Lc*(-3.*s1*u1 + 2*s1m2*(u1 - u2)*Lc + 3.*s2*u2*Lc)*power(3.25 + 3.*c1 ...
- 2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-1.5))/2. + 0.75*s2*Lc*(-3.*s1*u1 + 2*s1m2*(u1 ...
- u2)*Lc + 3.*s2*u2*Lc)*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + ...
Lc*Lc,-1.5) + c1m2*(u1 - u2)*Lc*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + ...
Lc*Lc,-0.5) - 1.5*c2*u2*Lc*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + ...
Lc*Lc,-0.5); 


nonPenetrationConstraint = (-3.25*contactCircleRadius + ...
3.*c2*contactCircleRadius*Lc - 1.*contactCircleRadius*(Lc*Lc) + ...
3.25*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,0.5) - ...
3.*c2*Lc*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,0.5) + ...
Lc*Lc*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,0.5) + ...
c1*(-3.*contactCircleRadius + 3.*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + ...
Lc*Lc,0.5)) + c1m2*(2.*contactCircleRadius*Lc - 2.*Lc*power(3.25 + 3.*c1 - ...
2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,0.5)))*power(3.25 + 3.*c1 - 2.*c1m2*Lc - ...
3.*c2*Lc + Lc*Lc,-1);

energies.PE = 1.5*g*M - c1*g*M - c2*g*M;

energies.PEGravity = 1.5*g*M - c1*g*M - c2*g*M;

energies.KE = (M*(u1*u1))/2. + (M*(u2*u2))/2. + (inertia*(u1*u1) + ...
inertia*(u2*u2))/2.;

points.pendulumOne.position(1) = -s1; 
points.pendulumOne.position(2) = 0; 
points.pendulumOne.position(3) = -c1; 


points.pendulumOne.velocity(1) = -(c1*u1); 
points.pendulumOne.velocity(2) = 0; 
points.pendulumOne.velocity(3) = s1*u1; 


points.pendulumOne.R(1,1) = c1; points.pendulumOne.R(1,2) = 0; ...
points.pendulumOne.R(1,3) = s1; 
points.pendulumOne.R(2,1) = 0; points.pendulumOne.R(2,2) = 1; ...
points.pendulumOne.R(2,3) = 0; 
points.pendulumOne.R(3,1) = -s1; points.pendulumOne.R(3,2) = 0; ...
points.pendulumOne.R(3,3) = c1; 


points.pendulumTwo.position(1) = 0. - s2; 
points.pendulumTwo.position(2) = 0.; 
points.pendulumTwo.position(3) = 1.5 - c2; 


points.pendulumTwo.velocity(1) = -(c2*u2); 
points.pendulumTwo.velocity(2) = 0; 
points.pendulumTwo.velocity(3) = s2*u2; 


points.pendulumTwo.R(1,1) = c2; points.pendulumTwo.R(1,2) = 0; ...
points.pendulumTwo.R(1,3) = s2; 
points.pendulumTwo.R(2,1) = 0; points.pendulumTwo.R(2,2) = 1; ...
points.pendulumTwo.R(2,3) = 0; 
points.pendulumTwo.R(3,1) = -s2; points.pendulumTwo.R(3,2) = 0; ...
points.pendulumTwo.R(3,3) = c2; 


points.contactPointOnCircle.position(1) = -(s1*contactCircleRadius*power(3.25 ...
+ 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5)) + s2*(-Lc + ...
contactCircleRadius*Lc*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + ...
Lc*Lc,-0.5)); 
points.contactPointOnCircle.position(2) = 0; 
points.contactPointOnCircle.position(3) = 1.5 - ...
1.5*contactCircleRadius*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + ...
Lc*Lc,-0.5) - c1*contactCircleRadius*power(3.25 + 3.*c1 - 2*c1m2*Lc - ...
3.*c2*Lc + Lc*Lc,-0.5) + c2*(-Lc + contactCircleRadius*Lc*power(3.25 + 3.*c1 ...
- 2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5)); 


points.contactPointOnCircle.velocity(1) = ...
-1.5*u2*contactCircleRadius*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + ...
Lc*Lc,-0.5) - c1*u2*contactCircleRadius*power(3.25 + 3.*c1 - 2*c1m2*Lc - ...
3.*c2*Lc + Lc*Lc,-0.5) + c2*(-u2 + u2*(1 - Lc) + ...
u2*contactCircleRadius*Lc*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + ...
Lc*Lc,-0.5)); 
points.contactPointOnCircle.velocity(2) = 0.; 
points.contactPointOnCircle.velocity(3) = 0. + ...
s1*u2*contactCircleRadius*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + ...
Lc*Lc,-0.5) - s2*(-u2 + u2*(1 - Lc) + u2*contactCircleRadius*Lc*power(3.25 + ...
3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5)); 


points.contactPointOnCircle.R(1,1) = c2; points.contactPointOnCircle.R(1,2) = ...
0; points.contactPointOnCircle.R(1,3) = s2; 
points.contactPointOnCircle.R(2,1) = 0; points.contactPointOnCircle.R(2,2) = ...
1; points.contactPointOnCircle.R(2,3) = 0; 
points.contactPointOnCircle.R(3,1) = -s2; points.contactPointOnCircle.R(3,2) ...
= 0; points.contactPointOnCircle.R(3,3) = c2; 


points.pendulumOneContactPointPosition(1) = -s1; 
points.pendulumOneContactPointPosition(2) = 0; 
points.pendulumOneContactPointPosition(3) = -c1; 


points.pendulumTwoContactCircleCenterPosition(1) = 0. - s2*Lc; 
points.pendulumTwoContactCircleCenterPosition(2) = 0.; 
points.pendulumTwoContactCircleCenterPosition(3) = 1.5 - c2*Lc; 


points.circleSurfaceToContactPointDirection(1) = 0. - s1*power(3.25 + 3.*c1 - ...
2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5) + s2*Lc*power(3.25 + 3.*c1 - 2*c1m2*Lc - ...
3.*c2*Lc + Lc*Lc,-0.5); 
points.circleSurfaceToContactPointDirection(2) = 0.; 
points.circleSurfaceToContactPointDirection(3) = -1.5*power(3.25 + 3.*c1 - ...
2*c1m2*Lc - 3.*c2*Lc + Lc*Lc,-0.5) - c1*power(3.25 + 3.*c1 - 2*c1m2*Lc - ...
3.*c2*Lc + Lc*Lc,-0.5) + c2*Lc*power(3.25 + 3.*c1 - 2*c1m2*Lc - 3.*c2*Lc + ...
Lc*Lc,-0.5); 


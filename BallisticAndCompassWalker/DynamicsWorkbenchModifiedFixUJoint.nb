(* Content-type: application/mathematica *)

(*** Wolfram Notebook File ***)
(* http://www.wolfram.com/nb *)

(* CreatedBy='Mathematica 7.0' *)

(*CacheID: 234*)
(* Internal cache information:
NotebookFileLineBreakTest
NotebookFileLineBreakTest
NotebookDataPosition[       145,          7]
NotebookDataLength[    257866,       7735]
NotebookOptionsPosition[    225156,       6707]
NotebookOutlinePosition[    226108,       6741]
CellTagsIndexPosition[    225978,       6735]
WindowFrame->Normal*)

(* Beginning of Notebook Content *)
Notebook[{
Cell["Off[General::spell1]", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
BeginPackage[\"DynamicsWorkbenchMidfiedFixUJoint`\"];\
\>", "Input",
 InitializationCell->True,
 CellChangeTimes->{{3.482171353634465*^9, 3.482171354402542*^9}, {
  3.5792081952509155`*^9, 3.5792082015225425`*^9}},
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{"(*", " ", 
  RowBox[{
   RowBox[{"Version", " ", 
    RowBox[{"history", ":", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{
       RowBox[{"v", ".", " ", "3.8"}], " ", 
       RowBox[{
        RowBox[{"3", "/", "27"}], "/", "05"}]}], ":", " ", 
      RowBox[{"added", " ", "ExportMatlabCode"}]}]}]}], ",", " ", 
   RowBox[{
    RowBox[{"ExportExpression", " ", "\[IndentingNewLine]", 
     RowBox[{"v", ".", " ", "3.7"}], " ", 
     RowBox[{
      RowBox[{"3", "/", "15"}], "/", "04"}]}], ":", " ", 
    RowBox[{"added", " ", "CenterDot", " ", "notation"}]}], ",", " ", 
   RowBox[{
    RowBox[{
    "sped", " ", "up", " ", "slow", " ", "dot", " ", "products", 
     "\[IndentingNewLine]", 
     RowBox[{"v", ".", " ", "3.6"}], " ", 
     RowBox[{
      RowBox[{"1", "/", "25"}], "/", "04"}]}], ":", " ", 
    RowBox[{
     RowBox[{
     "altered", " ", "Norm", " ", "to", " ", "make", " ", "compatible", " ", 
      "with", " ", "Mma", " ", "5.0"}], "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"v", ".", " ", "3.5"}], " ", 
      RowBox[{
       RowBox[{"7", "/", "17"}], "/", "01"}]}]}], ":", " ", 
    RowBox[{
     RowBox[{
     "added", " ", "facility", " ", "to", " ", "memorize", " ", "dot", " ", 
      "products"}], "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"v", ".", " ", "3.4"}], " ", 
      RowBox[{
       RowBox[{"5", "/", "14"}], "/", "00"}]}]}], ":", " ", 
    RowBox[{
     RowBox[{
     "made", " ", "slight", " ", "change", " ", "to", " ", "Slider", " ", 
      "joint"}], "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{
       RowBox[{"v", ".", " ", "3.3"}], " ", 
       RowBox[{
        RowBox[{"1", "/", "10"}], "/", "00"}]}], ":", " ", 
      RowBox[{"changed", " ", "NewModel"}]}]}]}], ",", " ", 
   RowBox[{
    RowBox[{"added", " ", "options", "\[IndentingNewLine]", " ", 
     RowBox[{"v", ".", " ", "3.2"}], " ", 
     RowBox[{
      RowBox[{"10", "/", "2"}], "/", "99"}]}], ":", " ", 
    RowBox[{
     RowBox[{"Zee", " ", "functions", " ", "operational"}], 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"v", ".", " ", "3.1"}], " ", 
      RowBox[{
       RowBox[{"6", "/", "12"}], "/", "98"}]}]}], ":", " ", 
    RowBox[{
     RowBox[{"Zee", " ", "functions", " ", "in", " ", "beta"}], 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{
       RowBox[{"v", ".", " ", "3.0"}], " ", 
       RowBox[{
        RowBox[{"1", "/", "14"}], "/", "98"}]}], ":", " ", 
      RowBox[{"added", " ", "Mma", " ", "3.0", " ", "functionality"}]}]}]}]}],
   " ", "*)"}]], "Input"],

Cell[CellGroupData[{

Cell["Help", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
AccCOM::usage = \"AccCOM[body] returns a vector describing the acceleration \
of the center of mass of body with respect to the ground reference frame.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
AccJnt::usage = \"AccJnt[body] returns the velocity of the point on the \
inboard body which corresponds to the location of the joint connecting the \
two.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
AccJnt2::usage = \"AccJnt2[body] returns the acceleration of the point on \
body which instaneously corresponds to the location of the joint between the \
body and the inboard body. Used in slider joints.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
AddFrame::usage = \"AddFrame[frame,baseframe,jointtype,opts] adds a new \
reference frame to the frame tree. This frame is specified relative to a base \
frame which precedes it in the frame tree. Several Joint types are available.\
\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
AddBody::usage = \"AddBody[body,inboard,jointtype,opts] adds a new body to \
the system. This body is connected to the inboard body through a joint \
specified by jointtype. Several Joint types are available (type '?Joints'). \
Options InbToJnt and BodyToJnt specify vectors from the center of mass of the \
inboard body to the joint, and from the new body's center of mass to the \
joint. These vectors may be in any reference frame(s). Options Mass and \
Inertia describe physical parameters.  Other options specify the axes \
corresponding to the joint.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
AngAcc::usage = \"AngAcc[body] returns the angular acceleration of the body \
with respect to ground.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
AngMom::usage = \"AngMom[body,pnt] returns the angular momentum of the body \
about a given point, with respect to the ground reference frame. \
AngMom[body,pnt,ref] returns the angular momentum in a specified (inertial) \
frame. A list of bodies can also be provided. The given point pnt is treated \
as fixed in the reference frame. For angular momentum about a moving point, \
it is necessary to add the appropriate inertial term manually.\";\
\>", "Input",
 InitializationCell->True],

Cell["\<\
AngVel::usage = \"AngVel[body] returns the angular velocity of the body with \
respect to ground. AngVel[body,frme] returns the angular velocity of the body \
with respect to frme\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
AppFrc::usage = \"AppFrc[body,force,point] applies vector force to
the body at a vector point from the center of mass.  Vectors may
be specified in defined reference frame.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
AppTrq::usage = \"AppTrq[body,torque] applies a moment specified
by the vector torque to body.  The vector may be specified in
any defined reference frame.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["AtT0::usage = \"AtT0[expr] returns expr set at time zero.\";", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Axis::usage = \"Axis->axis specifies a rotational axis, and may be in the \
form of an axis number (1 through 3), a vector (e.g., ground[1]), or a list \
of unit vector coefficients (direction cosines). For joints with multiple \
rotatory axes, they are numbered Axis1, Axis2, etc.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Ball::usage = \"A Ball joint is a three degree-of-freedom rotatory joint. Its \
home position is coincident with the base reference frame (the frame of the \
inboard body). The generalized coordinates Qdof1 through Qdof4 describing the \
rotations are in the form of euler parameters {e1,e2,e3,e4}, where e4 is the \
cosine of the half-rotational angle.  The generalized speeds Udof1 through \
Udof3 are the angular velocities about the body's reference frame axes.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Bodies::usage = \"Bodies returns a list of the currently defined bodies.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
BodyToJnt::usage = \"BodyToJnt[body] is the vector from the body's center of \
mass to the joint connecting it to the inboard joint.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
CastMtx::usage = \"CastMtx[from,to] returns the transformation
matrix needed to cast a vector from one reference frame to
another.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
CastV::usage = \"CastV[vector,frame] will cast any vector into
a specified reference frame.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
CollectE::usage = \"CollectE[eom] puts the equations of motion into a form \
simplified with respect to the udots, so that they do not appear multiple \
times. CollectE[eom, x] simplifies with respect to any expression x appearing \
in the equations.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
ConvertList::usage = \"ConvertList[vector, frame] is a utility function which \
converts either a vector, a list of unit vector coefficients (direction \
cosines), or the number between 1 and 3 designating an axis into the form of \
a list of the unit vector coefficients for the specified frame.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Cross::usage = \"Cross[vector1,vector2] or
(vector1 ~X~ vector2) performs the cross product of
two vectors.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
D::usage = \"Partial derivatives of single or multiple vectors are found \
using D[ vector, scalar, in->frame, NonConstants->{functions} ], where in and \
NonConstants are options. Option in is used to specify the reference frame \
the partial derivative is desired in, and defaults to ground.\";

Dt::usage = \"Total derivatives of a single or multiple vector are found \
using Dt[ vector, scalar, in->frame, Constants->{constants} ], where in and \
Constants are options. Option in is used to specify the reference frame the \
total derivative is desired in, and defaults to ground. If the angular \
velocities of all of the reference frames vector is defined in are themselves \
defined, the total time derivative is computed using those angular \
velocities.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["\<\
Dist::usage = \"Dist[point1,point2] returns the distance
between two points, which need not be described in the
same reference frames.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"spell\"\>"}], ":", 
  " ", "\<\"Possible spelling error: new symbol name \\\"\\!\\(Dist\\)\\\" is \
similar to existing symbols \\!\\({Disk, List}\\). \
\\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", ButtonStyle->\\\"RefGuideLinkText\
\\\", ButtonFrame->None, ButtonData:>\\\"General::spell\\\"]\\)\"\>"}]], \
"Message"]
}, Open  ]],

Cell["\<\
Dot::usage = \"Dot[vector1,vector2] or vector1 . vector2
performs the dot product of two vectors (or a vector
and a dyadic).\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Dyadic::usage = \"A dyadic may be performed by using
vector1 ** vector2.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
EOM::usage = \"EOM[] generates the equations of motion. EOM[Simplify->On] \
applies simplification at low levels to attempt to generate more compact \
equations, but at the expense of more execution time.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
FindEquil::usage = \"FindEquil[ eqn, {x,x0} ] finds the equilibrium point in \
the given equation, for variable x. The initial guess of x0 is used to start \
a Newton search. For a list of equations, use FindEquil[ eqns, {x,x0}, \
{y,y0},...] to find equilibrium points in several variables x, y,...\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Fixed::usage = \"A Fixed joint is a zero degree-of-freedom joint. Its axes \
can be offset from those of the base reference frame using the Offset option. \
Offset may be a matrix of direction cosines or a list of vectors specifying \
the offset axes in terms of the base frame.  Examples: \
Offset->{{0,1,0},{1,0,0},{0,0,1}}, Offset->{body[2],body[1],body[3]}. A Fixed \
joint has no generalized speeds or coordinates associated with it.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Force::usage = \"Force[body] returns a list of the forces acting on the body.\
\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Frames::usage = \"Frames returns a list of the currently defined reference \
frames.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
GActFrc::usage = \"GActFrc[body,n] returns the generalized active force of \
body with respect to the nth generalized speed. GActFrc[body] returns the \
generalized active forces for body with respect to each of the generalized \
speeds. GActFrc[All] returns the sum of the generalized active forces for all \
bodies, with respect to each of the generalized speeds.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Gimbal::usage = \"A Gimbal joint is a three degree-of-freedom rotatory joint. \
Its home position is coincident with the base reference frame (the frame of \
the inboard body). The generalized coordinates describing the rotations are \
the successive rotation angles about the three specified rotation axes, \
described by options Axis1, Axis2, and Axis3. Use Ball if euler parameters \
are preferred as generalized coordinates. Axes may be specified by coordinate \
number, or a list of direction cosines. Examples: Axis1->3, Axis2->1, \
Axis3->2; Axis1->{0,0,1}, Axis2->{0,.707,.707}, Axis3->{.707,0,.707}.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
GInerFrc::usage = \"GInerFrc[body,n] returns the generalized
inertia force of body with respect to the nth generalized
speed. GInerFrc[body] returns the generalized inertia forces
for body with respect to each of the generalized speeds.
GInerFrc[All] returns the sum of the generalized inertia
forces for all bodies, with respect to each of the
generalized speeds.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
ground::usage = \"ground is the default Newtonian reference frame, which all \
other frames are defined relative to.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Hinge::usage = \"A Hinge joint is a single degree-of-freedom rotatory joint. \
The axis about which the joint rotates is specified by the option Axis, which \
may be the coordinate number, a list of direction cosines, or a vector in the \
base reference frame (the frame of the inboard body).  Examples: Axis->3, \
Axis->{0,0,1}, Axis->body[1]. The generalized speed, Udof, is defined to be \
the time-derivative of generalized coordinate Qdof.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
InbToJnt::usage = \"InbToJnt[body] is the vector from the center of mass of \
the inboard body to the joint connecting it to the argument body.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Inboard::usage = \"Inboard[body] returns the name of the body inboard to the \
argument.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Inertia::usage = \"Inertia[body] is the inertia dyadic of the body.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
JntToJnt::usage = \"JntToJnt[body] is the vector from the joint of the \
inboard body to the joint of the outboard body. This vector is used \
internally with slider joints.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Joints::usage = \"The following joint types are supported: Hinge, Ball, \
Slider, Fixed, Gimbal, SixDOF, UJoint. For more information, use ? followed \
by the joint type.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Kids::usage = \"Kids[frame] returns a list of reference frames below the \
argument's entry in the frame tree.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Kinematics::usage = \"Kinematics returns the set of kinematical differential \
equations.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
LinMom::usage = \"LinMom[body] is the linear momentum of the body. \\
LinMom[{body1,body2,...}] is the linear momentum of the system \\
consisting of the bodies listed.\"; \
\>", "Input",
 InitializationCell->True],

Cell["Mass::usage = \"Mass[body] is the mass of the body.\";", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
MassMatrix::usage = \"MassMatrix[eom] returns the mass matrix and other terms \
from the specified equations of motion.\"; \
\>", "Input",
 InitializationCell->True],

Cell["\<\
NewModel::usage = \"NewModel[] initializes the Dynamics
Workbench for a new model. The generalized coordinates
and generalized speeds, and information regarding bodies
and reference frames are all cleared. NewModel[Zees->On] indicates that the \
subsequent model is to be constructed with intermediate terms stored in the \
'zees' variable\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Nonholonomic::usage = \"Nonholonomic returns a list of the nonholonomic \
constraints.  These include holonomic constraints rising from closed-loop \
mechanisms, which are treated as if they were nonholonomic and therefore \
expressed in differential form.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Offset::usage = \"Offset->axeslist is an option to AddFrame which offsets the \
new reference frame with respect to the base frame.  The default is no \
offset.  Offset is specified as the coordinates of each of the new frame's \
axes, in terms of the base frame.  These may specified as vectors, a list of \
three lists of direction cosines, or a list of three axis numbers.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Parents::usage = \"Parents[frame] returns a list of reference frames above \
the argument's entry in the frame tree.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PosCOM::usage = \"PosCOM[body] returns a vector describing the position of \
the center of mass of body with respect to the ground reference frame. \
PosCOM[{body1,body2,...}] returns the position of the center of mass of the \
system consisting of the bodies listed.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PosPnt::usage = \"PosPnt[point,body] returns the vector
describing the position of point (entered as a vector
relative to the center of mass) fixed to body.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PrtVel::usage = \"PrtVel[expr,n] or PrtVel[expr,u[n]] returns
the partial velocity of expression with respective to the
nth generalized speed.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PV::usage = \"PV[{c,frame,n}..}] is a head used by the Dynamics Workbench to \
denote vectors. Each 'Packaged Vector' is placed within this head and \
consists of a series of lists denoting a constant multiplied by a unit vector \
n of the reference frame: c frame[n]. PV's are not normally visible to users.\
\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["q::usage = \"q[n] refers to the nth generalized coordinate.\";", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
qdofs::usage = \"qdofs is a list of the currently defined generalized \
coordinates.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"qdots", "::", "usage"}], "=", 
   "\"\<qdots[qs] returns a list of qdots, of the form q[1]', q[2]', etc. for \
the specified coordinates.\>\""}], ";"}]], "Input",
 InitializationCell->True],

Cell["\<\
RelativeTo::usage = \"RelativeTo->frame is an option for AddBody which \
specifies an alternate reference frame which the new body's frame is \
referenced to.  The default for RelativeTo is the inboard body's frame.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
ResltF::usage = \"ResltF[body] returns the resultant of the forces
acting on the body.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
ResltT::usage = \"ResltT[body] returns the resultant of the
torques or moments acting on the body.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Rstar::usage = \"Rstar[body] returns the inertia forces acting on
body.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
SixDOF::usage = \"A SixDOF joint is a six degree-of- freedom joint which \
allows for full translational and rotational movement between bodies.  Its \
location ahd home position are specified by the BodyToJoint option. The \
translational axes are specified by TAxis1, TAxis2, and TAxis3. The \
translations along those axes are specified by generalized coordinates Qdof1, \
Qdof2, and Qdof3, and by generalized speeds Udof1, Udof2, and Udof3. The \
rotational orientation is described by four euler parameters, specified by \
generalized coordinates Qdof4 through Qdof7. The angular velocities about the \
base frame's axes are specified by generalized speeds Udof1, Udof2, and \
Udof3.\";  \
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Slider::usage = \"A Slider joint is a single degree-of- freedom prismatic \
joint. Its location and home position are specified by the BodyToJoint \
option. The translational axis is specified by TAxis, which may be a \
coordinate number, a list of direction cosines, or a vector in the base \
reference frame.  Examples: TAxis->3, TAxis->{0,0,1}, TAxis->body[1]. The \
generalized speed, Udof, is defined to be the time-derivative of generalized \
coordinate Qdof.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
SolveEqn::usage = \"SolveEqn[eqn, vars] solves a list of equations in eqn for \
the given variables, and puts them in order as an == expression. SolveEqn is \
useful if the -> expression returned by Solve is inconvenient.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
States::usage = \"States returns a list of all of the states
currently used in the model.\"; \
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["t::usage = \"t is time.\"; ", "Input",
 InitializationCell->True],

Cell["\<\
TAxis::usage = \"TAxis->taxis specifies a translational axis, and may be in \
the form of an axis number (1 through 3), a vector (e.g., ground[1]), or a \
list of unit vector coefficients (direction cosines). For joints with \
multiple translational axes, they are numbered TAxis1, TAxis2, etc.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Tmtx::usage = \"Tmtx[frame] is the transformation matrix which maps between \
frame and the inertial (ground) reference frame. Tmtx returns a list of \
coordinates of the three axes of frame, each in the form of a sublist \
comprising coefficients for axes of reference frame.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Torque::usage = \"Torque[body] returns a list of the torques acting on the \
body.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Tstar::usage = \"Tstar[body] returns the inertia torque acting on
body.\";\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["u::usage = \"u[n] refers to the nth generalized speed.\";", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
udofs::usage = \"udofs is a list of the currently defined generalized speeds.\
\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"udots", "::", "usage"}], "=", 
   "\"\<udots[us] returns a list of udots, of the form u[1]', u[2]', etc. for \
the specified speeds.\>\""}], ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"spell\"\>"}], ":", 
  " ", "\<\"Possible spelling error: new symbol name \\\"\\!\\(udots\\)\\\" \
is similar to existing symbols \\!\\({qdots, udofs}\\). \\!\\(\\*ButtonBox[\\\
\"More\[Ellipsis]\\\", ButtonStyle->\\\"RefGuideLinkText\\\", \
ButtonFrame->None, ButtonData:>\\\"General::spell\\\"]\\)\"\>"}]], "Message"]
}, Open  ]],

Cell["\<\
UJoint::usage = \"A Ujoint is a two degree-of-freedom rotatory joint. Its \
home position is coincident with the base reference frame (the frame of the \
inboard body). The generalized coordinates describing the rotations are the \
successive rotation angles about the two specified rotation axes, Axis1 and \
Axis2. The generalized speeds, Udof1 and Udof2, are defined to be the \
time-derivatives of the respective generalized coordinates, Qdof1 and \
Qdof2.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
VelCOM::usage = \"VelCOM[body] returns a vector describing the velocity of \
the center of mass of body with respect to the ground reference frame.  \
VelCOM[{body1, body2,...}] returns the velocity of the center of mass of the \
system consisting of the bodies listed.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
VelJnt::usage = \"VelJnt[body] returns the velocity of the point on the \
inboard body which corresponds to the location of the joint connecting the \
two.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
VelJnt2::usage = \"VelJnt2[body] returns the velocity of the point on body \
which instantaneously corresponds to the location of the joint between body \
and the inboard body. Used in slider joints.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
XDot::usage = \"XDot[eom, state] returns the state derivative evaluated using \
the provided equations eom, and the current state.  The command States \
describes the ordering of generalized coordinates and speeds in the state \
vector.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Z::usage = \"Z[n] refers to the nth zee variable, but does
not return the value. Use zees[[n]] to retrieve the value
of the intermediate expression. Use NewModel[Zees->On] to specify that zees \
should be formed.\";\
\>", "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"Zees", "::", "usage"}], "=", 
   "\"\<Zees->On is an option to NewModel that specifies that intermediate \
'zee' variable should be generated in order to make expressions shorter.  \
Z[n] refers to the nth zee variable, but does not return the value. Use \
zees[[n]] to retrieve the value of the intermediate expression. Use \
NewModel[Zees->On] to specify that zees should be formed.\>\""}], 
  ";"}]], "Input",
 PageWidth->PaperWidth,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"formtrigreplacements", "::", "usage"}], "=", 
   "\"\<formtrigreplacements[equations] returns a list of shorthand \
trigonometric replacements that could be used to condense the equations \
given. The output is of the form \
{Sin[q[1]]->\\\"s1\\\",Cos[q[2]]->\\\"c2\\\"}. Options include \
ArgReplacements->{{gamma,\\\"g\\\",alpha,\\\"alp\\\"}} for shortening other \
argument variables, and TrigReplacements->{{Sin,\\\"s\\\",{Cos,\\\"c\\\"}} \
for changing the default trigonometric function substitutions.\>\""}], 
  ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"formqureplacements", "::", "usage"}], "=", "\[IndentingNewLine]", 
   "\"\<formqureplacements returns a list of shorthand replacments for the \
q's, u's, and udot's, e.g. \
{q[1]\[Rule]\\\"q1\\\",u[1]->\\\"u1\\\",u[1]'->\\\"u1dot\\\"}.\>\""}], 
  ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"SymmetricQ", "::", "usage"}], "=", "\[IndentingNewLine]", 
   "\"\<SymmetricQ[M] returns True if M is a matrix.\>\""}], ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"ExportExpression", "::", "usage"}], "=", 
   "\"\<ExportExpression[expression, \\\"name\\\"] formats expression as \
Matlab code, producing a string that begins with 'name = ' followed by the \
expression. ExportExpression can export a matrix, a symmeric matrix, a list, \
or a scalar. Formatting options include EndLine\[Rule]\\\"\\\\n\\\", \
Continuator\[Rule]\\\"...\\\", LineLength\[Rule]78, Deliminator\[Rule]\\\" \\\
\", which specify the end-of-line character, line continuator, maximum line \
length of the output, and the deliminators where line breaks can occur \
(default to space character). The options to formtrigreplacements can also be \
used.\>\""}], ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"ExportCode", "::", "usage"}], "=", "\"\<\!\(\*
StyleBox[\"ExportCode\",
FontWeight->\"Bold\"]\)\!\(\*
StyleBox[\" \",
FontWeight->\"Bold\"]\)writes a Matlab function to evaluate the \
state-derivative. Features include substitution of q's and u's for the state \
x, and substitution of shorthand trig functions such as s1 for sin(q(1)). \
ExportCode[{massmatrix,rhs}] uses the mass matrix and right-hand side given \
(usually found using MassMatrix[]). Alternatively, ExportCode[equations] will \
call MassMatrix[] automatically. Several optional arguments may be given. \
Forces\[Rule]{T1,T2} specifies forces that enter linearly into the equations; \
ExportCode will export a matrix of coefficients for these forces. Another \
option is Expressions\[Rule]{{KE,\\\"KE\\\"},{PE,\\\"PE\\\"}}, which outputs \
the specified additional expressions, named with the strings given. Each \
expression must be paired with a name within a list. The output of ExportCode \
can be sent to a file with OutputFile\[Rule]\\\"filename\\\", which is \
automatically produced in the current directory. Formatting options include \
EndLine\[Rule]\\\"\\\\n\\\", Continuator\[Rule]\\\"...\\\", \
LineLength\[Rule]78, Delimiter\[Rule]\\\" \\\", which specify the end-of-line \
character, line continuator, maximum line length of the output, and the \
delimiters where line breaks can occur (default to space character). The \
options to formtrigreplacements can also be used.\>\""}], ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"LinearTerms", "::", "usage"}], "=", 
   "\"\<LinearTerms[expressions,terms] returns a matrix of linear \
coefficients of the variables listed in terms,that appear in the expressions \
(also a list) given. One option is Simplifier\[Rule]Simplify, which causes \
the specified function to be applied to the matrix. Also see UnLinearTerms.\>\
\""}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"UnLinearTerms", "::", "usage"}], "=", 
   "\"\<UnLinearTerms[expressions,terms] returns all of the remaining terms \
that are not linear in the LinearTerms. One option is Simplifier->Simplify, \
which causes the specified function to be applied to the output.\>\""}], 
  ";"}]}], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"fmtString", "::", "usage"}], "=", 
   "\"\<fmtString[string] reformats a long String argument and tries to break \
it into a bunch of lines with a Matlab (or other) continuator,so that the \
output is fairly readable code. Options include EndLine\[Rule]\\\"\\\\n\\\" \
(end of line character), Continuator\[Rule]\\\"...\\\" (Matlab or other line \
continuator), LineLength\[Rule]78 (max line length), Delimiter\[Rule]\\\" \
\\\" (look for spaces to break lines on; lists of delimiters are also \
acceptable here).\>\""}], ";"}]], "Input",
 InitializationCell->True]
}, Open  ]],

Cell["\<\
Clear[Axis1,Axis2,Axis3,TAxis1,TAxis2,TAxis3,
\tUdof,Udof1,Udof2,Udof3,Udof4,Udof5,Udof6,
\tQdof,Qdof1,Qdof2,Qdof3,Qdof4,Qdof5,Qdof6,Qdof7
\t];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["Begin[\"`Private`\"];", "Input",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["Simple Utility Functions", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[TextData[{
 StyleBox["AngVel[ frme1, frme2 ]",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " returns the angular velocity of frme1 relative to frme2"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
AngVel[ frme1_, frme2_ ] := AngVel[ frme1 ] - AngVel[ frme2 ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["Common",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " returns the leftmost identical elements between two lists"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
Common[a_List, b_List] := Module[
\t{n = Min[ Length[a], Length[b] ]},
\tPart[ a, Flatten[ Position[
\t\tMapThread[ SameQ, {Take[a,n], Take[b,n]} ], True
\t\t] ] ]
]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["Uncommon1",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " takes list ",
 StyleBox["a",
  FontSlant->"Plain"],
 ", and removes the leftmost common elements between ",
 StyleBox["a",
  FontSlant->"Plain"],
 " and ",
 StyleBox["b",
  FontSlant->"Plain"],
 ".  Example: ",
 StyleBox["a = {x, y, z}, b = {x, t, u},",
  FontSlant->"Plain"],
 " ",
 StyleBox["Uncommon1[ a, b ] = {y, z}",
  FontSlant->"Plain"]
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
Uncommon1[a_List, b_List] := Module[
\t{n = Min[ Length[a], Length[b] ]},
\tDelete[ a, Position[
\t\tMapThread[ SameQ, {Take[a,n], Take[b,n]} ], True
\t\t] ]
]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["Uncommon2",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " takes list ",
 StyleBox["b",
  FontSlant->"Plain"],
 ", and removes the leftmost common elements between ",
 StyleBox["a",
  FontSlant->"Plain"],
 " and ",
 StyleBox["b",
  FontSlant->"Plain"],
 ".  Example: ",
 StyleBox["a = {x, y, z}, b = {x, t, u},",
  FontSlant->"Plain"],
 " ",
 StyleBox["Uncommon1[ a, b ] = {t, u}",
  FontSlant->"Plain"]
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
Uncommon2[a_List, b_List] := Module[
\t{n = Min[ Length[a], Length[b] ]},
\tDelete[ b, Position[
\t\tMapThread[ SameQ, {Take[a,n], Take[b,n]} ], True
\t] ]
]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["Wrap",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " is a hack that forces ",
 StyleBox["Map",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " to work on an empty list, without which ",
 StyleBox["Map",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " does not apply any function"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
Wrap[ {} ] = {{}};
Wrap[ a_List ] := a;\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["Mod3",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " performs modulus on the ring {1,2,3}"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["Mod3[ n_Integer ] := Mod[ n-1, 3] + 1;", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["Normed",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " gives the normalized (magnitude 1) vector v"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["Normed[ v_ ] := v / PowerExpand[ Sqrt[ v.v ] ];", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["NormV[ v_ ] := PowerExpand[ Sqrt[ v.v ] ];", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
NormV[ x:PV[__] ] := PowerExpand[ Sqrt[ Simplify[ Apply[ Plus, Map[ #^2 &, 
\tMap[ #[[1]]&, CastV[x, ground ] ] ] ] ] ] ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["Normed[ x:PV[__] ] := x / NormV[ x ];", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["CoordQ",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " determines whether the input is between 1 and 3"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["CoordQ[ n_ ] := IntegerQ[n] && Abs[n] >= 1 && Abs[n] <=3;", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[TextData[{
 StyleBox["TripleQ",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " determines whether the input is a vector of length 3"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["TripleQ[ v_ ] := VectorQ[v] && Length[v] == 3;", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[TextData[{
 StyleBox["PrincipalAxisQ",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " determines whether the input is a vector of length 3 which is either \
{0,0,1}, {0,1,0}, or {1,0,0}"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
PrincipalAxisQ[ x:{_,_,_} ] := Count[x,1] == 1 &&
\tCount[x,0] == 2;\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["VecToList",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " and ",
 StyleBox["ListToVec",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 "convert between list and packaged vector \nrepresentations of vectors"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
VecToList[ vec_, frame_ ] := {vec . frame[1], vec . frame[2],
  vec . frame[3]};\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
ListToVec[ lis_, frame_ ] := lis[[1]] frame[1] +
  lis[[2]] frame[2] + lis[[3]] frame[3];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["ConvertVec",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " is used to convert any of the possible three forms for\nvectors into the \
standard packaged vector form"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
ConvertVec[ coord_?CoordQ, frme_ ] := ListToVec[ 
\tSign[coord]*RotateRight[{0,0,1},Abs[coord]], frme ];
ConvertVec[ axis_?TripleQ, frme_ ] := 
\tListToVec[ Normed[axis], frme ];
ConvertVec[ x:PV[__], frme_ ] := 
\tx 1/Sqrt[(x.frme[1])^2+(x.frme[2])^2+(x.frme[3])^2];
ConvertVec[l:{(_?TripleQ)..}, frme_ ] :=
\tMap[ ConvertVec[#,frme]&, l ]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["ConvertList",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " is used to convert any of the possible three forms for\nvectors into a \
list form in the specified frame"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
ConvertList[ coord_?CoordQ, frme_ ] :=
\tSign[coord]*RotateRight[{0,0,1},Abs[coord]];
ConvertList[ axis_?TripleQ, frme_ ] :=
\tNormed[axis];
ConvertList[ x:PV[__], frme_ ] :=
\tVecToList[
\t\tx 1/Sqrt[(x.frme[1])^2+(x.frme[2])^2+(x.frme[3])^2], frme];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["ConvertOffset",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " is used to convert one of the two possible forms for a reference frame \
offset. Input can be a transformation matrix, or a list describing the \
coordinates of each of the offset axes in the base reference frame."
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
ConvertOffset[M_?MatrixQ,frme_] := M;
ConvertOffset[{x_?CoordQ,y_?CoordQ,z_?CoordQ},frme_]:={ConvertList[x,frme],\
ConvertList[y,frme],ConvertList[z,frme]};
ConvertOffset[{x:PV[__],y:PV[__],z:PV[__]},frme_] :=
\t{VecToList[x,frme],VecToList[y,frme],VecToList[z,frme]};\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["ConvertInertia",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " is used to convert any of the possible three forms for inertia matrices \
into a dyadic form in the specified frame"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
ConvertInertia[I_?VectorQ,frme_] := I[[1]] frme[1]**frme[1] +
\tI[[2]] frme[2]**frme[2] + I[[3]] frme[3]**frme[3];
ConvertInertia[I_?MatrixQ,frme_] := Apply[ Plus, Flatten[ Outer[ 
\tNonCommutativeMultiply, Array[frme,3], Array[frme,3] ] ] *
\tFlatten[ I ] ];
ConvertInertia[x:PV[__],frme_] := x;
ConvertInertia[0|0.,frme_]:=PV[{PV[{0,frme,1}],frme,1}];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 "If no dof number is assigned, ",
 StyleBox["PickDof",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " is used to assign one automatically, based on the lowest number which is \
not already taken"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
PickDof[dofs_List] :=
\tFirst[ Complement[ Range[ Length[dofs]+1 ], dofs ] ];
PickDof[dofs_List, num_?NumberQ] :=
\tTake[ Complement[ Range[ Length[dofs]+num ], dofs ], num ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["ReplaceDofs",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " takes a list of new dofs, and assigns the ones marked Automatic with new \
dofs which do not appear in the useddofs or newdofs lists."
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
ReplaceDofs[ newdofs_, useddofs_ ] := replDofs[ newdofs, 
\tFlatten[ Position[ newdofs, Automatic ] ],
\tPickDof[ Union[ Complement[ newdofs, {Automatic}],useddofs], 
\t  Count[ newdofs, Automatic ] ] ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["replDofs[ newdofs_, {}, {}] := newdofs;", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
replDofs[ newdofs_List, loc:{_}, val:{_}] :=
\tReplacePart[ newdofs, val[[1]], loc];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
replDofs[ newdofs_, loc_List, val_List ] :=
\treplDofs[ ReplacePart[ newdofs, val[[1]], loc[[1]] ],
\t\tDrop[loc, 1], Drop[val, 1] ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
replacesin = {
\tc_. Sin[x_] Cos[y_] + c_. Cos[x_] Sin[y_] -> c Sin[x+y],
\tc_. Sin[x_] Cos[y_] + d_. Cos[x_] Sin[y_] /; d===-c-> c Sin[x-y]};\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
replacecos = {
\tc_. Cos[x_] Cos[y_] + c_. Sin[x_] Sin[y_] -> c Cos[x-y],
\tc_. Cos[x_] Cos[y_] + d_. Sin[x_] Sin[y_] /; d===-c-> c Cos[x+y]};\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
replace2SC = {a_. Cos[x_] + b_. Cos[x_] -> (a+b) Cos[x],
a_. Sin[x_] + b_. Sin[x_] -> (a+b) Sin[x]};\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["replaceSC2 = {a_. Cos[x_]^2 + a_. Sin[x_]^2-> a};", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["replaceUs = {c_. u[n_] + d_. u[n_] -> (c+d) u[n]};", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["AtT0",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " is a simple function to enable use of this"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
AtT0[ expr_ ] := expr /. t->0;
AtT0[ expr__ ] := Flatten[{expr}] /. t->0;\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["FindEquil",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " finds an equilibrium point for one or more equations"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
FindEquil[ eqn_, args:{_, _}.. ] :=
\tFindRoot[ Evaluate[eqn], args ]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["Mass",
  FontWeight->"Bold"],
 " returns the masses of a bunch of bodies"
}], "Text"],

Cell["Mass[(bodies_)?ListQ] := Mass /@ bodies; ", "Input",
 InitializationCell->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["VelCOM",
  FontWeight->"Bold"],
 " returns the velocity of the center of mass of a collection of bodies"
}], "Text"],

Cell["\<\
VelCOM[(bodies_)?ListQ] := 
  Simplify[Plus @@ (Mass /@ bodies*VelCOM /@ bodies)/
    Plus @@ Mass /@ bodies]\
\>", "Input",
 InitializationCell->True]
}, Open  ]],

Cell[CellGroupData[{

Cell["Optional common stuff", "Subsubsection",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[TextData[{
 StyleBox["(* This is another way to do the ",
  FontWeight->"Plain",
  FontSlant->"Italic"],
 "common",
 StyleBox[" functions above,\n   but it makes fewer assumptions of the form \
of the\n   input lists *)",
  FontWeight->"Plain",
  FontSlant->"Italic"]
}], "Input",
 AspectRatioFixed->True],

Cell["common[a_List, b_List] := Select[ a, MemberQ[b, #]& ]", "Input",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["uncommon1[a_List, b_List] := Select[ a, FreeQ[b, #]& ]", "Input",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["uncommon2[a_List, b_List] := Select[ b, FreeQ[a, #]& ]", "Input",
 Evaluatable->False,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["SymmetricQ",
  FontWeight->"Bold"],
 " tests if a matrix is symmetric."
}], "Text"],

Cell["SymmetricQ[(m_List)?MatrixQ] := m === Transpose[m]", "Input",
 InitializationCell->True]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Vectors", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[TextData[{
 "All vectors are packaged together and tagged with ",
 StyleBox["PV",
  FontWeight->"Bold"],
 "."
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
(*PV/: Times[c_ /; FreeQ[c,PV],PV[{a_,frme_,n_}] ] :=
\tPV[{a c,frme,n}]; *)
Timespkg[c_,{x_,y_,z_}] := {c x, y, z};
PV/: Times[c_ /; FreeQ[c,PV], PV[args__] ] :=
\tMap[ Timespkg[c,#]&, PV[args] ];
PV/: Plus[ PV[x:{_,_,_}..], PV[y:{_,_,_}..] ] := 
\tPV[x,y];
PV[{0,_,_}] := 0;
PV[{0,_,_},rest__] := PV[rest];
PV[rest1__,{0,_,_},rest2__] := PV[rest1,rest2];
PV[r1___,{c1_ /; FreeQ[c1,PV],frme_,n_},r2___,
\t {c2_ /; FreeQ[c2,PV],frme_,n_},r3___] :=
\t PV[r1,r2,r3,{c1+c2,frme,n}];
(*PV[r1:{_,_,_}...,{c1_ /; FreeQ[c1,PV],frme_,n_},r2:{_,_,_}...,
     {c2_ /; FreeQ[c2,PV],frme_,n_},rest___] :=
\tPV[{c1+c2,frme,n},r1,r2,rest] ;*)
SetAttributes[PV, Orderless];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell[TextData[{
 "Though vectors are tagged with a head ",
 StyleBox["PV",
  FontWeight->"Bold"],
 ", meaning that they are packaged, the output form is set so that vectors \
look the same way as they are input"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
If[ TrueQ[ $VersionNumber >= 3.],
\tFormat[outV[{c_,v_,n_}]] := 
\t\tHoldForm[c Subscript[UnderBar[v],n] ];
\tFormat[outV[{1,v_,n_}] ]  := Subscript[UnderBar[v],n],
(*else *)
\tFormat[outV[{c_,v_,n_}] ] :=
\t\tHoldForm[c Subscripted[v[n]] ];
\tFormat[outV[{1,v_,n_}] ]  := HoldForm[Subscripted[v[n]] ] ];
(*Format[PV[x:{0,_,_}]] := 0;*)
Format[PV[x:{_,_,_}..] ] := Apply[ Plus, Map[ outV, {x}] ];
\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 StyleBox["CollectV",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " does garbage collection of packaged vectors, combining coefficients of \
identical elements"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["SetAttributes[CollectV,Orderless]", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"spell\"\>"}], ":", 
  " ", "\<\"Possible spelling error: new symbol name \
\\\"\\!\\(CollectV\\)\\\" is similar to existing symbols \\!\\({Collect, \
CollectE}\\). \\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", \
ButtonStyle->\\\"RefGuideLinkText\\\", ButtonFrame->None, \
ButtonData:>\\\"General::spell\\\"]\\)\"\>"}]], "Message"]
}, Open  ]],

Cell["\<\
CollectV[ PV[r1___,{c1_,frme_,n_},r2___,
\t{c2_,frme_,n_},r3___] ]:=
  CollectV[ PV[r1,r2,r3,{c1+c2,frme,n}] ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["CollectV[ PV[x__] ] := PV[x];", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Casting into Reference Frames", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[TextData[{
 StyleBox["CastMtx",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " returns the transformation matrix used to cast from one frame to another. \
It goes up the branches of the frame tree from the ",
 StyleBox["from",
  FontSlant->"Plain"],
 " frame up to the common parent to the two frames, and then down the \
branches to the ",
 StyleBox["to",
  FontSlant->"Plain"],
 " frame."
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
CastMtx[ from_, to_ ] :=
 \tApply[ Dot,
\t\tMap[ Tmtx, 
\t\t\tWrap[Reverse[Uncommon1[ Parents[to], Parents[from] ]] ] 
\t\t]
\t] ~ Dot ~
\t\tTranspose[ Apply[ Dot,
\t\tMap[ Tmtx, 
\t\t\tWrap[Reverse[Uncommon2[ Parents[to], Parents[from] ]] ]
\t\t]
\t] ] /. Join[replacesin,replacecos,replaceSC2,replace2SC]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[TextData[{
 StyleBox["CastV",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " will cast any vector into a target reference frame. It does this by \
casting each element one at a time, and adding the results. ",
 StyleBox["Cast1V",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " takes one element at a time, casts it into three elements of the target \
frame, and assembles the results in a ",
 StyleBox["PV",
  FontWeight->"Bold"]
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
CastV[ PV[x__], trgtfrme_ /; MemberQ[Frames, trgtfrme] ]:= 
\tSimplify[ Apply[ Plus,
\t\tMap[ Cast1V[#,trgtfrme]&, {x}, 1] ] /. replaceSC2 ];
\t\t
CastV[ 0, trgtfrme_ ] := 0;\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
Cast1V[ {c_,frme_,n_}, trgtfrme_ ] := Apply[PV,
\tMapThread[List,{c*CastMtx[trgtfrme,frme][[n]],
\t\t{trgtfrme,trgtfrme,trgtfrme},{1,2,3}}] ] ;\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[TextData[{
 StyleBox["CML",
  FontWeight->"Bold"],
 " is the castmatrixlist, which is a way to memorize all the transformation \
matrices as they are computed, so nothing needs to be repeated."
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"CML", "[", 
   RowBox[{"from_", ",", "to_"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"frame1", ",", "frame2"}], "}"}], ",", 
    RowBox[{
     RowBox[{
      RowBox[{"{", 
       RowBox[{"frame1", ",", "frame2"}], "}"}], "=", 
      RowBox[{"Sort", "[", 
       RowBox[{"{", 
        RowBox[{"from", ",", "to"}], "}"}], "]"}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"If", "[", 
       RowBox[{
        RowBox[{"OrderedQ", "[", 
         RowBox[{"{", 
          RowBox[{"from", ",", "to"}], "}"}], "]"}], ",", "Identity", ",", 
        "Transpose"}], "]"}], "[", 
      RowBox[{
       RowBox[{"CML", "[", 
        RowBox[{"frame1", ",", "frame2"}], "]"}], "=", 
       RowBox[{"CastMtx", "[", 
        RowBox[{"frame1", ",", "frame2"}], "]"}]}], "]"}]}]}], 
   "]"}]}]], "Input",
 InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Dot Products", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["Dot products using CenterDot, defined at the top level", "Subsection"],

Cell["\<\
Definition of zero dot products, to make sure that vectors with length 0 or \
0. evaluate to zero dot product. \
\>", "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{"PV", "/:", 
   RowBox[{"CenterDot", "[", 
    RowBox[{
     RowBox[{"0", "|", "0."}], ",", 
     RowBox[{"PV", "[", "__", "]"}]}], "]"}], "=", "0"}], ";"}], "\n", 
 RowBox[{
  RowBox[{"PV", "/:", 
   RowBox[{"CenterDot", "[", 
    RowBox[{
     RowBox[{"PV", "[", "__", "]"}], ",", 
     RowBox[{"0", "|", "0."}]}], "]"}], "=", "0"}], ";"}]}], "Input",
 Evaluatable->False],

Cell["Vectors dotted with a dyadic, and vice versa", "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{"PV", "/:", 
   RowBox[{"CenterDot", "[", 
    RowBox[{
     RowBox[{"x", ":", 
      RowBox[{"PV", "[", 
       RowBox[{"{", 
        RowBox[{"_", ",", "_", ",", "_"}], "}"}], "]"}]}], ",", 
     RowBox[{"PV", "[", 
      RowBox[{"{", 
       RowBox[{
        RowBox[{"y", ":", 
         RowBox[{"PV", "[", 
          RowBox[{"{", 
           RowBox[{"_", ",", "_", ",", "_"}], "}"}], "]"}]}], ",", "frame2_", 
        ",", "coord2_"}], "}"}], "]"}]}], "]"}], ":=", 
   RowBox[{"PV", "[", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"CenterDot", "[", 
       RowBox[{"x", ",", "y"}], "]"}], ",", "frame2", ",", "coord2"}], "}"}], 
    "]"}]}], ";"}]], "Input",
 Evaluatable->False],

Cell[BoxData[
 RowBox[{
  RowBox[{"PV", "/:", 
   RowBox[{"CenterDot", "[", 
    RowBox[{
     RowBox[{"PV", "[", 
      RowBox[{"{", 
       RowBox[{
        RowBox[{"PV", "[", 
         RowBox[{"{", 
          RowBox[{"c1_", ",", "frame1_", ",", "coord1_"}], "}"}], "]"}], ",", 
        "frame2_", ",", "coord2_"}], "}"}], "]"}], ",", 
     RowBox[{"x", ":", 
      RowBox[{"PV", "[", 
       RowBox[{"{", 
        RowBox[{"_", ",", "_", ",", "_"}], "}"}], "]"}]}]}], "]"}], ":=", 
   RowBox[{"PV", "[", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"CenterDot", "[", 
       RowBox[{
        RowBox[{"PV", "[", 
         RowBox[{"{", 
          RowBox[{"c1", ",", "frame2", ",", "coord2"}], "}"}], "]"}], ",", 
        "x"}], "]"}], ",", "frame1", ",", "coord1"}], "}"}], "]"}]}], 
  ";"}]], "Input",
 Evaluatable->False],

Cell["Distributive property of dot products", "Text"],

Cell[BoxData[
 RowBox[{"PV", "/:", 
  RowBox[{"CenterDot", "[", 
   RowBox[{
    RowBox[{"PV", "[", 
     RowBox[{"x", ":", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"_", ",", "_", ",", "_"}], "}"}], ".."}]}], "]"}], ",", 
    RowBox[{"PV", "[", 
     RowBox[{"y", ":", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{"_", ",", "_", ",", "_"}], "}"}], ".."}]}], "]"}]}], "]"}], ":=", 
  RowBox[{
   RowBox[{"Apply", "[", 
    RowBox[{"Plus", ",", 
     RowBox[{"Flatten", "[", 
      RowBox[{"Outer", "[", 
       RowBox[{"CenterDot", ",", 
        RowBox[{"Map", "[", 
         RowBox[{"PV", ",", 
          RowBox[{"{", "x", "}"}]}], "]"}], ",", 
        RowBox[{"Map", "[", 
         RowBox[{"PV", ",", 
          RowBox[{"{", "y", "}"}]}], "]"}]}], "]"}], "]"}]}], "]"}], "/;", 
   RowBox[{
    RowBox[{
     RowBox[{"Length", "[", 
      RowBox[{"{", "x", "}"}], "]"}], "+", 
     RowBox[{"Length", "[", 
      RowBox[{"{", "y", "}"}], "]"}]}], ">", "2"}]}]}]], "Input",
 Evaluatable->False],

Cell["\<\
Dot products of two vectors on the same unit vector is just their product\
\>", "Text"],

Cell["\<\
PV/: CenterDot[PV[{c1_,frame_,coord_}],PV[{c2_,frame_,coord_}]]:=c1*c2\
\>", "Input",
 Evaluatable->False,
 InitializationCell->True],

Cell["\<\
Dot product of two vectors in the same reference frame, but different axes, \
is zero\
\>", "Text"],

Cell["\<\
PV/: CenterDot[PV[{c1_,frame_,coord1_}],PV[{c2_,frame_,coord2_}]]:=0\
\>", "Input",
 Evaluatable->False,
 InitializationCell->True]
}, Closed]],

Cell[TextData[{
 "Dot products are performed by overloading the ",
 StyleBox["Dot",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " operator for ",
 StyleBox["PV",
  FontWeight->"Bold"],
 " objects. The overloading implements a distributed function on ",
 StyleBox["DotV",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 ", which extracts the dot product of two elements from the transformation \
matrix"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["CenterDot defined to refer to DotV", "Subsection"],

Cell[BoxData[
 RowBox[{
  RowBox[{"PV", "/:", 
   RowBox[{"CenterDot", "[", 
    RowBox[{
     RowBox[{"PV", "[", 
      RowBox[{"x", ":", 
       RowBox[{
        RowBox[{"{", 
         RowBox[{"_", ",", "_", ",", "_"}], "}"}], ".."}]}], "]"}], ",", 
     RowBox[{"PV", "[", 
      RowBox[{"y", ":", 
       RowBox[{
        RowBox[{"{", 
         RowBox[{"_", ",", "_", ",", "_"}], "}"}], ".."}]}], "]"}]}], "]"}], ":=", 
   RowBox[{
    RowBox[{"Apply", "[", 
     RowBox[{"Plus", ",", 
      RowBox[{"Distribute", "[", 
       RowBox[{
        RowBox[{"DotV", "[", 
         RowBox[{
          RowBox[{"{", "x", "}"}], ",", 
          RowBox[{"{", "y", "}"}]}], "]"}], ",", "List"}], "]"}]}], "]"}], "/.", 
    RowBox[{"Join", "[", 
     RowBox[{
     "replacesin", ",", "replacecos", ",", "replaceSC2", ",", "replace2SC"}], 
     "]"}]}]}], ";"}]], "Input",
 InitializationCell->True],

Cell["\<\
PV/: CenterDot[ 0 | 0., PV[__] ] = 0;
PV/: CenterDot[ PV[__], 0 | 0.] = 0;
CenterDot[ 0 | 0., 0 | 0.] = 0;\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["Dot overloaded to refer to DotV", "Subsection"],

Cell["\<\
Unprotect[ Dot ];
Dot[ 0 | 0., 0 | 0.] = 0;
Protect[ Dot ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PV/: Dot[ PV[x:{_,_,_}..], PV[y:{_,_,_}..] ] :=
\tApply[Plus, Distribute[ DotV[{x},{y}], List ] ] /.
\tJoin[replacesin,replacecos,replaceSC2,replace2SC];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PV/: Dot[ 0 | 0., PV[__] ] = 0;
PV/: Dot[ PV[__], 0 | 0.] = 0;\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
DotV[x:{_,_,_},{PV[y:{_,_,_}],frame2_,coord2_}] :=
\tPV[ {DotV[x,y], frame2, coord2} ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
(*DotV[{PV[y:{_,_,_}],frame2_,coord2_},x:{_,_,_}] :=
\tPV[ {DotV[x,y], frame2, coord2} ]; *)
DotV[{PV[y:{c1_,frame1_,coord1_}],frame2_,coord2_},x:{_,_,_}]:=
    PV[{DotV[{c1,frame2,coord2},x],frame1,coord1}];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
DotV[{c1_,frame1_?(MemberQ[Frames,#]&),coord1_},
     {c2_,frame2_?(MemberQ[Frames,#]&),coord2_}] :=
\t   c1 c2 CML[frame1,frame2][[coord2,coord1]]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Cross Products", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[TextData[{
 StyleBox["Cross",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " products are given in the reference frame of the second argument. This is \
performed by breaking the 2nd arg into elementary ",
 StyleBox["PV",
  FontWeight->"Bold"],
 "s, and using ",
 StyleBox["CrossV",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 ", which requires that its inputs are in the same frame. ",
 StyleBox["CrossV",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " takes each element of the 1st arg and crosses with the elemental 2nd arg"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
If[ TrueQ[ $VersionNumber >= 3. ],
\tUnprotect[Cross] ];
Cross[ PV[x:{_,_,_}..], PV[y:{_,_,_}..] ] :=
\tModule[{
\t\tlftarg = Map[ CastV[ PV[x], #]&, Transpose[{y}][[2]] ],
\t\trgtarg = Map[ PV, {y} ]},
\t\tApply[Plus, MapThread[ CrossV, {lftarg, rgtarg} ] ]
\t];
\t
Cross[ expr_, 0 | 0.] := 0;
Cross[ 0 | 0., expr_ ] := 0;
Cross[ 0 | 0., 0 | 0.] := 0;\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
CrossV[PV[{c1_,frme_,n1_}],
\tPV[{c2_,frme_,n2_}]] :=
\tPV[{{ c1 c2, frme, Mod3[n1+2]},
\t {-c1 c2, frme, Mod3[n1+1]},
\t {     0, frme, n1 }}[[Mod3[n2-n1]]] ] /.
\tJoin[replacesin,replacecos,replaceSC2,replace2SC];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
CrossV[PV[x:{_,frme_,_}..],PV[y:{_,frme_,_}] ] :=
\tApply[ Plus, Map[ CrossV[ PV[#], PV[y] ]&, {x}] ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
CrossV[ 0 | 0., PV[__] ] := 0;
CrossV[ PV[__], 0 | 0. ] := 0;\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["X[x_,y_] := Cross[x,y];", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Dyadics", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[TextData[{
 "To assemble dyadics, it is necessary to use a ",
 StyleBox["NonCommutativeMultiply",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " to hold two vectors in the right order: ",
 StyleBox["r=a[1]**a[2]",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " can be used so that later, ",
 StyleBox["r.b[1]",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " gives the right result"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
PV/: PV[{x1_,x2_,x3_}] ** PV[{y1_,y2_,y3_}] :=
\tPV[{y1 PV[{x1,x2,x3}],y2,y3}]

PV/: PV[x:{_,_,_}..]**PV[y:{_,_,_}..] := Apply[ Plus,
\tDistribute[Map[ PV, {x} ] ** Map[ PV, {y} ], List ] ]
\t
PV/: PV[__] ** (0 | 0.) := 0;
PV/: (0 | 0.) ** PV[__] := 0;\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Generalized Coordinates and Speeds", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
u[n_] = ut[n][t];
q[n_] = qt[n][t];
SetAttributes[u, Listable]
SetAttributes[ q, Listable ]\
\>", "Input",
 AspectRatioFixed->True],

Cell["\<\
u[n_] := ut[n][t];
If[ TrueQ[ $VersionNumber >= 3.],
\tFormat[ ut[n_][t] ] := Subscript[u,n];
\tFormat[ ut[n_]'[t] ] := Subscript[u,n]',
(*else *)
\tFormat[ ut[n_][t] ] := HoldForm[ Subscripted[u[n]] ];
\tFormat[ ut[n_]'[t] ] := HoldForm[ Subscripted[u[n]]']
]
\t
SetAttributes[ u, Listable ];
attr = If[ TrueQ[$VersionNumber >= 3.],
\tNHoldAll, NProtectedAll];
SetAttributes[ u, attr];
\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
q[n_] := qt[n][t];
If[ TrueQ[ $VersionNumber >= 3.],
\tFormat[ qt[n_][t] ] := Subscript[q,n];
\tFormat[ qt[n_]'[t] ] := Subscript[q,n]';
\tFormat[ qt[n_]''[t] ] := Subscript[q,n]'',
(* else *)
\tFormat[ qt[n_][t] ] := HoldForm[ Subscripted[q[n]] ];
\tFormat[ qt[n_]'[t] ] := HoldForm[ Subscripted[q[n]]'];
\tFormat[ qt[n_]''[t] ] := HoldForm[ Subscripted[q[n]]'']
];
SetAttributes[ q, Listable ];
SetAttributes[ q, attr ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
u[n_]' := ut[n]'[t];
q[n_]' := qt[n]'[t];
q[n_]'' := qt[n]''[t];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
If[ TrueQ[ $VersionNumber >= 3.],
\tFormat[ ut[n_][t_] ] := Subscript[u,n][t];
\tFormat[ qt[n_][t_] ] := Subscript[q,n][t];
\tFormat[ ut[n_]'[t_] ] := Subscript[u,n]'[t];
\tFormat[ qt[n_]'[t_] ] := Subscript[q,n]'[t];
\tFormat[ qt[n_]''[t_] ] := Subscript[q,n]''[t],
(* else *)
\tFormat[ ut[n_][t_] ] := HoldForm[Subscripted[u[n]][t]];
\tFormat[ qt[n_][t_] ] := HoldForm[Subscripted[q[n]][t]];
\tFormat[ ut[n_]'[t_] ] := HoldForm[Subscripted[u[n]]'[t]];
\tFormat[ qt[n_]'[t_] ] := HoldForm[Subscripted[q[n]]'[t]];
\tFormat[ qt[n_]''[t_] ] := HoldForm[Subscripted[q[n]]''[t]]
];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
u[n_][t_] := ut[n][t]
q[n_][t_] := qt[n][t]
u[n_]'[t_] := ut[n]'[t]
q[n_]'[t_] := qt[n]'[t]
q[n_]''[t_] := qt[n]''[t]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
SetAttributes[ ut, Listable ]
SetAttributes[ qt, Listable ]
SetAttributes[ ut, attr ];
SetAttributes[ qt, attr ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
udots[udofs_List] := Map[ ut[#]'[t]&, udofs ]
udots[udof_] := ut[udof]'[t]
qdots[qdofs_List] := Map[ qt[#]'[t]&, qdofs ]
qdots[qdof_] := qt[qdof]'[t]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["States := Join[ q[qdofs], u[udofs] ];", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Positions on Bodies", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
PosCOM[ body_ /; MemberQ[Bodies, body] ] :=
  PosCOM[ Inboard[body] ] + InbToJnt[body]+JntToJnt[body]-BodyToJnt[body];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PosCOM[(bodies_)?ListQ] := 
  Simplify[Plus @@ (Mass /@ bodies*PosCOM /@ bodies)/
    Plus @@ Mass /@ bodies]\
\>", "Input",
 InitializationCell->True],

Cell["PosPnt[ point_, body_ ] := PosCOM[ body ] + point;", "Input",
 PageWidth->Infinity,
 InitializationCell->True,
 ShowSpecialCharacters->False],

Cell["\<\
Dist[ pnt1_, pnt2_ ] :=
\tSimplify[ NormV[ Transpose[ Level[
\t\tCastV[ pnt2 - pnt1 , ground ], 1]][[1]] ] ]\
\>", "Input",
 InitializationCell->True]
}, Closed]],

Cell["Velocities on Bodes", "Section"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"VelPntFixed", "[", " ", 
    RowBox[{"point_", ",", " ", "body_"}], " ", "]"}], " ", ":=", " ", 
   RowBox[{
    RowBox[{"VelCOM", "[", " ", "body", " ", "]"}], " ", "+", " ", 
    RowBox[{"Cross", "[", "  ", 
     RowBox[{
      RowBox[{"AngVel", "[", " ", "body", " ", "]"}], ",", " ", "point"}], 
     "  ", "]"}]}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"AccPntFixed", "[", " ", 
    RowBox[{"point_", ",", " ", "body_"}], " ", "]"}], " ", ":=", " ", 
   RowBox[{
    RowBox[{"AccCOM", "[", " ", "body", " ", "]"}], " ", "+", " ", 
    RowBox[{"Cross", "[", " ", 
     RowBox[{
      RowBox[{"AngAcc", "[", " ", "body", " ", "]"}], ",", " ", "point"}], 
     " ", "]"}], " ", "+", " ", 
    RowBox[{"Cross", "[", " ", 
     RowBox[{"Cross", "[", " ", 
      RowBox[{
       RowBox[{"AngVel", "[", " ", "body", " ", "]"}], ",", " ", "point"}], 
      " ", "]"}], " ", "]"}]}]}], ";"}]}], "Input"],

Cell[CellGroupData[{

Cell["Derivative of Free Vector", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[TextData[{
 "Partial and total derivatives are computed separately. Partial derivatives \
of single or multiple vectors are found using ",
 StyleBox["D[ vector, scalar, in->frame, NonConstants->{functions} ]",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 ", where ",
 StyleBox["in",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " and ",
 StyleBox["NonConstants",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " are options. Option ",
 StyleBox["in",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " is used to specify the reference frame the partial derivative is desired \
in, and defaults to ",
 StyleBox["ground",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 ".\n\nTotal derivatives of a single or multiple vector are found using ",
 StyleBox["Dt[ vector, scalar, in->frame, Constants->{constants} ]",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 ", where ",
 StyleBox["in",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " and ",
 StyleBox["Constants",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " are options. Option ",
 StyleBox["in",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " is used to specify the reference frame the total derivative is desired in, \
and defaults to ",
 StyleBox["ground",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 ". If the angular velocities of all of the reference frames vector is \
defined in are themselves defined, the total time derivative is computed \
using those angular velocities."
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["Options[DPV] = { in->ground };", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PV/: D[ PV[{c_,frme_,n_}], x_, opts___Rule ] := Module[
\t{bfrme, ncons},
\tbfrme = in  /. {opts} /. Options[DPV];
\tncons = NonConstants /. {opts} /. NonConstants->{};
\tDprtl[ PV[{c,frme,n}], x, bfrme, NonConstants->ncons ] ];
PV/: D[ PV[vecs:{_,_,_}..], x_, opts___Rule] := Apply[ Plus,
\tMap[ D[ PV[#], x, opts]&, {vecs} ] ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PV/: Dprtl[ PV[{c_,frme_,n_}], t, bfrme_, opts___Rule] :=
\tModule[ {pv},
\t\tpv = Apply[ List, CastV[ PV[{c,frme,n}], bfrme ] ] /.
\t\t\t{q[k_] -> qh[k], u[k_] -> uh[k]};
\t\tApply[ PV, Transpose[
\t\t\tMapAt[ D[#,x,opts]&, Transpose[pv], 1] ] ] /.
\t\t\t\t{qh[k_]->q[k],uh[k_]->u[k]} ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PV/: Dprtl[ PV[{c_,frme_,n_}], x_, bfrme_, opts___Rule] :=
\tModule[ {pv},
\t\tpv = Apply[ List, CastV[ PV[{c,frme,n}], bfrme ] ];
\t\tApply[ PV, Transpose[
\t\t\tMapAt[ D[#,x,opts]&, Transpose[pv], 1] ] ] ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PV/: Dt[ PV[{c_,frme_,n_}], x_, opts___Rule] := Module[
\t {bfrme, cons},
\t bfrme = in /. {opts} /. Options[DPV];
\t cons = Constants /. {opts} /. Constants->{};
\t Dttl[ PV[{c,frme,n}], x, bfrme, Constants->cons ] ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PV/: Dt[ PV[v:{_,_,_}..], x_, opts___Rule] :=
\t  Apply[ Plus, Map[ Dt[ PV[#], x, opts]&, {v} ] ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PV/: Dttl[ PV[{c_,frme_,n_}], t, bfrme_, opts___Rule] :=
\tCross[ AngVel[frme,bfrme], PV[{c,frme,n}] ] +
\tPV[{Dt[c,t,opts],frme,n}] /; 
\t\tValueQ[AngVel[frme]] && ValueQ[AngVel[bfrme]]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PV/: Dttl[ PV[{c_,frme_,n_}], x_, bfrme_, opts___Rule] :=
\tModule[ {pv},
\t\tpv = Apply[ List, CastV[ PV[{c,frme,n}], bfrme ] ];
\t\tApply[ PV, Transpose[
\t\t\tMapAt[ Dt[#,x,opts]&, Transpose[pv], 1] ] ] ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["(* Older versions of derivatives *)", "Input",
 AspectRatioFixed->True],

Cell[BoxData["Null"], "Input"],

Cell["\<\
PV/: Dt[ PV[{c_,frme_,n_}], t, opts___] := 
  Cross[ AngVel[frme], PV[{c,frme,n}] ]+
  PV[{Dt[c,t,opts],frme,n}];
PV/: Dt[ PV[x:{_,_,_}..], t, opts___] :=
  Apply[ Plus, Map[ Dt[ PV[#], t, opts]&, {x} ] ];\
\>", "Input",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
PV/: D[ PV[{c_,frme_,n_}], t] :=
  Cross[ AngVel[frme], PV[{c,frme,n}] ]+
  PV[{D[c,t],frme,n}];\
\>", "Input",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
PV/: D[ PV[x:{_,_,_}..], t] :=
\tApply[ Plus, Map[ D[ PV[#], t]&, {x} ] ];\
\>", "Input",
 Evaluatable->False,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Angular Momentum", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
AngMom[ body_, pnt_ ] :=
\tInertia[body].AngVel[body] +
\tCross[ Mass[body] (PosCOM[body] - pnt),
\t\tVelCOM[body] ];
AngMom[ bodies_List, pnt_ ] :=
\tApply[ Plus, Map[ AngMom[#, pnt]&, bodies ] ];
AngMom[ body_, pnt_, ref_ ] :=
\tInertia[body].AngVel[body,ref] +
\tCross[ Mass[body] (PosCOM[body] - pnt),
\t\tVelCOM[body,ref] ];
AngMom[ bodies_List, pnt_, ref_ ] :=
\tApply[ Plus, Map[ AngMom[#, pnt, ref]&, bodies ] ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell["Linear Momentum", "Section"],

Cell["\<\
LinMom[body_] := Mass[body]*VelCOM[body]; 
  LinMom[(bodies_)?ListQ] := Simplify[Plus @@ LinMom /@ bodies]; \
\>", "Input",
 InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Partial velocities", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
To compute partial velocities, you need to be able to take the partial \
derivative of an expression with respect to a u.\
\>", "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
PV/: D[ PV[ {c_, frme_, n_ }], u[d_] ] :=
  PV[{ D[c,u[d]], frme, n}];
PV/: D[ PV[x:{_,_,_}..], u[d_] ] := 
\tApply[Plus, Map[ D[PV[#], u[d]]&, {x}] ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
PrtVel[ expr_, n_?NumberQ ] := D[ expr, u[n] ];
PrtVel[ expr_, u[n_?NumberQ] ] := D[ expr, u[n] ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Generalized Active Forces", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
ResltF[ body_ ] := Apply[ Plus, Map[ #[[1]]&, Force[body] ] ];
ResltT[ body_ ] := Apply[ Plus, Torque[body] ] + 
\tApply[ Plus, Map[ Cross[ #[[2]], #[[1]] ] &, Force[body] ] ];
GActFrcC[ All ]  := (* Simplify[ *)
\tApply[ Plus, Map[ GActFrc, Bodies ] ] (*]*);
GActFrcC[ All, n_ ] := Apply[ Plus,
\tMap[ GActFrc[#,n]&, Bodies] ];
GActFrcC[ body_, udof_ /; MemberQ[udofs,udof] ] :=
\t\tPrtVel[ AngVel[body], udof] . ResltT[body] +
\t\tPrtVel[ VelCOM[body], udof] . ResltF[body] /.
\t\tJoin[replacesin,replacecos,replace2SC,replaceSC2] //ZF;
GActFrcC[ body_ ] := Map[ GActFrc[ body, # ]&, udofs ];
SetAttributes[ GActFrcC, Listable ]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
AppFrc[ body_, force_, point_ ] := (
\tAppendTo[ Force[body], {force, point} ];
\tLength[ Force[body] ] )
AppTrq[ body_, torque_ ] := (
\tAppendTo[ Torque[body], torque ];
\tLength[ Torque[body] ] )\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Generalized Inertia Forces", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{"(*", " ", 
  RowBox[{
   RowBox[{"Note", ":", " ", 
    RowBox[{"C", " ", "stands", " ", "for", " ", "conventional"}]}], ",", " ", 
   RowBox[{"S", " ", "stands", " ", "for", " ", "simplified"}], ",", " ", 
   RowBox[{"0", " ", "stands", " ", "for", " ", "bare", " ", "minimum"}]}], 
  " ", "*)"}]], "Input"],

Cell[CellGroupData[{

Cell["\<\
GInerFrcC[ All ] := CollectU[ 
\tApply[ Plus, Outer[ GInerFrc, Bodies, udofs ] ] ] //.
\t\tJoin[replacesin,replacecos,replace2SC,replaceSC2];
\t(* Apply[ Plus, Map[ gInerFrc, Bodies ] ]; *)
GInerFrcC[ All, n_ ] := CollectU[
\tApply[ Plus, Map[ GInerFrc[#,n]&, Bodies ] ] ] //.
\t\tJoin[replacesin,replacecos,replace2SC,replaceSC2];
GInerFrcC[ body_, udof_ /; MemberQ[udofs,udof] ] :=
\tCollect[
\t\tPrtVel[ AngVel[body], udof] . Tstar[body] +
\t\tPrtVel[ VelCOM[body], udof] . Rstar[body] //.
\t\tJoin[replacesin,replacecos,replace2SC,replaceSC2],
\t\tJoin[ Map[(u[#])'&, udofs], Map[u[#]&, udofs] ] ] //ZF
GInerFrcC[ body_ ] := CollectU[
\tMap[ GInerFrc[ body, # ]&, udofs ] ] //.
\t\tJoin[replacesin,replacecos,replace2SC,replaceSC2];
GInerFrc0[ All ] := 
\tApply[ Plus, Outer[ GInerFrc, Bodies, udofs ] ]  //.
\t\tJoin[replacesin,replacecos,replace2SC,replaceSC2];
\t(* Apply[ Plus, Map[ GInerFrc, Bodies ] ]; *)
GInerFrc0[ All, n_ ] := 
\tApply[ Plus, Map[ GInerFrc[#,n]&, Bodies ] ]  //.
\t\tJoin[replacesin,replacecos,replace2SC,replaceSC2];
GInerFrc0[ body_, udof_ /; MemberQ[udofs,udof] ] :=
\tCollect[
\t\tPrtVel[ AngVel[body], udof] . Tstar[body] +
\t\tPrtVel[ VelCOM[body], udof] . Rstar[body] //.
\t\tJoin[replacesin,replacecos,replace2SC,replaceSC2],
\t\tJoin[ Map[(u[#])'&, udofs], Map[u[#]&, udofs] ] ] //ZF
GInerFrc0[ body_ ] := 
\tMap[ GInerFrc[ body, # ]&, udofs ] //.
\t\tJoin[replacesin,replacecos,replace2SC,replaceSC2];

GInerFrcS[ All ] := CollectU[ 
\tApply[ Plus, Outer[ GInerFrc, Bodies, udofs ] ] ] //.
\t\tJoin[replacesin,replacecos,replace2SC,replaceSC2];
GInerFrcS[ All, n_ ] := CollectU[
\tApply[ Plus, Map[ GInerFrc[#,n]&, Bodies ] ] ] //.
\t\tJoin[replacesin,replacecos,replace2SC,replaceSC2];
GInerFrcS[ body_ ] := CollectU[
\tMap[ GInerFrc[ body, # ]&, udofs ] ] //.
\t\tJoin[replacesin,replacecos,replace2SC,replaceSC2];
GInerFrcS[ body_, udof_ /; MemberQ[udofs,udof] ] :=
\tSimplify[Collect[
\t\tPrtVel[ AngVel[body], udof] . Tstar[body] +
\t\tPrtVel[ VelCOM[body], udof] . Rstar[body] //.
\t\tJoin[replacesin,replacecos,replace2SC,replaceSC2],
\t\tJoin[ Map[(u[#])'&, udofs], Map[u[#]&, udofs] ] ] ] //ZF

SetAttributes[ GInerFrcC, Listable ]
SetAttributes[ GInerFrcS, Listable ]
SetAttributes[ CleanGIF, Listable ]
SetAttributes[ CleanGIFS, Listable ]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"spell\"\>"}], ":", 
  " ", "\<\"Possible spelling error: new symbol name \
\\\"\\!\\(CollectU\\)\\\" is similar to existing symbols \\!\\({Collect, \
CollectE, CollectV}\\). \\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", \
ButtonStyle->\\\"RefGuideLinkText\\\", ButtonFrame->None, \
ButtonData:>\\\"General::spell\\\"]\\)\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"spell\"\>"}], ":", 
  " ", "\<\"Possible spelling error: new symbol name \\\"\\!\\(GInerFrcS\\)\\\
\" is similar to existing symbols \\!\\({GInerFrc, GInerFrcC}\\). \
\\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", ButtonStyle->\\\"RefGuideLinkText\
\\\", ButtonFrame->None, ButtonData:>\\\"General::spell\\\"]\\)\"\>"}]], \
"Message"]
}, Open  ]],

Cell["\<\
TstarC[body_] := (-AngAcc[body].Inertia[body] - 
\tCross[ AngVel[body], Inertia[body] . AngVel[body] ]) //ZF
Rstar[body_] := -Mass[body] AccCOM[body]
SetAttributes[ TstarC, Listable ]
SetAttributes[ Rstar, Listable ]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
CollectU[ x_ ] := Collect[ x, 
\tJoin[ Map[(u[#])'&, udofs], Map[u[#]&, udofs] ] ];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
upow2 := Union[ Flatten[ 
\tOuter[ Times, 
\t\tMap[u[#]&, udofs], Map[u[#]&, udofs] 
\t] ] ]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
CleanGIF[ x_ ] := Apply[ Plus, Map[ 
\tCoefficient[Expand[x], #] # &, 
\tJoin[ Map[(u[#])'&, udofs], upow2 ] ] ]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
CleanGIFS[ x_ ] := Apply[ Plus, Map[ 
\tSimplify[ Coefficient[Expand[x], #] ] # &, 
\tJoin[ Map[(u[#])'&, udofs], upow2 ] ] ]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Zees", "Section"],

Cell[BoxData[
 RowBox[{
  RowBox[{"SetAttributes", "[", 
   RowBox[{"Zee", ",", "Orderless"}], "]"}], ";"}]], "Input"],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"Z", "[", "n_", "]"}], ":=", 
   RowBox[{
    RowBox[{"Zz", "[", "n", "]"}], "[", "t", "]"}]}], ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"Format", "[", 
    RowBox[{
     RowBox[{"Zz", "[", "n_", "]"}], "[", "t_", "]"}], "]"}], ":=", 
   RowBox[{"Subscript", "[", 
    RowBox[{"Z", ",", "n"}], "]"}]}], ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"Zee", "[", 
    RowBox[{"x_", " ", 
     RowBox[{
      RowBox[{
       RowBox[{"ut", "[", "n1_", "]"}], "'"}], "[", "t_", "]"}]}], "]"}], ":=", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", "}"}], ",", 
     RowBox[{"If", "[", "\n", "\t\t\t", 
      RowBox[{
       RowBox[{
        RowBox[{"LeafCount", "[", "x", "]"}], ">", "4"}], ",", 
       RowBox[{
        RowBox[{"Z", "[", 
         RowBox[{"addtozee", "[", "x", "]"}], "]"}], " ", 
        RowBox[{
         RowBox[{
          RowBox[{"ut", "[", "n1", "]"}], "'"}], "[", "t", "]"}]}], ",", "\n",
        "\t\t", 
       RowBox[{"x", " ", 
        RowBox[{
         RowBox[{
          RowBox[{"ut", "[", "n1", "]"}], "'"}], "[", "t", "]"}]}]}], " ", 
      "]"}]}], "]"}]}], ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"Zee", "[", 
    RowBox[{"x_", " ", 
     RowBox[{
      RowBox[{"ut", "[", "n1_", "]"}], "[", "t_", "]"}], " ", 
     RowBox[{
      RowBox[{"ut", "[", "n2_", "]"}], "[", "t_", "]"}]}], "]"}], ":=", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", "}"}], ",", 
     RowBox[{"If", "[", "\n", "\t\t\t", 
      RowBox[{
       RowBox[{
        RowBox[{"LeafCount", "[", "x", "]"}], ">", "4"}], ",", 
       RowBox[{
        RowBox[{"Z", "[", 
         RowBox[{"addtozee", "[", "x", "]"}], "]"}], " ", 
        RowBox[{
         RowBox[{"ut", "[", "n1", "]"}], "[", "t", "]"}], 
        RowBox[{
         RowBox[{"ut", "[", "n2", "]"}], "[", "t", "]"}]}], ",", "\n", "\t\t", 
       RowBox[{"x", " ", 
        RowBox[{
         RowBox[{"ut", "[", "n1", "]"}], "[", "t", "]"}], " ", 
        RowBox[{
         RowBox[{"ut", "[", "n2", "]"}], "[", "t", "]"}]}]}], "]"}]}], 
    "]"}]}], ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"Zee", "[", 
    RowBox[{"x_", " ", 
     RowBox[{
      RowBox[{"ut", "[", "n1_", "]"}], "[", "t_", "]"}], " ", 
     RowBox[{
      RowBox[{"ut", "[", "n1_", "]"}], "[", "t_", "]"}]}], "]"}], ":=", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", "}"}], ",", 
     RowBox[{"If", "[", "\n", "\t\t\t", 
      RowBox[{
       RowBox[{
        RowBox[{"LeafCount", "[", "x", "]"}], ">", "4"}], ",", 
       RowBox[{
        RowBox[{"Z", "[", 
         RowBox[{"addtozee", "[", "x", "]"}], "]"}], " ", 
        RowBox[{
         RowBox[{"ut", "[", "n1", "]"}], "[", "t", "]"}], 
        RowBox[{
         RowBox[{"ut", "[", "n1", "]"}], "[", "t", "]"}]}], ",", "\n", "\t\t", 
       RowBox[{"x", " ", 
        RowBox[{
         RowBox[{"ut", "[", "n1", "]"}], "[", "t", "]"}], " ", 
        RowBox[{
         RowBox[{"ut", "[", "n1", "]"}], "[", "t", "]"}]}]}], "]"}]}], 
    "]"}]}], ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"Zee", "[", 
    RowBox[{"x_", " ", 
     RowBox[{
      RowBox[{"ut", "[", "n1_", "]"}], "[", "t_", "]"}]}], "]"}], ":=", 
   RowBox[{
    RowBox[{"Module", "[", 
     RowBox[{
      RowBox[{"{", "}"}], ",", 
      RowBox[{"If", "[", "\n", "\t\t\t", 
       RowBox[{
        RowBox[{
         RowBox[{"LeafCount", "[", "x", "]"}], ">", "4"}], ",", 
        RowBox[{
         RowBox[{"Z", "[", 
          RowBox[{"addtozee", "[", "x", "]"}], "]"}], " ", 
         RowBox[{
          RowBox[{"ut", "[", "n1", "]"}], "[", "t", "]"}]}], ",", "\n", 
        "\t\t", 
        RowBox[{"x", " ", 
         RowBox[{
          RowBox[{"ut", "[", "n1", "]"}], "[", "t", "]"}]}]}], " ", "]"}]}], 
     "]"}], " ", "/;", 
    RowBox[{"FreeQ", "[", 
     RowBox[{"x", ",", 
      RowBox[{"u", "[", "_Integer", "]"}]}], "]"}]}]}], ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"Zee", "[", 
   RowBox[{"PV", "[", 
    RowBox[{"List", "[", 
     RowBox[{"x_", ",", "y_", ",", "z_"}], "]"}], "]"}], "]"}], ":=", 
  RowBox[{"PV", "[", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"Zee", "[", 
      RowBox[{"Collect", "[", 
       RowBox[{"x", ",", 
        RowBox[{"Join", "[", 
         RowBox[{
          RowBox[{"u", "[", "udofs", "]"}], ",", 
          RowBox[{"udots", "[", "udofs", "]"}]}], "]"}]}], "]"}], "]"}], ",", 
     "y", ",", "z"}], "}"}], "]"}]}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"Zee", "[", 
    RowBox[{"PV", "[", "x_", "]"}], "]"}], ":=", 
   RowBox[{"Transpose", "[", 
    RowBox[{
     RowBox[{"Map", "[", 
      RowBox[{
       RowBox[{
        RowBox[{"Zee", "[", 
         RowBox[{"Collect", "[", 
          RowBox[{"#", ",", 
           RowBox[{"Join", "[", 
            RowBox[{
             RowBox[{"u", "[", "udofs", "]"}], ",", 
             RowBox[{"udots", "[", "udofs", "]"}]}], "]"}]}], "]"}], "]"}], 
        "&"}], ",", 
       RowBox[{
        RowBox[{"Transpose", "[", "x", "]"}], "[", 
        RowBox[{"[", "1", "]"}], "]"}]}], "]"}], ",", 
     RowBox[{"Drop", "[", 
      RowBox[{
       RowBox[{"Transpose", "[", "x", "]"}], ",", "1"}], "]"}]}], "]"}]}], 
  ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"Zee", "[", 
    RowBox[{"x", ":", 
     RowBox[{"Plus", "[", "__", "]"}]}], "]"}], ":=", 
   RowBox[{"Map", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"Zee", "[", 
       RowBox[{"Collect", "[", 
        RowBox[{"#", ",", 
         RowBox[{"Join", "[", 
          RowBox[{
           RowBox[{"u", "[", "udofs", "]"}], ",", 
           RowBox[{"udots", "[", "udofs", "]"}]}], "]"}]}], "]"}], "]"}], 
      "&"}], ",", "x"}], "]"}]}], ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"Zz", "[", "n_", "]"}], "'"}], "[", "t", "]"}], ":=", 
  RowBox[{"Dt", "[", 
   RowBox[{
    RowBox[{"zees", "[", 
     RowBox[{"[", "n", "]"}], "]"}], ",", "t"}], "]"}]}]], "Input",
 InitializationCell->True],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"addtozee", "[", "x_", "]"}], ":=", 
   RowBox[{
    RowBox[{"Module", "[", 
     RowBox[{
      RowBox[{"{", "}"}], ",", 
      RowBox[{
       RowBox[{"AppendTo", "[", 
        RowBox[{"zees", ",", "x"}], "]"}], ";", 
       RowBox[{"Length", "[", "zees", "]"}]}]}], "]"}], " ", "/;", " ", 
    RowBox[{"!", 
     RowBox[{"MemberQ", "[", 
      RowBox[{"zees", ",", "x"}], "]"}]}]}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"addtozee", "[", "x_", "]"}], ":=", 
   RowBox[{
    RowBox[{
     RowBox[{"Flatten", "[", 
      RowBox[{"Position", "[", 
       RowBox[{"zees", ",", "x"}], "]"}], "]"}], "[", 
     RowBox[{"[", "1", "]"}], "]"}], "/;", 
    RowBox[{"MemberQ", "[", 
     RowBox[{"zees", ",", "x"}], "]"}]}]}], ";"}]}], "Input",
 InitializationCell->True]
}, Closed]],

Cell[CellGroupData[{

Cell["Equations of Motion", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["Options[EOM] = {Simplify -> Off}; ", "Input",
 InitializationCell->True],

Cell["\<\
EOM[opts___] := Module[{},If[(Simplify/.{opts}/.Options[EOM])===On,
(* then Simplify it *)
Thread[ 
\tGActFrc[All] + GInerFrcS[All] == Table[0, {Length[udofs]} ] ],
(* else regular equations *)
Thread[ 
\tGActFrc[All] + GInerFrc[All] == Table[0, {Length[udofs]} ] ]
] ]

(* EOM0 := Thread[ 
\tGActFrc[All] + GInerFrc0[All] == Table[0, {Length[udofs]} ] ] *)\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
CollectE takes the equations of motion, and collects the terms of the udots \
together. You can also use CollectE to \
\>", "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
CollectE[ eom_ ] := Collect[eom[[1]],
\tudots[udofs] ] == 0  
CollectE[ eom_, x_ ] := Collect[eom[[1]],
\tx ] == 0
SetAttributes[ CollectE, Listable ]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[TextData[{
 StyleBox["SolveEqn",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " solves a list of equations for the given variables, sorts them into order, \
and puts an == sign around the whole thing"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
SolveEqn[ eqn_, vars_ ] := Sort[ Apply[ Equal, 
\tSolve[ eqn, vars], {2}][[1]] ]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[TextData[{
 StyleBox["RHS",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " gives the right-hand-side of each equation in a list of equations"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["RHS[ eqn_ ] := Map[#[[2]]&,eqn]", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[TextData[{
 StyleBox["AsmStateEqn",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " assembles the state equations, if you give it the kinematical differential \
equations and the equations of motion. First, it solves them for the q's and \
u's, then it joins it all together, and provides the right-hand-side. This \
output is suitable for ",
 StyleBox["RungeKutta",
  FontWeight->"Bold",
  FontSlant->"Plain"]
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
AsmStateEqn[ Kinematics_, eom_ ] := RHS[ Join[ 
\tSolveEqn[ Kinematics, qdots[qdofs] ],
\tSolveEqn[ eom, udots[udofs] ] ]]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[TextData[{
 StyleBox["MassMatrix",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " extracts the mass matrix from the equations of motion"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
MassMatrix[ eom_ ] := Module[ {eqns,mass},
\teqns = Thread[ eom, Equal]; eqns = eqns[[1]]-eqns[[2]];
\tmass = Transpose[Map[ Coefficient[ Expand[eqns], ut[#]'[t] ] &, udofs ]];
  {-mass, (eqns /. Thread[udots[udofs]->Table[0,{Length[udofs]}]])}
] \
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[TextData[{
 StyleBox["XDot",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " computes the state derivative, given the equations of motion and the state"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["\<\
XDot[eom_, states_List] := Module[
\t{staterule = Thread[
\t\tEvaluate[ Join[q[qdofs],u[udofs]] ] -> 
\t\t\tFlatten[states] ],
\txdots = 
\t\tJoin[Thread[q[qdofs]'],Thread[u[udofs]'] ]},
\txdots /. Solve[
\t\tFlatten[{eom /. parms, Kinematics}] /.
\t\tstaterule, xdots][[1]]
]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"spell\"\>"}], ":", 
  " ", "\<\"Possible spelling error: new symbol name \\\"\\!\\(xdots\\)\\\" \
is similar to existing symbols \\!\\({qdots, udots}\\). \\!\\(\\*ButtonBox[\\\
\"More\[Ellipsis]\\\", ButtonStyle->\\\"RefGuideLinkText\\\", \
ButtonFrame->None, ButtonData:>\\\"General::spell\\\"]\\)\"\>"}]], "Message"]
}, Open  ]]
}, Closed]],

Cell["Exporting", "Section"],

Cell["\<\
lowercasefunctions = {Sin -> sin, Cos -> cos, Tan -> tan, Cot -> cot, Power \
-> power}; \
\>", "Input",
 InitializationCell->True,
 CellChangeTimes->{{3.5794663819476757`*^9, 3.5794663866906757`*^9}}],

Cell["\<\
formtrigreplacements takes in a set of equations, and returns a list of \
replacements\
\>", "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"Options", "[", "formtrigreplacements", "]"}], "=", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"TrigReplacements", "\[Rule]", 
       RowBox[{"{", 
        RowBox[{
         RowBox[{"{", 
          RowBox[{"Sin", ",", "\"\<s\>\""}], "}"}], ",", 
         RowBox[{"{", 
          RowBox[{"Cos", ",", "\"\<c\>\""}], "}"}], ",", 
         RowBox[{"{", 
          RowBox[{"Tan", ",", "\"\<t\>\""}], "}"}], ",", 
         RowBox[{"{", 
          RowBox[{"Sec", ",", "\"\<sec\>\""}], "}"}], ",", 
         RowBox[{"{", 
          RowBox[{"Csc", ",", "\"\<csc\>\""}], "}"}]}], "}"}]}], ",", 
      RowBox[{"ArgReplacements", "\[Rule]", "None"}]}], " ", "}"}]}], ";"}], 
  "\n", 
  RowBox[{"(*", " ", 
   RowBox[{
    RowBox[{"trigSubs", " ", "=", " ", 
     RowBox[{
      RowBox[{"formtrigreplacements", "[", "equations", "]"}], " ", "takes", 
      " ", "in", " ", "equations", " ", "of", " ", "any", " ", "form"}]}], 
    ",", " ", 
    RowBox[{
    "and", " ", "returns", " ", "a", " ", "list", " ", "of", " ", 
     "replacements", " ", "for", " ", "trig", " ", "function", " ", "calls", 
     " ", "with", " ", "shorthand", " ", 
     RowBox[{"variables", ".", " ", "The"}], " ", "shortened", " ", 
     "variables", " ", "are", " ", "given", " ", "as", " ", 
     RowBox[{"strings", ".", " ", "For"}], " ", "example"}], ",", " ", 
    RowBox[{
     RowBox[{"an", " ", "equation", " ", "M", "*", "g", "*", 
      RowBox[{"Sin", "[", 
       RowBox[{"q", "[", "1", "]"}], "]"}], "*", 
      RowBox[{"Cos", "[", 
       RowBox[{"q", "[", "2", "]"}], "]"}], "*", 
      RowBox[{"Sin", "[", 
       RowBox[{
        RowBox[{"q", "[", "1", "]"}], "-", 
        RowBox[{"q", "[", "2", "]"}]}], "]"}], "*", 
      RowBox[{"Sin", "[", "unknown", "]"}], " ", "returns", " ", 
      RowBox[{
       RowBox[{"{", 
        RowBox[{
         RowBox[{
          RowBox[{"Sin", "[", 
           RowBox[{"q", "[", "1", "]"}], "]"}], "->", "\"\<s1\>\""}], ",", 
         RowBox[{
          RowBox[{"Cos", "[", 
           RowBox[{"q", "[", "2", "]"}], "]"}], "->", "\"\<c2\>\""}], ",", 
         RowBox[{
          RowBox[{"Sin", "[", 
           RowBox[{
            RowBox[{"q", "[", "1", "]"}], "-", 
            RowBox[{"q", "[", "2", "]"}]}], "]"}], "->", "\"\<s1m2\>\""}]}], 
        "}"}], ".", " ", "There"}], " ", "are", " ", "two", " ", "optional", 
      " ", "arguments", " ", "that", " ", "can", " ", "be", " ", 
      RowBox[{"given", ".", " ", "ArgReplacements"}]}], "\[Rule]", 
     RowBox[{
      RowBox[{"{", 
       RowBox[{
        RowBox[{"{", 
         RowBox[{"gamma", ",", "\"\<g\>\""}], "}"}], ",", 
        RowBox[{"{", 
         RowBox[{"alpha", ",", "\"\<a\>\""}], "}"}]}], "}"}], " ", 
      "specifies", " ", "additional", " ", "trig", " ", "arguments", " ", 
      "that", " ", "can", " ", "be", " ", "shortened"}]}], ",", " ", 
    RowBox[{
     RowBox[{"and", " ", "TrigReplacements"}], "\[Rule]", 
     RowBox[{
      RowBox[{"{", 
       RowBox[{
        RowBox[{"{", 
         RowBox[{"Sin", ",", "\"\<s\>\""}], "}"}], ",", 
        RowBox[{"{", 
         RowBox[{"Cos", ",", "\"\<c\>\""}], "}"}]}], "}"}], " ", "specifies", 
      " ", "all", " ", "the", " ", "trig", " ", "functions", " ", "that", " ",
       "can", " ", "be", " ", 
      RowBox[{"shortened", ".", " ", "The"}], " ", "second", " ", "element", 
      " ", "of", " ", "each", " ", "entry", " ", "is", " ", "a", " ", 
      "string", " ", "containing", " ", "the", " ", 
      RowBox[{"abbreviation", "."}]}]}]}], "  ", 
   "*)"}]}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"formtrigreplacements", "[", 
   RowBox[{"eom_", ",", "opts___"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{
     "trigreps", ",", "altargs", ",", "alltrig", ",", "trigreplaced", ",", 
      "argreplacements", ",", "argtostrings", ",", "plusminustostrings", ",", 
      "successfulones", ",", "trigreplacements", ",", "trigfncalls", ",", 
      "trigSubs", ",", "reorder"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"trigreps", "=", 
      RowBox[{
       RowBox[{
        RowBox[{"TrigReplacements", "/.", 
         RowBox[{"{", "opts", "}"}]}], "/.", 
        RowBox[{"Options", "[", "formtrigreplacements", "]"}]}], "/.", 
       RowBox[{"None", "\[Rule]", 
        RowBox[{"{", "}"}]}]}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"altargs", "=", 
      RowBox[{
       RowBox[{
        RowBox[{"ArgReplacements", "/.", 
         RowBox[{"{", "opts", "}"}]}], "/.", 
        RowBox[{"Options", "[", "formtrigreplacements", "]"}]}], "/.", 
       RowBox[{"None", "\[Rule]", 
        RowBox[{"{", "}"}]}]}]}], ";", "\n", "\t", 
     RowBox[{"(*", " ", 
      RowBox[{
       RowBox[{
        RowBox[{
        "pull", " ", "out", " ", "all", " ", "the", " ", "unique", " ", 
         "trig", " ", "function", " ", "calls", " ", "of", " ", "the", " ", 
         "form", " ", 
         RowBox[{"Sin", "[", "_", "]"}]}], "|", 
        RowBox[{
         RowBox[{"Cos", "[", "_", "]"}], " ", 
         RowBox[{"etc", "."}]}]}], ",", " ", 
       RowBox[{"yielding", " ", "a", " ", "list", " ", "like", " ", 
        RowBox[{"{", 
         RowBox[{
          RowBox[{"Sin", "[", 
           RowBox[{"q", "[", "1", "]"}], "]"}], ",", 
          RowBox[{"Cos", "[", 
           RowBox[{
            RowBox[{"q", "[", "2", "]"}], "-", 
            RowBox[{"q", "[", "3", "]"}]}], "]"}]}], "}"}]}]}], " ", "*)"}], 
     "\[IndentingNewLine]", 
     RowBox[{"alltrig", "=", 
      RowBox[{"Union", "[", 
       RowBox[{"Cases", "[", 
        RowBox[{"eom", ",", 
         RowBox[{"Apply", "[", 
          RowBox[{"Alternatives", ",", 
           RowBox[{"Map", "[", 
            RowBox[{
             RowBox[{
              RowBox[{"#", "[", "_", "]"}], "&"}], ",", 
             RowBox[{
              RowBox[{"Transpose", "[", "trigreps", "]"}], "[", 
              RowBox[{"[", "1", "]"}], "]"}]}], "]"}]}], "]"}], ",", 
         "Infinity"}], "]"}], "]"}]}], ";", "\n", "\t", 
     RowBox[{"(*", " ", 
      RowBox[{
       RowBox[{
       "form", " ", "a", " ", "list", " ", "of", " ", "the", " ", "trig", " ",
         "functions", " ", "replaced", " ", "by", " ", "their", " ", 
        "shortcuts"}], ",", " ", 
       RowBox[{
        RowBox[{"e", ".", "g", ".", " ", 
         RowBox[{"{", 
          RowBox[{
           RowBox[{"Cos", "[", 
            RowBox[{"q", "[", "1", "]"}], "]"}], ",", 
           RowBox[{"Sin", "[", "anything", "]"}]}], "}"}]}], " ", "becomes", 
        " ", 
        RowBox[{"{", 
         RowBox[{"\"\<c\>\"", ",", "\"\<s\>\""}], "}"}]}]}], " ", "*)"}], 
     "\[IndentingNewLine]", 
     RowBox[{"trigreplaced", "=", 
      RowBox[{
       RowBox[{"Map", "[", 
        RowBox[{"Head", ",", "alltrig"}], "]"}], "/.", 
       RowBox[{"Apply", "[", 
        RowBox[{"Rule", ",", "trigreps", ",", 
         RowBox[{"{", "1", "}"}]}], "]"}]}]}], ";", "\n", "\t", 
     RowBox[{"(*", " ", 
      RowBox[{
       RowBox[{
       "make", " ", "a", " ", "list", " ", "of", " ", "replacements"}], ",", 
       " ", 
       RowBox[{
        RowBox[{"starting", " ", "with", " ", 
         RowBox[{"q", "[", "n_", "]"}]}], "\[RuleDelayed]", 
        RowBox[{"ToString", "[", "n", "]"}]}], ",", " ", 
       RowBox[{
       "followed", " ", "by", " ", "alternative", " ", "arg", " ", 
        "replacements", " ", "if", " ", "any", " ", 
        RowBox[{"(", 
         RowBox[{
         "whether", " ", "in", " ", "vector", " ", "or", " ", "matrix", " ", 
          "form"}], ")"}], " ", 
        RowBox[{"e", ".", "g", ".", " ", 
         RowBox[{"{", 
          RowBox[{
           RowBox[{
            RowBox[{"q", "[", "n_", "]"}], "\[RuleDelayed]", 
            RowBox[{"ToString", "[", "n", "]"}]}], ",", 
           RowBox[{"gamma", "->", "\"\<g\>\""}]}], "}"}]}]}]}], " ", "*)"}], 
     "\[IndentingNewLine]", 
     RowBox[{"argreplacements", "=", 
      RowBox[{"Prepend", "[", 
       RowBox[{
        RowBox[{"Apply", "[", 
         RowBox[{"Rule", ",", 
          RowBox[{"Replace", "[", 
           RowBox[{
            RowBox[{"altargs", "/.", 
             RowBox[{"None", "\[Rule]", 
              RowBox[{"{", "}"}]}]}], ",", 
            RowBox[{
             RowBox[{"x", ":", 
              RowBox[{"{", 
               RowBox[{"_", ",", "_String"}], "}"}]}], "\[Rule]", 
             RowBox[{"{", "x", "}"}]}]}], "]"}], ",", 
          RowBox[{"{", "1", "}"}]}], "]"}], ",", 
        RowBox[{
         RowBox[{"q", "[", "n_", "]"}], "\[RuleDelayed]", 
         RowBox[{"ToString", "[", "n", "]"}]}]}], "]"}]}], ";", "\n", "\t", 
     RowBox[{"(*", " ", 
      RowBox[{
       RowBox[{
       "convert", " ", "all", " ", "arguments", " ", "into", " ", "their", 
        " ", "replacements"}], ",", " ", 
       RowBox[{
        RowBox[{"e", ".", "g", ".", " ", 
         RowBox[{"q", "[", "1", "]"}]}], " ", "becomes", " ", "\"\<1\>\""}]}],
       " ", "*)"}], "\[IndentingNewLine]", 
     RowBox[{"argstostrings", "=", 
      RowBox[{
       RowBox[{"Map", "[", 
        RowBox[{
         RowBox[{
          RowBox[{"#", "[", 
           RowBox[{"[", "1", "]"}], "]"}], "&"}], ",", "alltrig"}], "]"}], "/.",
        "argreplacements"}]}], ";", "\n", "\t", 
     RowBox[{"(*", " ", 
      RowBox[{
       RowBox[{
       "for", " ", "cases", " ", "where", " ", "two", " ", "arguments", " ", 
        "are", " ", "summed"}], ",", " ", 
       RowBox[{
       "convert", " ", "all", " ", "plus", " ", "and", " ", "minus", " ", 
        "signs", " ", "into", " ", "\"\<p\>\"", " ", "and", " ", 
        "\"\<m\>\""}]}], " ", "*)"}], "\[IndentingNewLine]", 
     RowBox[{"plusminustostrings", "=", 
      RowBox[{
       RowBox[{"argstostrings", "/.", 
        RowBox[{
         RowBox[{"(", 
          RowBox[{"x_String", " ", "-", " ", "y_String"}], ")"}], 
         "\[RuleDelayed]", 
         RowBox[{"(", 
          RowBox[{"x", " ", "<>", " ", "\"\<m\>\"", " ", "<>", " ", "y"}], 
          ")"}]}]}], "/.", 
       RowBox[{
        RowBox[{"(", 
         RowBox[{"x_String", " ", "+", " ", "y_String"}], ")"}], " ", 
        "\[RuleDelayed]", 
        RowBox[{"(", " ", 
         RowBox[{"x", " ", "<>", " ", "\"\<p\>\"", " ", "<>", " ", "y"}], 
         ")"}]}]}]}], ";", "\n", "\t", 
     RowBox[{"(*", " ", 
      RowBox[{
      "positions", " ", "of", " ", "the", " ", "arguments", " ", "that", " ", 
       "were", " ", "successfully", " ", "replaced"}], " ", "*)"}], 
     "\[IndentingNewLine]", 
     RowBox[{"successfulones", "=", 
      RowBox[{"Position", "[", 
       RowBox[{"plusminustostrings", ",", "_String", ",", 
        RowBox[{"{", "1", "}"}]}], "]"}]}], ";", " ", "\n", "\t", 
     RowBox[{"(*", " ", 
      RowBox[{
       RowBox[{
       "splice", " ", "together", " ", "the", " ", "trig", " ", "function", 
        " ", "replacement", " ", 
        RowBox[{"(", 
         RowBox[{
          RowBox[{"e", ".", "g", ".", " ", "\"\<s\>\""}], " ", "for", " ", 
          "Sin"}], ")"}], " ", "with", " ", "the", " ", "argument", " ", 
        "replacements"}], ",", " ", 
       RowBox[{"yielding", " ", "something", " ", "like", " ", 
        RowBox[{"{", 
         RowBox[{"\"\<s1\>\"", ",", "\"\<c2\>\"", ",", "\"\<s12\>\""}], 
         "}"}]}]}], " ", "*)"}], "\[IndentingNewLine]", 
     RowBox[{"trigreplacements", "=", 
      RowBox[{"MapThread", "[", 
       RowBox[{"StringJoin", ",", 
        RowBox[{"{", 
         RowBox[{
          RowBox[{"Extract", "[", 
           RowBox[{"trigreplaced", ",", "successfulones"}], "]"}], ",", 
          RowBox[{"Extract", "[", 
           RowBox[{"plusminustostrings", ",", "successfulones"}], "]"}]}], 
         "}"}]}], "]"}]}], ";", "\n", 
     RowBox[{"(*", 
      RowBox[{" ", 
       RowBox[{
        RowBox[{
        "and", " ", "pull", " ", "out", " ", "the", " ", "matching", " ", 
         "trig", " ", "functions"}], ",", " ", 
        RowBox[{
        "effectively", " ", "discarding", " ", "the", " ", "ones", " ", 
         "that", " ", 
         RowBox[{"couldn", "'"}], "t", " ", "be", " ", "replaced"}], ",", " ", 
        RowBox[{"e", ".", "g", ".", " ", 
         RowBox[{"{", 
          RowBox[{"Sin", "[", 
           RowBox[{
            RowBox[{"q", "[", "1", "]"}], ",", 
            RowBox[{"Cos", "[", 
             RowBox[{"q", "[", "2", "]"}], "]"}], ",", 
            RowBox[{"Sin", "[", 
             RowBox[{
              RowBox[{"q", "[", "1", "]"}], "-", 
              RowBox[{"q", "[", "2", "]"}]}], "]"}]}]}]}]}]}], "}"}], " ", 
      "*)"}], "\[IndentingNewLine]", 
     RowBox[{"(*", " ", 
      RowBox[{
       RowBox[{
       "sort", " ", "them", " ", "so", " ", "that", " ", "shorter", " ", 
        "strings", " ", "go", " ", "first"}], ",", " ", 
       RowBox[{
       "and", " ", "after", " ", "that", " ", "they", " ", "are", " ", 
        "alphabetical"}]}], " ", "*)"}], "\[IndentingNewLine]", 
     RowBox[{"reorder", "=", 
      RowBox[{"Ordering", "[", 
       RowBox[{"trigreplacements", ",", "All", ",", 
        RowBox[{
         RowBox[{
          RowBox[{
           RowBox[{"StringLength", "[", "#1", "]"}], "<", 
           RowBox[{"StringLength", "[", "#2", "]"}]}], "||", 
          RowBox[{"(", 
           RowBox[{
            RowBox[{
             RowBox[{"StringLength", "[", "#1", "]"}], "===", 
             RowBox[{"StringLength", "[", "#2", "]"}]}], " ", "&&", " ", 
            RowBox[{"OrderedQ", "[", 
             RowBox[{"{", 
              RowBox[{"#1", ",", "#2"}], "}"}], "]"}]}], ")"}]}], "&"}]}], 
       "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"trigfncalls", "=", 
      RowBox[{"Extract", "[", 
       RowBox[{"alltrig", ",", "successfulones"}], "]"}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"(*", " ", 
      RowBox[{
       RowBox[{
       "Use", " ", "the", " ", "two", " ", "lists", " ", "to", " ", "form", 
        " ", "a", " ", "set", " ", "of", " ", "rules"}], ",", " ", 
       RowBox[{"{", 
        RowBox[{
         RowBox[{
          RowBox[{"Sin", "[", 
           RowBox[{"q", "[", "1", "]"}], "]"}], "\[Rule]", "\"\<s1\>\""}], 
         ",", 
         RowBox[{
          RowBox[{"Cos", "[", 
           RowBox[{"q", "[", "2", "]"}], "]"}], "->", "\"\<c2\>\""}]}], 
        "}"}]}], " ", "*)"}], "\[IndentingNewLine]", 
     RowBox[{"trigSubs", "=", 
      RowBox[{"MapThread", "[", 
       RowBox[{
        RowBox[{
         RowBox[{"Rule", "[", 
          RowBox[{"#1", ",", "#2"}], "]"}], "&"}], ",", 
        RowBox[{"{", 
         RowBox[{
          RowBox[{"trigfncalls", "[", 
           RowBox[{"[", "reorder", "]"}], "]"}], ",", 
          RowBox[{"trigreplacements", "[", 
           RowBox[{"[", "reorder", "]"}], "]"}]}], "}"}]}], "]"}]}]}]}], 
   "]"}]}]}], "Input",
 InitializationCell->True],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"formqureplacements", ":=", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"qSubs", ",", "uSubs", ",", "upSubs", ",", "quSubs"}], "}"}], 
     ",", 
     RowBox[{
      RowBox[{"qSubs", "=", 
       RowBox[{
        RowBox[{"(", 
         RowBox[{
          RowBox[{
           RowBox[{"q", "[", "#1", "]"}], "\[Rule]", 
           RowBox[{"ToString", "[", 
            InterpretationBox["\"\<q\\!\\(#1\\)\>\"",
             StringForm["q`1`", #],
             Editable->False], "]"}]}], "&"}], ")"}], "/@", "qdofs"}]}], ";", 
      RowBox[{"uSubs", "=", 
       RowBox[{
        RowBox[{"(", 
         RowBox[{
          RowBox[{
           RowBox[{"u", "[", "#1", "]"}], "\[Rule]", 
           RowBox[{"ToString", "[", 
            InterpretationBox["\"\<u\\!\\(#1\\)\>\"",
             StringForm["u`1`", #],
             Editable->False], "]"}]}], "&"}], ")"}], "/@", "udofs"}]}], ";", 
      RowBox[{"upSubs", "=", 
       RowBox[{
        RowBox[{"(", 
         RowBox[{
          RowBox[{
           SuperscriptBox[
            RowBox[{"u", "[", "#1", "]"}], "\[Prime]",
            MultilineFunction->None], "\[Rule]", 
           RowBox[{"ToString", "[", 
            InterpretationBox["\"\<u\\!\\(#1\\)dot\>\"",
             StringForm["u`1`dot", #],
             Editable->False], "]"}]}], "&"}], ")"}], "/@", "udofs"}]}], ";", 
      RowBox[{"quSubs", "=", 
       RowBox[{"Join", "[", 
        RowBox[{"qSubs", ",", "uSubs", ",", "upSubs"}], "]"}]}]}]}], "]"}]}], 
  ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"spell\"\>"}], ":", 
  " ", "\<\"Possible spelling error: new symbol name \\\"\\!\\(quSubs\\)\\\" \
is similar to existing symbols \\!\\({qSubs, uSubs}\\). \\!\\(\\*ButtonBox[\\\
\"More\[Ellipsis]\\\", ButtonStyle->\\\"RefGuideLinkText\\\", \
ButtonFrame->None, ButtonData:>\\\"General::spell\\\"]\\)\"\>"}]], "Message"]
}, Open  ]],

Cell[TextData[{
 "We will change anything raised to the 2nd power into a multiplication, \
because ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " wants to export squares with the Power function"
}], "Text"],

Cell["pSub = {(x_)^2 -> HoldForm[x*x]}; ", "Input",
 InitializationCell->True],

Cell[TextData[{
 StyleBox["ExportExpression",
  FontWeight->"Bold"],
 "[expression, \"name\"] formats expression as Matlab code, producing a \
string that begins with 'name = ' followed by the expression. \
ExportExpression can export a matrix, a symmeric matrix, a list, or a scalar. \
Formatting options include EndLine\[Rule]\"\\n\", Continuator\[Rule]\"...\", \
LineLength\[Rule]78, Deliminator\[Rule]\" \", which specify the end-of-line \
character, line continuator, maximum line length of the output, and the \
deliminators where line breaks can occur (default to space character). The \
options to formtrigreplacements can also be used."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Options", "[", "ExportExpression", "]"}], "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"qusubs", "\[Rule]", "Automatic"}], ",", 
     RowBox[{"TrigSubs", "\[Rule]", "Automatic"}], ",", 
     RowBox[{"psub", "->", 
      RowBox[{"{", 
       RowBox[{
        RowBox[{
         RowBox[{"(", "x_", ")"}], "^", "2"}], "\[Rule]", 
        RowBox[{"HoldForm", "[", 
         RowBox[{"x", "*", "x"}], "]"}]}], "}"}]}]}], "}"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"ExportExpression", "[", 
    RowBox[{
     RowBox[{"Mx_", "?", "SymmetricQ"}], ",", " ", "name_String", ",", 
     "opts___"}], "]"}], ":=", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
      "elementsreplaced", ",", "quSubs", ",", "trigSubs", ",", "pSub"}], 
      "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"quSubs", "=", 
       RowBox[{
        RowBox[{
         RowBox[{"qusubs", "/.", 
          RowBox[{"{", "opts", "}"}]}], "/.", 
         RowBox[{"Options", "[", "ExportExpression", "]"}]}], "/.", 
        RowBox[{"Automatic", "\[Rule]", "formqureplacements"}]}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"trigSubs", "=", 
       RowBox[{
        RowBox[{
         RowBox[{
          RowBox[{"TrigSubs", "/.", 
           RowBox[{"{", "opts", "}"}]}], "/.", 
          RowBox[{"Options", "[", "ExportExpression", "]"}]}], "/.", 
         RowBox[{"None", "\[Rule]", 
          RowBox[{"{", "}"}]}]}], "/.", 
        RowBox[{"Automatic", "\[Rule]", 
         RowBox[{"formtrigreplacements", "[", 
          RowBox[{"Mx", ",", "opts"}], "]"}]}]}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"pSub", "=", 
       RowBox[{
        RowBox[{"psub", "/.", 
         RowBox[{"{", "opts", "}"}]}], "/.", 
        RowBox[{"Options", "[", "ExportExpression", "]"}]}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"(*", " ", 
       RowBox[{
        RowBox[{"produce", " ", "table", " ", "of", " ", "values"}], ",", " ", 
        RowBox[{"such", " ", "as", " ", 
         RowBox[{"{", 
          RowBox[{
           RowBox[{"{", 
            RowBox[{
             RowBox[{
              RowBox[{"MM", 
               RowBox[{"(", 
                RowBox[{"1", ",", "1"}], ")"}]}], "=", 
              RowBox[{"M", "*", "g", "*", "s12"}]}], ",", 
             RowBox[{
              RowBox[{"MM", 
               RowBox[{"(", 
                RowBox[{"1", ",", "2"}], ")"}]}], "=", "c12"}]}], "}"}], ",", 
           RowBox[{"{", 
            RowBox[{
             RowBox[{
              RowBox[{"MM", 
               RowBox[{"(", 
                RowBox[{"2", ",", "1"}], ")"}]}], "=", "c12"}], ",", 
             RowBox[{
              RowBox[{"MM", 
               RowBox[{"(", 
                RowBox[{"2", ",", "2"}], ")"}]}], "=", "c2"}]}], "}"}]}], 
          "}"}], " ", "for", "\[IndentingNewLine]", "symmetric", " ", 
         "matrices"}], ",", " ", 
        RowBox[{
        "where", " ", "duplicate", " ", "definitions", " ", "are", " ", 
         "avoided"}]}], " ", "*)"}], "\[IndentingNewLine]", 
      RowBox[{"elementsreplaced", "=", 
       RowBox[{"Table", "[", "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{"StringReplace", "[", " ", 
          RowBox[{"(*", " ", 
           RowBox[{"strip", " ", "quotes"}], " ", "*)"}], 
          "\[IndentingNewLine]", 
          RowBox[{"(*", " ", 
           RowBox[{
            RowBox[{
            "expression", " ", "of", " ", "the", " ", "form", " ", "name", 
             RowBox[{"(", 
              RowBox[{"i", ",", "j"}], ")"}]}], " ", "=", " ", "rhs"}], " ", 
           "*)"}], "\[IndentingNewLine]", 
          RowBox[{
           RowBox[{"ToString", "[", 
            RowBox[{"StringForm", "[", 
             RowBox[{
             "\"\<`1`(`2`,`3`) = `4`; \>\"", ",", "name", ",", "i", ",", "j", 
              ",", 
              RowBox[{"If", "[", 
               RowBox[{
                RowBox[{"i", ">", "j"}], ",", 
                RowBox[{"StringForm", "[", 
                 RowBox[{
                 "\"\<`1`(`2`,`3`)\>\"", ",", "name", ",", "j", ",", "i"}], 
                 "]"}], ",", 
                RowBox[{
                 RowBox[{"CForm", "[", 
                  RowBox[{
                   RowBox[{
                    RowBox[{
                    RowBox[{"Mx", "[", 
                    RowBox[{"[", 
                    RowBox[{"i", ",", "j"}], "]"}], "]"}], "/.", "trigSubs"}],
                     "/.", "quSubs"}], "/.", "pSub"}], "]"}], "/.", 
                 "lowercasefunctions"}]}], "]"}]}], "]"}], "]"}], ",", 
           RowBox[{"\"\<\\\"\>\"", "->", "\"\<\>\""}]}], "]"}], ",", 
         "\[IndentingNewLine]", 
         RowBox[{"{", 
          RowBox[{"i", ",", "1", ",", 
           RowBox[{
            RowBox[{"Dimensions", "[", "Mx", "]"}], "[", 
            RowBox[{"[", "1", "]"}], "]"}]}], "}"}], ",", 
         RowBox[{"{", 
          RowBox[{"j", ",", "1", ",", 
           RowBox[{
            RowBox[{"Dimensions", "[", "Mx", "]"}], "[", 
            RowBox[{"[", "2", "]"}], "]"}]}], "}"}]}], "]"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"(*", " ", 
       RowBox[{
        RowBox[{
        "output", " ", "each", " ", "row", " ", "as", " ", "a", " ", 
         "separate", " ", "formatted", " ", "output"}], ",", " ", 
        RowBox[{
        "with", " ", "line", " ", "breaks", " ", "in", " ", "between"}]}], 
       " ", "*)"}], "\n", 
      RowBox[{"StringJoin", "[", 
       RowBox[{"Map", "[", 
        RowBox[{
         RowBox[{
          RowBox[{"StringInsert", "[", 
           RowBox[{
            RowBox[{"fmtString", "[", 
             RowBox[{"#", ",", "opts"}], "]"}], ",", "\"\<\\n\>\"", ",", 
            RowBox[{"-", "1"}]}], "]"}], "&"}], ",", 
         RowBox[{"Map", "[", 
          RowBox[{"StringJoin", ",", "elementsreplaced"}], "]"}]}], "]"}], 
       "]"}]}]}], "]"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"ExportExpression", "[", 
    RowBox[{
     RowBox[{"Mx_List", "?", "MatrixQ"}], ",", " ", "name_String", ",", 
     "opts___"}], "]"}], ":=", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
      "elementsreplaced", ",", "quSubs", ",", "trigSubs", ",", "pSub"}], 
      "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"quSubs", "=", 
       RowBox[{
        RowBox[{
         RowBox[{"qusubs", "/.", 
          RowBox[{"{", "opts", "}"}]}], "/.", 
         RowBox[{"Options", "[", "ExportExpression", "]"}]}], "/.", 
        RowBox[{"Automatic", "\[Rule]", "formqureplacements"}]}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"trigSubs", "=", 
       RowBox[{
        RowBox[{
         RowBox[{
          RowBox[{"TrigSubs", "/.", 
           RowBox[{"{", "opts", "}"}]}], "/.", 
          RowBox[{"Options", "[", "ExportExpression", "]"}]}], "/.", 
         RowBox[{"None", "\[Rule]", 
          RowBox[{"{", "}"}]}]}], "/.", 
        RowBox[{"Automatic", "\[Rule]", 
         RowBox[{"formtrigreplacements", "[", 
          RowBox[{"Mx", ",", "opts"}], "]"}]}]}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"pSub", "=", 
       RowBox[{
        RowBox[{"psub", "/.", 
         RowBox[{"{", "opts", "}"}]}], "/.", 
        RowBox[{"Options", "[", "ExportExpression", "]"}]}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"(*", " ", 
       RowBox[{
        RowBox[{"produce", " ", "table", " ", "of", " ", "values"}], ",", " ", 
        RowBox[{"such", " ", "as", " ", 
         RowBox[{"{", 
          RowBox[{
           RowBox[{"{", 
            RowBox[{
             RowBox[{
              RowBox[{"MM", 
               RowBox[{"(", 
                RowBox[{"1", ",", "1"}], ")"}]}], "=", 
              RowBox[{"M", "*", "g", "*", "s12"}]}], ",", 
             RowBox[{
              RowBox[{"MM", 
               RowBox[{"(", 
                RowBox[{"1", ",", "2"}], ")"}]}], "=", "c12"}]}], "}"}], ",", 
           RowBox[{"{", 
            RowBox[{
             RowBox[{
              RowBox[{"MM", 
               RowBox[{"(", 
                RowBox[{"2", ",", "1"}], ")"}]}], "=", "c12"}], ",", 
             RowBox[{
              RowBox[{"MM", 
               RowBox[{"(", 
                RowBox[{"2", ",", "2"}], ")"}]}], "=", "c2"}]}], "}"}]}], 
          "}"}]}]}], " ", "*)"}], "\[IndentingNewLine]", 
      RowBox[{"elementsreplaced", "=", 
       RowBox[{"Table", "[", "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{"StringReplace", "[", " ", 
          RowBox[{"(*", " ", 
           RowBox[{"strip", " ", "quotes"}], " ", "*)"}], 
          "\[IndentingNewLine]", 
          RowBox[{"(*", " ", 
           RowBox[{
            RowBox[{
            "expression", " ", "of", " ", "the", " ", "form", " ", "name", 
             RowBox[{"(", 
              RowBox[{"i", ",", "j"}], ")"}]}], " ", "=", " ", "rhs"}], " ", 
           "*)"}], "\[IndentingNewLine]", 
          RowBox[{
           RowBox[{"ToString", "[", 
            RowBox[{"StringForm", "[", 
             RowBox[{
             "\"\<`1`(`2`,`3`) = `4`; \>\"", ",", "name", ",", "i", ",", "j", 
              ",", 
              RowBox[{
               RowBox[{"CForm", "[", 
                RowBox[{
                 RowBox[{
                  RowBox[{
                   RowBox[{"Mx", "[", 
                    RowBox[{"[", 
                    RowBox[{"i", ",", "j"}], "]"}], "]"}], "/.", "trigSubs"}],
                   "/.", "quSubs"}], "/.", "pSub"}], "]"}], "/.", 
               "lowercasefunctions"}]}], "]"}], "]"}], ",", 
           RowBox[{"\"\<\\\"\>\"", "->", "\"\<\>\""}]}], "]"}], ",", 
         "\[IndentingNewLine]", 
         RowBox[{"{", 
          RowBox[{"i", ",", "1", ",", 
           RowBox[{
            RowBox[{"Dimensions", "[", "Mx", "]"}], "[", 
            RowBox[{"[", "1", "]"}], "]"}]}], "}"}], ",", 
         RowBox[{"{", 
          RowBox[{"j", ",", "1", ",", 
           RowBox[{
            RowBox[{"Dimensions", "[", "Mx", "]"}], "[", 
            RowBox[{"[", "2", "]"}], "]"}]}], "}"}]}], "]"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"(*", " ", 
       RowBox[{
        RowBox[{
        "output", " ", "each", " ", "row", " ", "as", " ", "a", " ", 
         "separate", " ", "formatted", " ", "output"}], ",", " ", 
        RowBox[{
        "with", " ", "line", " ", "breaks", " ", "in", " ", "between"}]}], 
       " ", "*)"}], "\n", 
      RowBox[{"StringJoin", "[", 
       RowBox[{"Map", "[", 
        RowBox[{
         RowBox[{
          RowBox[{"StringInsert", "[", 
           RowBox[{
            RowBox[{"fmtString", "[", 
             RowBox[{"#", ",", "opts"}], "]"}], ",", "\"\<\\n\>\"", ",", 
            RowBox[{"-", "1"}]}], "]"}], "&"}], ",", 
         RowBox[{"Map", "[", 
          RowBox[{"StringJoin", ",", "elementsreplaced"}], "]"}]}], "]"}], 
       "]"}]}]}], "]"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"ExportExpression", "[", 
    RowBox[{
     RowBox[{"rhs_List", "?", "VectorQ"}], ",", " ", "name_String", ",", 
     "opts___"}], "]"}], ":=", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
      "elementsreplaced", ",", "quSubs", ",", "trigSubs", ",", "pSub"}], 
      "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"quSubs", "=", 
       RowBox[{
        RowBox[{
         RowBox[{"qusubs", "/.", 
          RowBox[{"{", "opts", "}"}]}], "/.", 
         RowBox[{"Options", "[", "ExportExpression", "]"}]}], "/.", 
        RowBox[{"Automatic", "\[Rule]", "formqureplacements"}]}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"trigSubs", "=", 
       RowBox[{
        RowBox[{
         RowBox[{
          RowBox[{"TrigSubs", "/.", 
           RowBox[{"{", "opts", "}"}]}], "/.", 
          RowBox[{"Options", "[", "ExportExpression", "]"}]}], "/.", 
         RowBox[{"None", "\[Rule]", 
          RowBox[{"{", "}"}]}]}], "/.", 
        RowBox[{"Automatic", "\[Rule]", 
         RowBox[{"formtrigreplacements", "[", 
          RowBox[{"rhs", ",", "opts"}], "]"}]}]}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"pSub", "=", 
       RowBox[{
        RowBox[{"psub", "/.", 
         RowBox[{"{", "opts", "}"}]}], "/.", 
        RowBox[{"Options", "[", "ExportExpression", "]"}]}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"(*", " ", 
       RowBox[{
        RowBox[{"produce", " ", "list", " ", "of", " ", "values"}], ",", " ", 
        RowBox[{"such", " ", "as", " ", 
         RowBox[{"{", 
          RowBox[{
           RowBox[{
            RowBox[{"rhs", 
             RowBox[{"(", "1", ")"}]}], "=", 
            RowBox[{"M", "*", "g", "*", "s12"}]}], ",", 
           RowBox[{
            RowBox[{"rhs", 
             RowBox[{"(", "2", ")"}]}], "=", "c12"}]}], "}"}]}]}], " ", 
       "*)"}], "\[IndentingNewLine]", 
      RowBox[{"elementsreplaced", "=", 
       RowBox[{"Table", "[", "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{"StringReplace", "[", " ", 
          RowBox[{"(*", " ", 
           RowBox[{"strip", " ", "quotes"}], " ", "*)"}], 
          "\[IndentingNewLine]", 
          RowBox[{"(*", " ", 
           RowBox[{
            RowBox[{
            "expression", " ", "of", " ", "the", " ", "form", " ", "name", 
             RowBox[{"(", 
              RowBox[{"i", ",", "j"}], ")"}]}], " ", "=", " ", "rhs"}], " ", 
           "*)"}], "\[IndentingNewLine]", 
          RowBox[{
           RowBox[{"ToString", "[", 
            RowBox[{"StringForm", "[", 
             RowBox[{"\"\<`1`(`2`) = `3`; \>\"", ",", "name", ",", "i", ",", 
              RowBox[{
               RowBox[{"CForm", "[", 
                RowBox[{
                 RowBox[{
                  RowBox[{
                   RowBox[{"rhs", "[", 
                    RowBox[{"[", "i", "]"}], "]"}], "/.", "trigSubs"}], "/.", 
                  "quSubs"}], "/.", "pSub"}], "]"}], "/.", 
               "lowercasefunctions"}]}], "]"}], "]"}], ",", 
           RowBox[{"\"\<\\\"\>\"", "->", "\"\<\>\""}]}], "]"}], ",", 
         "\[IndentingNewLine]", 
         RowBox[{"{", 
          RowBox[{"i", ",", "1", ",", 
           RowBox[{"Length", "[", "rhs", "]"}]}], "}"}]}], "]"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"(*", " ", 
       RowBox[{
        RowBox[{
        "output", " ", "each", " ", "row", " ", "as", " ", "a", " ", 
         "separate", " ", "formatted", " ", "output"}], ",", " ", 
        RowBox[{
        "with", " ", "line", " ", "breaks", " ", "in", " ", "between"}]}], 
       " ", "*)"}], "\[IndentingNewLine]", 
      RowBox[{"StringJoin", "[", 
       RowBox[{"Map", "[", 
        RowBox[{
         RowBox[{
          RowBox[{"StringInsert", "[", 
           RowBox[{
            RowBox[{"fmtString", "[", 
             RowBox[{"#", ",", "opts"}], "]"}], ",", "\"\<\\n\>\"", ",", 
            RowBox[{"-", "1"}]}], "]"}], "&"}], ",", "elementsreplaced"}], 
        "]"}], "]"}]}]}], "]"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"ExportExpression", "[", 
    RowBox[{
     RowBox[{"scalar_", " ", "/;", 
      RowBox[{"Nor", "[", 
       RowBox[{
        RowBox[{"VectorQ", "[", "scalar", "]"}], ",", 
        RowBox[{"MatrixQ", "[", "scalar", "]"}]}], " ", "]"}]}], ",", 
     "name_String", " ", ",", "opts___"}], "]"}], ":=", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"quSubs", ",", "trigSubs", ",", "pSub"}], "}"}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"quSubs", "=", 
       RowBox[{
        RowBox[{
         RowBox[{"qusubs", "/.", 
          RowBox[{"{", "opts", "}"}]}], "/.", 
         RowBox[{"Options", "[", "ExportExpression", "]"}]}], "/.", 
        RowBox[{"Automatic", "\[Rule]", "formqureplacements"}]}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"trigSubs", "=", 
       RowBox[{
        RowBox[{
         RowBox[{
          RowBox[{"TrigSubs", "/.", 
           RowBox[{"{", "opts", "}"}]}], "/.", 
          RowBox[{"Options", "[", "ExportExpression", "]"}]}], "/.", 
         RowBox[{"None", "\[Rule]", 
          RowBox[{"{", "}"}]}]}], "/.", 
        RowBox[{"Automatic", "\[Rule]", 
         RowBox[{"formtrigreplacements", "[", 
          RowBox[{"scalar", ",", "opts"}], "]"}]}]}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"pSub", "=", 
       RowBox[{
        RowBox[{"psub", "/.", 
         RowBox[{"{", "opts", "}"}]}], "/.", 
        RowBox[{"Options", "[", "ExportExpression", "]"}]}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"fmtString", "[", 
       RowBox[{
        RowBox[{"StringReplace", "[", 
         RowBox[{
          RowBox[{"ToString", "[", 
           RowBox[{"StringForm", "[", 
            RowBox[{
            "\"\<`1` = `2`;\>\"", ",", "name", ",", "\[IndentingNewLine]", 
             RowBox[{
              RowBox[{"CForm", "[", 
               RowBox[{
                RowBox[{
                 RowBox[{"scalar", "/.", "trigSubs"}], "/.", "quSubs"}], "/.",
                 "pSub"}], "]"}], "/.", "lowercasefunctions"}]}], "]"}], 
           "]"}], ",", 
          RowBox[{"\"\<\\\"\>\"", "->", "\"\<\>\""}]}], "]"}], ",", "opts"}], 
       "]"}]}]}], "]"}]}], ";"}]}], "Input",
 InitializationCell->True],

Cell["\<\
fmtString[string] reformats a long String argument and tries to break it into \
a bunch of lines with a Matlab (or other) continuator, so that the output is \
fairly readable code. Options include EndLine->\\\"\\\\n\\\" (end of line \
character), Continuator->\\\"...\\\" (Matlab or other line continuator), \
LineLength\[Rule]78 (max line length), Deliminator->\\\" \\\" (look for \
spaces, lists of deliminators are acceptable).\
\>", "Text"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"Options", "[", "fmtString", "]"}], "=", 
    RowBox[{"{", 
     RowBox[{
      RowBox[{"EndLine", "\[Rule]", "\"\<\\n\>\""}], ",", 
      RowBox[{"Continuator", "->", "\"\<...\>\""}], ",", 
      RowBox[{"LineLength", "\[Rule]", "78"}], ",", 
      RowBox[{"Delimiter", "->", "\"\< \>\""}]}], "}"}]}], ";"}], 
  "\[IndentingNewLine]", 
  RowBox[{"(*", " ", 
   RowBox[{
    RowBox[{
     RowBox[{"fmtString", "[", "string", "]"}], " ", "takes", " ", "a", " ", 
     "long", " ", "String", " ", "argument", " ", "and", " ", "tries", " ", 
     "to", " ", "break", " ", "it", " ", "into", " ", "a", " ", "bunch", " ", 
     "of", " ", "lines", " ", "with", " ", "a", " ", "Matlab", " ", 
     RowBox[{"(", 
      RowBox[{"or", " ", "other"}], ")"}], " ", "continuator"}], ",", " ", 
    RowBox[{
     RowBox[{
     "so", " ", "that", " ", "the", " ", "output", " ", "is", " ", 
      "digestable", " ", 
      RowBox[{"code", ".", " ", "Options"}], " ", "include", " ", "EndLine"}],
      "->", 
     RowBox[{"\"\<\\n\>\"", " ", 
      RowBox[{"(", 
       RowBox[{"end", " ", "of", " ", "line", " ", "character"}], ")"}]}]}], 
    ",", " ", 
    RowBox[{"Continuator", "->", 
     RowBox[{"\"\<...\>\"", " ", 
      RowBox[{"(", 
       RowBox[{
       "Matlab", " ", "or", " ", "other", " ", "line", " ", "continuator"}], 
       ")"}]}]}], ",", " ", 
    RowBox[{"LineLength", "\[Rule]", 
     RowBox[{"78", " ", 
      RowBox[{"(", 
       RowBox[{"max", " ", "line", " ", "length"}], ")"}]}]}], ",", " ", 
    RowBox[{"Delimiter", "->", 
     RowBox[{"\"\< \>\"", " ", 
      RowBox[{"(", 
       RowBox[{
        RowBox[{"look", " ", "for", " ", "spaces"}], ",", " ", 
        RowBox[{
        "lists", " ", "of", " ", "delimiters", " ", "are", " ", 
         "acceptable"}]}], ")"}]}]}]}], " ", "*)"}]}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"fmtString", "[", 
   RowBox[{"s_", ",", "opts___"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"maxlen", ",", 
      RowBox[{"instring", "=", "s"}], ",", 
      RowBox[{"outstring", "=", "\"\<\>\""}], ",", "spaces", ",", "eol", ",", 
      "continuator", ",", "delim"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"eol", "=", 
      RowBox[{
       RowBox[{
        RowBox[{"EndLine", "/.", 
         RowBox[{"{", "opts", "}"}]}], "/.", 
        RowBox[{"Options", "[", "fmtString", "]"}]}], "/.", 
       RowBox[{"None", "->", "\"\<\>\""}]}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"continuator", "=", 
      RowBox[{
       RowBox[{
        RowBox[{"Continuator", "/.", 
         RowBox[{"{", "opts", "}"}]}], "/.", 
        RowBox[{"Options", "[", "fmtString", "]"}]}], "/.", 
       RowBox[{"None", "->", "\"\<\>\""}]}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"maxlen", "=", 
      RowBox[{
       RowBox[{"LineLength", "/.", 
        RowBox[{"{", "opts", "}"}]}], "/.", 
       RowBox[{"Options", "[", "fmtString", "]"}]}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"delim", "=", 
      RowBox[{
       RowBox[{"Delimiter", "/.", 
        RowBox[{"{", "opts", "}"}]}], "/.", 
       RowBox[{"Options", "[", "fmtString", "]"}]}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"While", "[", 
      RowBox[{
       RowBox[{
        RowBox[{"StringLength", "[", "instring", "]"}], ">", "maxlen"}], ",", 
       "\[IndentingNewLine]", 
       RowBox[{
        RowBox[{"spaces", "=", 
         RowBox[{"StringPosition", "[", " ", 
          RowBox[{
           RowBox[{"StringTake", "[", 
            RowBox[{"instring", ",", " ", "maxlen"}], "]"}], ",", " ", 
           "delim"}], "]"}]}], ";", "\[IndentingNewLine]", 
        RowBox[{"If", "[", " ", 
         RowBox[{
          RowBox[{
           RowBox[{"Length", "[", "spaces", "]"}], " ", "<", " ", "1"}], ",", 
          " ", 
          RowBox[{"spaces", " ", "=", " ", 
           RowBox[{"StringPosition", "[", " ", 
            RowBox[{"instring", ",", " ", "delim"}], "]"}]}]}], "]"}], ";", 
        "\[IndentingNewLine]", 
        RowBox[{"outstring", " ", "=", " ", 
         RowBox[{"outstring", " ", "<>", " ", 
          RowBox[{"StringTake", "[", 
           RowBox[{"instring", ",", " ", 
            RowBox[{
             RowBox[{"Last", "[", "spaces", "]"}], "[", 
             RowBox[{"[", "1", "]"}], "]"}]}], "]"}], " ", "<>", " ", 
          "continuator", "<>", "eol"}]}], ";", "\[IndentingNewLine]", 
        RowBox[{"instring", " ", "=", " ", 
         RowBox[{"StringDrop", "[", " ", 
          RowBox[{"instring", ",", " ", 
           RowBox[{
            RowBox[{"Last", "[", "spaces", "]"}], "[", 
            RowBox[{"[", "1", "]"}], "]"}]}], "]"}]}], ";"}]}], 
      "\[IndentingNewLine]", "]"}], ";", "\[IndentingNewLine]", 
     RowBox[{"outstring", " ", "=", " ", 
      RowBox[{"outstring", " ", "<>", " ", "instring"}]}]}]}], " ", 
   "]"}]}]}], "Input",
 InitializationCell->True],

Cell[TextData[{
 StyleBox["LinearTerms",
  FontWeight->"Bold"],
 "[ expressions, terms] returns a matrix of linear coefficients of the \
variables listed in terms, that appear in the expressions (also a list) \
given. One option is Simplifier->Simplify, which causes the specified \
function to be applied to the matrix. UnLinearTerms returns all of the \
remaining terms that are not linear in the LinearTerms."
}], "Text"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"Options", "[", "LinearTerms", "]"}], "=", 
   RowBox[{"{", 
    RowBox[{"Simplifier", "\[Rule]", "Identity"}], "}"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"LinearTerms", "[", " ", 
    RowBox[{"rhs_", ",", "terms_List", ",", "opts___"}], " ", "]"}], " ", ":=",
    " ", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"linearstuff", ",", "simp"}], "}"}], ",", 
     RowBox[{
      RowBox[{"simp", "=", 
       RowBox[{
        RowBox[{"Simplifier", "/.", 
         RowBox[{"{", "opts", "}"}]}], "/.", 
        RowBox[{"Options", "[", "LinearTerms", "]"}]}]}], ";", 
      RowBox[{"linearstuff", "=", 
       RowBox[{
        RowBox[{"Outer", "[", 
         RowBox[{
          RowBox[{
           RowBox[{"Coefficient", "[", 
            RowBox[{"#1", ",", "#2"}], "]"}], "&"}], ",", "rhs", ",", 
          "terms"}], "]"}], "//", "simp"}]}]}]}], "]"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{"Options", "[", "UnLinearTerms", "]"}], "=", 
   RowBox[{"{", 
    RowBox[{"Simplifier", "\[Rule]", "Identity"}], "}"}]}], ";"}], "\n", 
 RowBox[{
  RowBox[{"UnLinearTerms", "[", 
   RowBox[{"rhs_", ",", "terms_", ",", "opts___"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", "simp", "}"}], ",", 
    RowBox[{
     RowBox[{"simp", "=", 
      RowBox[{
       RowBox[{"Simplifier", "/.", 
        RowBox[{"{", "opts", "}"}]}], "/.", 
       RowBox[{"Options", "[", "UnLinearTerms", "]"}]}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"rhs", "/.", 
       RowBox[{"Map", "[", 
        RowBox[{
         RowBox[{
          RowBox[{"#", "\[Rule]", "0"}], "&"}], ",", "terms"}], "]"}]}], "//",
       "simp"}]}]}], "]"}]}], "\n", 
 RowBox[{
  RowBox[{
   RowBox[{
    RowBox[{"LinearTerms", "[", 
     RowBox[{"rhs_", ",", "term_", ",", "opts___"}], "]"}], ":=", 
    RowBox[{"LinearTerms", "[", 
     RowBox[{"rhs", ",", 
      RowBox[{"{", "term", "}"}], ",", "opts"}], "]"}]}], ";"}], " ", 
  RowBox[{"(*", " ", 
   RowBox[{
    RowBox[{
    "if", " ", "only", " ", "one", " ", "term", " ", "is", " ", "used"}], ",",
     " ", 
    RowBox[{"turn", " ", "it", " ", "into", " ", "a", " ", "list"}]}], " ", 
   "*)"}]}]}], "Input",
 InitializationCell->True],

Cell[TextData[{
 StyleBox["ExportCode",
  FontWeight->"Bold"],
 " writes a Matlab function to evaluate the state-derivative. Features \
include substitution of q's and u's for the state x, and substitution of \
shorthand trig functions such as s1 for sin(q(1)). \
ExportCode[{massmatrix,rhs}] uses the mass matrix and right-hand side given \
(usually found using MassMatrix[]). Alternatively, ExportCode[equations] will \
call MassMatrix[] automatically. Several optional arguments may be given. \
Forces->{T1,T2} specifies forces that enter linearly into the equations; \
ExportCode will export a matrix of coefficients for these forces. Another \
option is Expressions->{{KE,\"KE\"},{PE,\"PE\"}}, which outputs the specified \
additional expressions, named with the strings given. Each expression must be \
paired with a name within a list. The output of ExportCode can be sent to a \
file with OutputFile->\"filename\", which is automatically produced in the \
current directory. Formatting options include EndLine->\"\\n\", Continuator->\
\"...\", LineLength->78, Deliminator->\" \", which specify the end-of-line \
character, line continuator, maximum line length of the output, and the \
deliminators where line breaks can occur (default to space character).\n "
}], "Text"],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"Options", "[", "ExportCode", "]"}], "=", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"OutputFile", "\[Rule]", "None"}], ",", 
     RowBox[{"Forces", "\[Rule]", "None"}], ",", 
     RowBox[{"Expressions", "\[Rule]", "None"}]}], "}"}]}], ";"}]], "Input",
 InitializationCell->True],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"ExportCode", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
       RowBox[{"mass_List", "?", "MatrixQ"}], ",", 
       RowBox[{"rhs_List", "?", "VectorQ"}]}], "}"}], ",", "opts___"}], "]"}],
    ":=", 
   RowBox[{"Module", "[", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{
      "ostrm", ",", "outputfile", ",", "quSubs", ",", "trigSubs", ",", 
       "linearforceterms", ",", "forces", ",", "forcenames", ",", "myopts"}], 
      "}"}], ",", "\[IndentingNewLine]", 
     RowBox[{"(*", " ", 
      RowBox[{
       RowBox[{
        RowBox[{"write", " ", "a", " ", "state"}], "-", 
        RowBox[{"derivative", " ", "function", " ", "in", " ", "Matlab"}]}], 
       ",", " ", 
       RowBox[{"with", " ", "mass", " ", "matrix"}], ",", " ", 
       RowBox[{"right", "-", 
        RowBox[{"hand", " ", "side"}]}], ",", " ", 
       RowBox[{
       "and", "\[IndentingNewLine]", "extras", " ", "like", " ", "forces", 
        " ", "and", " ", "additional", " ", "expressions"}]}], " ", "*)"}], 
     "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"outputfile", "=", 
       RowBox[{
        RowBox[{"OutputFile", "/.", 
         RowBox[{"{", "opts", "}"}]}], "/.", 
        RowBox[{"Options", "[", "ExportCode", "]"}]}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"forces", "=", 
       RowBox[{
        RowBox[{
         RowBox[{"Forces", "/.", 
          RowBox[{"{", "opts", "}"}]}], "/.", 
         RowBox[{"Options", "[", "ExportCode", "]"}]}], "/.", 
        RowBox[{"None", "\[Rule]", 
         RowBox[{"{", "}"}]}]}]}], ";", "\[IndentingNewLine]", 
      RowBox[{"(*", " ", 
       RowBox[{
        RowBox[{
        "forces", " ", "can", " ", "be", " ", "a", " ", "list", " ", "of", 
         " ", "forces"}], ",", " ", 
        RowBox[{
        "or", " ", "a", " ", "list", " ", "of", " ", "forces", " ", "and", 
         " ", "force", " ", "names"}], ",", " ", 
        RowBox[{"e", ".", "g", ".", " ", 
         RowBox[{"{", 
          RowBox[{
           RowBox[{"{", 
            RowBox[{"Rx", ",", "\"\<Rx\>\""}], "}"}], ",", 
           RowBox[{"{", 
            RowBox[{"Ry", ",", "\"\<Ry\>\""}], "}"}]}], "}"}]}]}], " ", 
       "*)"}], "\[IndentingNewLine]", 
      RowBox[{"If", "[", 
       RowBox[{
        RowBox[{"VectorQ", "[", "forces", "]"}], ",", 
        RowBox[{"forcenames", "=", 
         RowBox[{"Map", "[", 
          RowBox[{"SymbolName", ",", "forces"}], "]"}]}], ",", " ", 
        RowBox[{"(*", " ", "else", " ", "*)"}], "\[IndentingNewLine]", 
        RowBox[{"If", "[", 
         RowBox[{
          RowBox[{"MatrixQ", "[", "forces", "]"}], ",", 
          RowBox[{
           RowBox[{"{", 
            RowBox[{"forces", ",", "forcenames"}], "}"}], "=", 
           RowBox[{"Transpose", "[", "forces", "]"}]}]}], "]"}]}], "]"}], ";",
       "\[IndentingNewLine]", 
      RowBox[{"expressions", "=", 
       RowBox[{"Replace", "[", 
        RowBox[{
         RowBox[{
          RowBox[{
           RowBox[{"Expressions", "/.", 
            RowBox[{"{", "opts", "}"}]}], "/.", 
           RowBox[{"Options", "[", "ExportCode", "]"}]}], "/.", 
          RowBox[{"None", "\[Rule]", 
           RowBox[{"{", "}"}]}]}], ",", " ", 
         RowBox[{
          RowBox[{"x", ":", 
           RowBox[{"{", 
            RowBox[{"_", ",", "_String"}], "}"}]}], "\[Rule]", 
          RowBox[{"{", "x", "}"}]}]}], "]"}]}], ";", "\[IndentingNewLine]", 
      RowBox[{"ostrm", "=", 
       RowBox[{"If", "[", 
        RowBox[{
         RowBox[{"outputfile", "=!=", "None"}], ",", " ", 
         RowBox[{"(*", " ", 
          RowBox[{"there", " ", "is", " ", "a", " ", "file", " ", "given"}], 
          " ", "*)"}], "\[IndentingNewLine]", 
         RowBox[{
          RowBox[{"Print", "[", 
           RowBox[{
           "\"\<Opening file \\\"\>\"", ",", "outputfile", ",", 
            "\"\<\\\"\>\""}], "]"}], ";", "\[IndentingNewLine]", 
          RowBox[{"Print", "[", 
           RowBox[{"\"\<Current directory: \>\"", ",", 
            RowBox[{"Directory", "[", "]"}]}], "]"}], ";", 
          "\[IndentingNewLine]", 
          RowBox[{"OpenWrite", "[", "outputfile", "]"}]}], ",", " ", 
         RowBox[{"(*", " ", "else", " ", "*)"}], "\[IndentingNewLine]", 
         "$Output"}], "]"}]}], ";", "\[IndentingNewLine]", 
      RowBox[{"quSubs", "=", "formqureplacements"}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"trigSubs", "=", 
       RowBox[{"formtrigreplacements", "[", 
        RowBox[{
         RowBox[{"{", 
          RowBox[{"mass", ",", "rhs"}], "}"}], ",", "opts"}], "]"}]}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"myopts", "=", 
       RowBox[{"Sequence", "[", 
        RowBox[{
         RowBox[{"qusubs", "\[Rule]", "quSubs"}], ",", 
         RowBox[{"TrigSubs", "\[Rule]", "trigSubs"}]}], "]"}]}], ";", " ", 
      RowBox[{"(*", " ", 
       RowBox[{"options", " ", "generated", " ", "automatically"}], " ", 
       "*)"}], "\[IndentingNewLine]", 
      RowBox[{"WriteString", "[", 
       RowBox[{
       "ostrm", ",", "\"\<function xdot = fstatederivative(t, x)\\n\\n\>\""}],
        "]"}], ";", " ", 
      RowBox[{"(*", " ", 
       RowBox[{"intended", " ", "for", " ", "ode45", " ", "call"}], " ", 
       "*)"}], "\[IndentingNewLine]", 
      RowBox[{"(*", " ", 
       RowBox[{
       "Print", " ", "out", " ", "some", " ", "nice", " ", "comment", " ", 
        "reminders"}], " ", "*)"}], "\[IndentingNewLine]", 
      RowBox[{"WriteString", "[", 
       RowBox[{"ostrm", ",", "\"\<% Define constants\\n\\n\>\""}], "]"}], ";",
       "\[IndentingNewLine]", 
      RowBox[{"(*", " ", 
       RowBox[{
        RowBox[{"Print", " ", "out", " ", "the", " ", "forces"}], ",", " ", 
        RowBox[{"if", " ", "they", " ", "exist"}]}], " ", "*)"}], 
      "\[IndentingNewLine]", 
      RowBox[{"WriteString", "[", 
       RowBox[{"ostrm", ",", "\"\<% Define forces: \>\""}], "]"}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"If", "[", 
       RowBox[{
        RowBox[{
         RowBox[{"Length", "[", "forces", "]"}], ">", "0"}], ",", 
        RowBox[{"WriteString", "[", 
         RowBox[{"ostrm", ",", "\"\<[\>\"", ",", "\[IndentingNewLine]", 
          RowBox[{"StringDrop", "[", 
           RowBox[{
            RowBox[{"StringJoin", "[", 
             RowBox[{"Map", "[", 
              RowBox[{
               RowBox[{
                RowBox[{
                 RowBox[{"SymbolName", "[", "#", "]"}], "<>", "\"\<, \>\""}], 
                "&"}], ",", "forces"}], "]"}], "]"}], ",", 
            RowBox[{"-", "2"}]}], "]"}], ",", "\"\<]'\>\""}], "]"}]}], "]"}], 
      ";", "\[IndentingNewLine]", 
      RowBox[{"WriteString", "[", 
       RowBox[{"ostrm", ",", "\"\<\\n\\n% State assignments\\n\>\""}], "]"}], 
      ";", "\[IndentingNewLine]", 
      RowBox[{"WriteString", "[", 
       RowBox[{"ostrm", ",", 
        RowBox[{"(*", " ", 
         RowBox[{
          RowBox[{"export", " ", "the", " ", "state", " ", "assignments"}], 
          ",", " ", 
          RowBox[{"q1", " ", "=", " ", 
           RowBox[{"x", 
            RowBox[{"(", "1", ")"}]}]}], ",", " ", 
          RowBox[{"etc", "."}]}], " ", "*)"}], "\[IndentingNewLine]", 
        RowBox[{"StringJoin", "[", 
         RowBox[{"Map", "[", 
          RowBox[{
           RowBox[{
            RowBox[{"ToString", "[", 
             RowBox[{"StringForm", "[", 
              RowBox[{"\"\<q`1` = x(`1`); \>\"", ",", "#"}], "]"}], "]"}], 
            "&"}], ",", "qdofs"}], "]"}], "]"}], ",", "\"\<\\n\>\""}], "]"}], 
      ";", 
      RowBox[{"WriteString", "[", 
       RowBox[{"ostrm", ",", 
        RowBox[{"StringJoin", "[", 
         RowBox[{"Map", "[", 
          RowBox[{
           RowBox[{
            RowBox[{"ToString", "[", 
             RowBox[{"StringForm", "[", 
              RowBox[{"\"\<u`1` = x(`2`); \>\"", ",", " ", "#", ",", 
               RowBox[{"#", "+", 
                RowBox[{"Length", "[", "qdofs", "]"}]}]}], "]"}], "]"}], 
            "&"}], ",", "udofs"}], "]"}], "]"}], ",", "\"\<\\n\\n\>\""}], 
       "]"}], ";", "\[IndentingNewLine]", 
      RowBox[{"(*", " ", 
       RowBox[{
        RowBox[{"export", " ", "the", " ", "trig", " ", "assignments"}], ",", 
        " ", 
        RowBox[{"s1", " ", "=", " ", 
         RowBox[{"sin", 
          RowBox[{"(", "q1", ")"}]}]}], ",", " ", 
        RowBox[{"etc", "."}]}], " ", "*)"}], "\[IndentingNewLine]", 
      RowBox[{"WriteString", "[", 
       RowBox[{"ostrm", ",", 
        RowBox[{"StringReplace", "[", " ", 
         RowBox[{"(*", " ", 
          RowBox[{
          "strip", " ", "out", " ", "the", " ", "quote", " ", "marks"}], " ", 
          "*)"}], "\[IndentingNewLine]", 
         RowBox[{
          RowBox[{"StringJoin", "[", 
           RowBox[{"Map", "[", 
            RowBox[{
             RowBox[{
              RowBox[{"ToString", "[", 
               RowBox[{"StringForm", "[", 
                RowBox[{"\"\<`1` = `2`; \>\"", ",", " ", 
                 RowBox[{"#", "[", 
                  RowBox[{"[", "2", "]"}], "]"}], ",", 
                 RowBox[{"CForm", "[", 
                  RowBox[{
                   RowBox[{
                    RowBox[{"#", "[", 
                    RowBox[{"[", "1", "]"}], "]"}], "/.", "quSubs"}], "/.", 
                   RowBox[{"{", 
                    RowBox[{
                    RowBox[{"Sin", "\[Rule]", "\"\<sin\>\""}], ",", 
                    RowBox[{"Cos", "\[Rule]", "\"\<cos\>\""}], ",", 
                    RowBox[{"Tan", "\[Rule]", "\"\<tan\>\""}], ",", 
                    RowBox[{"Sec", "\[Rule]", "\"\<sec\>\""}], ",", 
                    RowBox[{"Csc", "\[Rule]", "\"\<csc\>\""}]}], "}"}]}], 
                  "]"}]}], "]"}], "]"}], "&"}], ",", "trigSubs"}], "]"}], 
           "]"}], ",", 
          RowBox[{"\"\<\\\"\>\"", "->", "\"\<\>\""}]}], "]"}], ",", 
        "\"\<\\n\\n\>\""}], "]"}], ";", "\[IndentingNewLine]", 
      RowBox[{"(*", " ", 
       RowBox[{
        RowBox[{"pre", "-", 
         RowBox[{"allocate", " ", "mass", " ", "matrix"}]}], ",", " ", 
        RowBox[{"force", " ", "matrix"}], ",", " ", 
        RowBox[{"and", " ", "otherrhs"}]}], " ", "*)"}], 
      "\[IndentingNewLine]", 
      RowBox[{"WriteString", "[", 
       RowBox[{"ostrm", ",", 
        RowBox[{"ToString", "[", 
         RowBox[{"StringForm", "[", 
          RowBox[{"\"\<MM = zeros(`1`,`1`); \>\"", ",", 
           RowBox[{"Length", "[", "udofs", "]"}]}], "]"}], "]"}]}], "]"}], 
      ";", "\[IndentingNewLine]", 
      RowBox[{"If", "[", 
       RowBox[{
        RowBox[{
         RowBox[{"Length", "[", "forces", "]"}], ">", "0"}], ",", " ", 
        RowBox[{"(*", " ", 
         RowBox[{"a", " ", "force", " ", "matrix", " ", "needed"}], " ", 
         "*)"}], "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{"linearforceterms", " ", "=", " ", 
          RowBox[{"LinearTerms", "[", 
           RowBox[{"rhs", ",", "forces", ",", "opts"}], "]"}]}], ";", 
         "\[IndentingNewLine]", 
         RowBox[{"WriteString", "[", 
          RowBox[{"ostrm", ",", 
           RowBox[{"ToString", "[", 
            RowBox[{"StringForm", "[", 
             RowBox[{"\"\<FF = zeros(`1`,`2`); \>\"", ",", 
              RowBox[{"Length", "[", "udofs", "]"}], ",", 
              RowBox[{
               RowBox[{"Dimensions", "[", "linearforceterms", "]"}], "[", 
               RowBox[{"[", "2", "]"}], "]"}]}], " ", "]"}], "]"}]}], 
          "]"}]}]}], "]"}], ";", "\[IndentingNewLine]", 
      RowBox[{"WriteString", "[", 
       RowBox[{"ostrm", ",", 
        RowBox[{"ToString", "[", 
         RowBox[{"StringForm", "[", 
          RowBox[{"\"\<rhs = zeros(`1`,1);\\n\\n\>\"", ",", 
           RowBox[{"Length", "[", "udofs", "]"}]}], "]"}], " ", "]"}]}], 
       "]"}], ";", "\[IndentingNewLine]", 
      RowBox[{"(*", " ", 
       RowBox[{"export", " ", "something", " ", "of", " ", "the", " ", "form", 
        RowBox[{"{", 
         RowBox[{"MM", ",", "\"\<MM\>\""}], "}"}]}], " ", "*)"}], 
      "\[IndentingNewLine]", 
      RowBox[{"WriteString", "[", 
       RowBox[{"ostrm", ",", "\"\<% Mass Matrix\\n\>\"", ",", 
        RowBox[{"ExportExpression", "[", 
         RowBox[{"mass", ",", "\"\<MM\>\"", ",", "myopts", ",", "opts"}], 
         "]"}], ",", "\"\<\\n\>\""}], "]"}], ";", "\[IndentingNewLine]", 
      RowBox[{"If", "[", 
       RowBox[{
        RowBox[{
         RowBox[{"Length", "[", "forces", "]"}], ">", "0"}], ",", " ", 
        RowBox[{"(*", " ", 
         RowBox[{
          RowBox[{
          "if", " ", "there", " ", "are", " ", "listed", " ", "forces"}], ",",
           " ", 
          RowBox[{
          "export", " ", "the", " ", "linear", " ", "terms", " ", "for", " ", 
           "them"}]}], " ", "*)"}], "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{"WriteString", "[", 
          RowBox[{"ostrm", ",", "\"\<% Force Matrix\\n\>\"", ",", 
           RowBox[{"ExportExpression", "[", 
            RowBox[{
            "linearforceterms", ",", "\"\<FF\>\"", ",", "myopts", ",", 
             "opts"}], "]"}], ",", "\"\<\\n\>\""}], "]"}], ";", 
         "\[IndentingNewLine]", 
         RowBox[{"WriteString", "[", 
          RowBox[{
          "ostrm", ",", "\"\<% other righthand side terms\\n\>\"", ",", 
           RowBox[{"ExportExpression", "[", 
            RowBox[{
             RowBox[{"UnLinearTerms", "[", 
              RowBox[{"rhs", ",", "forces"}], "]"}], ",", "\"\<rhs\>\"", ",", 
             "myopts", ",", "opts"}], "]"}], ",", "\"\<\\n\>\""}], "]"}], ";",
          "\[IndentingNewLine]", 
         RowBox[{"WriteString", "[", 
          RowBox[{"ostrm", ",", "\"\<rhs = rhs + FF*forces;\\n\>\""}], 
          "]"}]}], ",", " ", 
        RowBox[{"(*", " ", 
         RowBox[{
         "else", " ", "just", " ", "give", " ", "the", " ", "whole", " ", 
          "rhs"}], " ", "*)"}], "\[IndentingNewLine]", 
        RowBox[{"WriteString", "[", 
         RowBox[{"ostrm", ",", "\"\<% righthand side terms\\n\>\"", ",", 
          RowBox[{"ExportExpression", "[", 
           RowBox[{"rhs", ",", "\"\<rhs\>\"", ",", "myopts", ",", "opts"}], 
           "]"}], ",", "\"\<\\n\>\""}], "]"}]}], "]"}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"WriteString", "[", 
       RowBox[{"ostrm", ",", "\"\<udot = MM\\\\rhs;\\n\>\""}], "]"}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"WriteString", "[", 
       RowBox[{"ostrm", ",", 
        RowBox[{"ToString", "[", 
         RowBox[{"StringForm", "[", 
          RowBox[{"\"\<xdot = [x(`1`+1:2*`1`); udot];\>\"", ",", 
           RowBox[{"Length", "[", "qdofs", "]"}]}], "]"}], "]"}], ",", 
        "\"\<\\n\>\""}], "]"}], ";", "\[IndentingNewLine]", 
      RowBox[{"(*", " ", 
       RowBox[{
        RowBox[{"write", " ", "out", " ", "extra", " ", "expressions"}], ",", 
        " ", 
        RowBox[{"if", " ", "any"}]}], " ", "*)"}], "\[IndentingNewLine]", 
      RowBox[{"WriteString", "[", 
       RowBox[{"ostrm", ",", 
        RowBox[{"Apply", "[", 
         RowBox[{"Sequence", ",", 
          RowBox[{"Flatten", "[", 
           RowBox[{"Map", "[", 
            RowBox[{
             RowBox[{
              RowBox[{"{", 
               RowBox[{"\"\<\\n\>\"", ",", 
                RowBox[{"ExportExpression", "[", 
                 RowBox[{
                  RowBox[{"#", "[", 
                   RowBox[{"[", "1", "]"}], "]"}], ",", 
                  RowBox[{"#", "[", 
                   RowBox[{"[", "2", "]"}], "]"}], ",", "myopts", ",", 
                  "opts"}], "]"}], ",", "\"\<\\n\>\""}], "}"}], "&"}], ",", 
             "expressions"}], "]"}], "]"}]}], "]"}]}], "]"}], ";", 
      "\[IndentingNewLine]", 
      RowBox[{"If", "[", 
       RowBox[{
        RowBox[{"outputfile", "=!=", "None"}], ",", 
        RowBox[{
         RowBox[{"Print", "[", 
          RowBox[{
          "\"\<Closing file \\\"\>\"", ",", "outputfile", ",", 
           "\"\<\\\"\>\""}], "]"}], ";", 
         RowBox[{"Close", "[", "ostrm", "]"}]}]}], "]"}], ";"}]}], 
    "\[IndentingNewLine]", "]"}]}], ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"ExportCode", "[", 
    RowBox[{"eom_", ",", "opts___"}], "]"}], ":=", 
   RowBox[{"ExportCode", "[", 
    RowBox[{
     RowBox[{"MassMatrix", "[", "eom", "]"}], ",", "opts"}], "]"}]}], 
  ";"}]}], "Input",
 InitializationCell->True],

Cell[CellGroupData[{

Cell["Building a Model", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["NewModel", "Subsection",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[TextData[{
 "Whenever a new model is constructed, ",
 StyleBox["NewModel",
  FontWeight->"Bold",
  FontSlant->"Plain"],
 " must be invoked to set up a new frame tree"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
NewModel[opts___] := Module[{gif},
\t(*Begin[\"DynWkbnch`\"];*)
\tqdofs={};
\tudofs={};
\tzees={};
\tClear[ Parents, Kids, Tmtx, Kinematics,
\t  Inboard, VelCOM, VelJnt, AngVel, AccCOM, AccJnt, AngAcc,
\t  Force, Torque, Mass, Inertia, BodyToJnt, InbToJnt, JntToJnt,
\t  GInerFrc, GActFrc, Tstar, CML];
\tParents[ground] = {};
\tKids[ground] = {};
\tTmtx[{}] = IdentityMatrix[3];
\tFrames = {ground};
\tBodies = {};
\tground[n_?CoordQ] := PV[{1,ground,n}];
\tKinematics = {};
\tNonholonomic = {};
\tMass[(bodies_)?ListQ] := Mass /@ bodies; 
\tPosCOM[ ground ] = 0;
\tAngVel[ ground ] = PV[{0,ground,1}];
\tAngVel[ frme1_, frme2_ ] := AngVel[frme1] - 
\t\tAngVel[frme2] /; ValueQ[AngVel[frme2]];
\tVelCOM[ ground ] = 0;
\tVelCOM[(bodies_)?ListQ] := 
  Simplify[Plus @@ (Mass /@ bodies*VelCOM /@ bodies)/
    Plus @@ Mass /@ bodies];
\tAngAcc[ ground ] = 0;
\tAccCOM[ ground ] = 0;
\tInboard[ ground ] = {};
\tDofs[ ground ] = {{},{}};
\tZF = If[(Zees/.{opts})===On,Zee,Identity];
\tIf[(DotProductList/.{opts})===On, (* want to memorize dot products *)
\t\tDotProduct[frame1_,coord1_,frame2_,coord2_]=. ];
\tgif = If[(Simplify/.{opts})===On, GInerFrcS, GInerFrcC];
\tGInerFrc[x__] := GInerFrc[x] = gif[x]; 
\tGActFrc[x__] := GActFrc[x] = GActFrcC[x];
\tTstar[x__] := Tstar[x] = TstarC[x];
\tCML[from_,to_]:=Module[{frame1,frame2},{frame1,frame2}=Sort[{from,to}];
    If[OrderedQ[{from,to}],Identity,Transpose][
      CML[frame1,frame2]=CastMtx[frame1,frame2]]]
\t(*End[ ];*)
\t]\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell["AddFrame", "Subsection",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["Options for AddFrame", "Subsubsection",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
Options[ AddFrame ] = {Axis->{0,0,1}, Qdof->Automatic,
\tAxis1->{0,0,1},Axis2->{0,1,0},Axis3->{0,0,1},Qdof1->Automatic,
\tQdof2->Automatic, Qdof3->Automatic, Qdof4->Automatic, 
\tOffset->{{1,0,0},{0,1,0},{0,0,1}},  QOffset->0, QOffsets->{0,0}
\t};\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell["AddFrame for Hinge joint", "Subsubsection",
 Evaluatable->False,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[TextData[{
 "AddFrame[frme_,basefrm_,Hinge, opts___Rule ] := Module[\n {newqdof, z1, z2, \
z3},\n \n\t{newqdof} = ReplaceDofs[ {Qdof} \n\t\t\t/. {opts} /. Options[ \
AddFrame ], qdofs ];\n\tqdofs = Union[ qdofs, {newqdof} ];\n\tFrames = Union[ \
Append[Frames, frme] ];\n\t\n\tq0 = QOffset /. {opts} /. Options[ AddFrame ];\
\n\t\n\t{z1,z2,z3} = ConvertList[Axis /.\n\t\t\t\t{opts} /. Options[ AddFrame \
], basefrm] ;\n\n\t",
 StyleBox["(* Now set up the transformation matrix between frames *)",
  FontWeight->"Plain",
  FontSlant->"Italic"],
 "\n\tTmtx[frme] = {\n  {z1^2 (1-Cos[q[newqdof]-q0]) + Cos[q[newqdof]-q0],\n  \
 z1 z2 (1-Cos[q[newqdof]-q0]) + z3 Sin[q[newqdof]-q0],\n   z1 z3 \
(1-Cos[q[newqdof]-q0]) - z2 Sin[q[newqdof]-q0]},\n  {z1 z2 \
(1-Cos[q[newqdof]-q0]) - z3 Sin[q[newqdof]-q0],\n   z2^2 \
(1-Cos[q[newqdof]-q0]) + Cos[q[newqdof]-q0],\n   z2 z3 (1-Cos[q[newqdof]-q0]) \
+ z1 Sin[q[newqdof]-q0]},\n  {z1 z3 (1-Cos[q[newqdof]-q0]) + z2 \
Sin[q[newqdof]-q0],\n   z2 z3 (1-Cos[q[newqdof]-q0]) - z1 Sin[q[newqdof]-q0],\
\n   z3^2 (1-Cos[q[newqdof]-q0]) + Cos[q[newqdof]-q0]}};\n   \n\t\
Evaluate[frme][n_?CoordQ] := PV[{1,frme,n}];\n\tParents[frme] = Append[ \
Parents[basefrm], frme];\n\tKids[frme] = {};\n\tKids[basefrm] = Append[ \
Kids[basefrm], frme];\n\n\t{newqdof}\n];"
}], "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Open  ]],

Cell[CellGroupData[{

Cell["AddFrame for Fixed/Slider joint", "Subsubsection",
 Evaluatable->False,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[TextData[{
 "AddFrame[frme_,basefrm_,Fixed, opts___Rule] := Module[\n\t{mtx, z1, z2, \
z3}, \n\tFrames = Union[ Append[Frames, frme] ];\n\t\n\t",
 StyleBox["(* Now set up the transformation matrix between frames *)",
  FontWeight->"Plain",
  FontSlant->"Italic"],
 "\n\tTmtx[frme] = ConvertOffset[ Offset, basefrm ] /. {opts} /.\n\t\t \
Options[AddFrame];\n\n\tEvaluate[frme][n_?CoordQ] := PV[{1,frme,n}];\n\t\
Parents[frme] = Append[ Parents[basefrm], frme];\n\tKids[frme] = {};\n\t\
Kids[basefrm] = Append[ Kids[basefrm], frme];\n\t{}  ",
 StyleBox["(* No generalized coordinate, so output is null *)",
  FontWeight->"Plain",
  FontSlant->"Italic"],
 "\n];"
}], "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[TextData[{
 "AddFrame[frme_,basefrm_,Slider, opts___Rule] := Module[\n\t{mtx, z1, z2, \
z3}, \n\tFrames = Union[ Append[Frames, frme] ];\n\t\n\t",
 StyleBox["(* Now set up the transformation matrix between frames *)",
  FontWeight->"Plain",
  FontSlant->"Italic"],
 "\n\tTmtx[frme] = ConvertOffset[ Offset, basefrm ] /. {opts} /.\n\t\t \
Options[AddFrame];\n\n\tEvaluate[frme][n_?CoordQ] := PV[{1,frme,n}];\n\t\
Parents[frme] = Append[ Parents[basefrm], frme];\n\tKids[frme] = {};\n\t\
Kids[basefrm] = Append[ Kids[basefrm], frme];\n\t{}  ",
 StyleBox["(* No generalized coordinate, so output is null *)",
  FontWeight->"Plain",
  FontSlant->"Italic"],
 "\n];"
}], "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell["AddFrame for U joint", "Subsubsection",
 Evaluatable->False,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell[TextData[{
 "AddFrame[frme_,basefrm_,UJoint, opts___Rule ] := Module[\n\t\t{z11, z12, \
z13, z21, z22, z23,\n\t\t newqdofs, q1, q2},\n\n\t\t{z11,z12,z13} = \n\t\t\t\t\
ConvertList[Axis1, basefrm] /. {opts} /. Options[ AddFrame ];\n\t\t\
{z21,z22,z23} =\n\t  \tConvertList[Axis2, basefrm] /. {opts} /. Options[ \
AddFrame ];\n\t\n\t\tnewqdofs = {q1, q2} = ReplaceDofs[ {Qdof1, Qdof2}/.\n\t\t\
 \t{opts} /. Options[ AddFrame ], qdofs ] ;\n\t\tqdofs = Union[ qdofs, \
newqdofs ];\n\t\n\t\tFrames = Union[ Append[Frames, frme] ];\n\t\n\t{q10,q20} \
= QOffsets /. {opts} /. Options[ AddFrame ];\n\t\n\t\t",
 StyleBox["(* Now set up the transformation matrix between frames *)",
  FontWeight->"Plain",
  FontSlant->"Italic"],
 "\n\tTmtx[frme] = {\n\t {z21^2 (1-Cos[q[q2]-q20]) + Cos[q[q2]-q20],\n   z21 \
z22 (1-Cos[q[q2]-q20]) + z23 Sin[q[q2]-q20],\n   z21 z23 (1-Cos[q[q2]-q20]) - \
z22 Sin[q[q2]-q20]},\n  {z21 z22 (1-Cos[q[q2]-q20]) - z23 Sin[q[q2]-q20],\n   \
z22^2 (1-Cos[q[q2]-q20]) + Cos[q[q2]-q20],\n   z22 z23 (1-Cos[q[q2]-q20]) + \
z21 Sin[q[q2]-q20]},\n  {z21 z23 (1-Cos[q[q2]-q20]) + z22 Sin[q[q2]-q20],\n   \
z22 z23 (1-Cos[q[q2]-q20]) - z21 Sin[q[q2]-q20],\n   z23^2 (1-Cos[q[q2]-q20]) \
+ Cos[q[q2]-q20]}} .{\n\t\t{z11^2 (1-Cos[q[q1]-q10]) + Cos[q[q1]-q10],\n   \
z11 z12 (1-Cos[q[q1]-q10]) + z13 Sin[q[q1]-q10],\n   z11 z13 \
(1-Cos[q[q1]-q10]) - z12 Sin[q[q1]-q10]},\n  {z11 z12 (1-Cos[q[q1]-q10]) - \
z13 Sin[q[q1]-q10],\n   z12^2 (1-Cos[q[q1]-q10]) + Cos[q[q1]-q10],\n   z12 \
z13 (1-Cos[q[q1]-q10]) + z11 Sin[q[q1]-q10]},\n  {z11 z13 (1-Cos[q[q1]-q10]) \
+ z12 Sin[q[q1]-q10],\n   z12 z13 (1-Cos[q[q1]-q10]) - z11 Sin[q[q1]-q10],\n  \
 z13^2 (1-Cos[q[q1]-q10]) + Cos[q[q1]-q10]}};\n\t\n\t\t\
Evaluate[frme][n_?CoordQ] := PV[{1,frme,n}];\n\t\tParents[frme] = Append[ \
Parents[basefrm], frme];\n\t\tKids[frme] = {};\n\t\tKids[basefrm] = Append[ \
Kids[basefrm], frme];\n\t\tnewqdofs\n];"
}], "Input",
 InitializationCell->True,
 CellChangeTimes->{{3.5792075529921913`*^9, 3.579207632922174*^9}, 
   3.5792093120995893`*^9},
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"spell\"\>"}], ":", 
  " ", "\<\"Possible spelling error: new symbol name \
\\\"\\!\\(newqdofs\\)\\\" is similar to existing symbols \\!\\({newdofs, \
newqdof}\\). \\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", \
ButtonStyle->\\\"RefGuideLinkText\\\", ButtonFrame->None, \
ButtonData:>\\\"General::spell\\\"]\\)\"\>"}]], "Message"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["AddFrame for Ball joint", "Subsubsection",
 Evaluatable->False,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
AddFrame[frme_,basefrm_,Ball | SixDOF, opts___Rule ] := 
  Module[
\t{newqdofs, q1, q2, q3, q4},
\t
\tnewqdofs = {q1,q2,q3,q4} = ReplaceDofs[ 
\t\t{Qdof1,Qdof2,Qdof3,Qdof4} /.
\t\t{opts} /. Options[ AddFrame ], qdofs ];
\tqdofs = Union[ qdofs, newqdofs ];
\t
\tFrames = Union[ Append[Frames, frme] ];

    (* Now set up the transformation matrix between frames *)\t
\tTmtx[frme] = {
\t  {1 - 2 q[q2]^2 - 2 q[q3]^2,
\t   2 (q[q1] q[q2] + q[q3] q[q4]),
\t   2 (q[q3] q[q1] - q[q2] q[q4])},
\t  {2 (q[q1] q[q2] - q[q3] q[q4]),
\t   1 - 2 q[q3]^2 - 2 q[q1]^2,
\t   2 (q[q2] q[q3] + q[q1] q[q4])},
\t  {2 (q[q3] q[q1] + q[q2] q[q4]),
       2 (q[q2] q[q3] - q[q1] q[q4]),
\t   1 - 2 q[q1]^2 - 2 q[q2]^2}};
\t
\tEvaluate[frme][n_?CoordQ] := PV[{1,frme,n}];
\tParents[frme] = Append[ Parents[basefrm], frme];
\tKids[frme] = {};
\tKids[basefrm] = Append[ Kids[basefrm], frme];
\tnewqdofs
];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell["AddFrame for Gimbal joint", "Subsubsection",
 Evaluatable->False,
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[TextData[{
 "AddFrame[frme_,basefrm_,Gimbal, opts___Rule ] := Module[\n\t\t{z11, z12, \
z13, z21, z22, z23, z31, z32, z33,\n\t\t newqdofs, q1, q2, q3},\n\n\t\t\
{z11,z12,z13} = \n\t\t\t\tConvertList[Axis1, basefrm] /. {opts} /. Options[ \
AddFrame ];\n\t\t{z21,z22,z23} =\n\t  \tConvertList[Axis2, basefrm] /. {opts} \
/. Options[ AddFrame ];\n\t\t{z31,z32,z33} =\n\t\t\t\tConvertList[Axis3, \
basefrm] /. {opts} /. Options[ AddFrame ];\n\t\n\t\tnewqdofs = {q1, q2, q3} = \
ReplaceDofs[ {Qdof1, Qdof2,\n\t\t  Qdof3 } /.\t{opts} /. Options[ AddFrame ], \
qdofs ] ;\n\t\tqdofs = Union[ qdofs, newqdofs ];\n\t\n\t\tFrames = Union[ \
Append[Frames, frme] ];\n\t\n\t\t",
 StyleBox["(* Now set up the transformation matrix between frames *)",
  FontWeight->"Plain",
  FontSlant->"Italic"],
 "\n\tTmtx[frme] = {\n\t {z31^2 (1-Cos[q[q3]]) + Cos[q[q3]],\n   z31 z32 \
(1-Cos[q[q3]]) + z33 Sin[q[q3]],\n   z31 z33 (1-Cos[q[q3]]) - z32 \
Sin[q[q3]]},\n  {z31 z32 (1-Cos[q[q3]]) - z33 Sin[q[q3]],\n   z32^2 \
(1-Cos[q[q3]]) + Cos[q[q3]],\n   z32 z33 (1-Cos[q[q3]]) + z31 Sin[q[q3]]},\n  \
{z31 z33 (1-Cos[q[q3]]) + z32 Sin[q[q3]],\n   z32 z33 (1-Cos[q[q3]]) - z31 \
Sin[q[q3]],\n   z33^2 (1-Cos[q[q3]]) + Cos[q[q3]]}} . {\n  {z21^2 \
(1-Cos[q[q2]]) + Cos[q[q2]],\n   z21 z22 (1-Cos[q[q2]]) + z23 Sin[q[q2]],\n   \
z21 z23 (1-Cos[q[q2]]) - z22 Sin[q[q2]]},\n  {z21 z22 (1-Cos[q[q2]]) - z23 \
Sin[q[q2]],\n   z22^2 (1-Cos[q[q2]]) + Cos[q[q2]],\n   z22 z23 (1-Cos[q[q2]]) \
+ z21 Sin[q[q2]]},\n  {z21 z23 (1-Cos[q[q2]]) + z22 Sin[q[q2]],\n   z22 z23 \
(1-Cos[q[q2]]) - z21 Sin[q[q2]],\n   z23^2 (1-Cos[q[q2]]) + Cos[q[q2]]}} . {\n\
  {z11^2 (1-Cos[q[q1]]) + Cos[q[q1]],\n   z11 z12 (1-Cos[q[q1]]) + z13 \
Sin[q[q1]],\n   z11 z13 (1-Cos[q[q1]]) - z12 Sin[q[q1]]},\n  {z11 z12 \
(1-Cos[q[q1]]) - z13 Sin[q[q1]],\n   z12^2 (1-Cos[q[q1]]) + Cos[q[q1]],\n   \
z12 z13 (1-Cos[q[q1]]) + z11 Sin[q[q1]]},\n  {z11 z13 (1-Cos[q[q1]]) + z12 \
Sin[q[q1]],\n   z12 z13 (1-Cos[q[q1]]) - z11 Sin[q[q1]],\n   z13^2 \
(1-Cos[q[q1]]) + Cos[q[q1]]}};\n\t\n\t\tEvaluate[frme][n_?CoordQ] := \
PV[{1,frme,n}];\n\t\tParents[frme] = Append[ Parents[basefrm], frme];\n\t\t\
Kids[frme] = {};\n\t\tKids[basefrm] = Append[ Kids[basefrm], frme];\n\t\t\
newqdofs\n];"
}], "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{

Cell["AddBody", "Subsection",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["Options for AddBody", "Subsubsection",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["\<\
Options[ AddBody ] = {Axis->{0,0,1}, Qdof->Automatic,
  Udof->Automatic, Udof1->Automatic, Udof2->Automatic,
  Udof3->Automatic,Udof4->Automatic,Udof5->Automatic,
  Udof6->Automatic,
  Qdof1->Automatic, Qdof2->Automatic,Qdof3->Automatic,
  Qdof4->Automatic, Qdof5->Automatic, Qdof6->Automatic,
  Qdof7->Automatic,
  Axis1->{0,0,1}, Axis2->{0,1,0},Axis3->{0,0,1},
  Taxis->{1,0,0},
  TAxis1->{1,0,0},TAxis2->{0,1,0},TAxis3->{0,0,1},
\tBodyToJnt->0, InbToJnt->0, JntToJnt->0,Mass->0, Inertia->0,
\tFrme->Automatic, Basefrm->Automatic,
\tRelativeTo->Automatic};\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"spell\"\>"}], ":", 
  " ", "\<\"Possible spelling error: new symbol name \\\"\\!\\(Taxis\\)\\\" \
is similar to existing symbols \\!\\({axis, TAxis}\\). \
\\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", ButtonStyle->\\\"RefGuideLinkText\
\\\", ButtonFrame->None, ButtonData:>\\\"General::spell\\\"]\\)\"\>"}]], \
"Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"spell\"\>"}], ":", 
  " ", "\<\"Possible spelling error: new symbol name \\\"\\!\\(Frme\\)\\\" is \
similar to existing symbols \\!\\({Frame, frme}\\). \
\\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", ButtonStyle->\\\"RefGuideLinkText\
\\\", ButtonFrame->None, ButtonData:>\\\"General::spell\\\"]\\)\"\>"}]], \
"Message"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["AddBody for Hinge joint", "Subsubsection",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[TextData[{
 "AddBody[ body_, inboard_, Hinge, opts___Rule ] := Module[ \n\t\t{BtJ, ItJ, \
newqdof, newudof, frme,\n  \tbasefrm, axis},\n\n\t frme = Frme /. {opts} /. \
Options[ AddBody ];\n\t\tIf[ frme == Automatic, frme = body ];\t\n\t\tbasefrm \
= RelativeTo /. {opts} /. Options[ AddBody ];\n\t\tIf[ basefrm == Automatic, \
basefrm = inboard ];\n  {newqdof} = AddFrame[ frme, basefrm, Hinge, opts ];\n\
\t {newudof} = ReplaceDofs[{Udof} /. {opts} /.\n\t   Options[ AddBody ], \
udofs ];\n\t udofs = Union[ udofs, {newudof} ];\n\n\t\taxis = \
ConvertVec[Axis, basefrm] /. \n\t\t\t\t{opts} /. Options[ AddFrame ];\n\t\n ",
 StyleBox["\t(* Handle the bodies *)",
  FontWeight->"Plain",
  FontSlant->"Italic"],
 "\n\t\n \tAppendTo[ Bodies, body ];\n \tInboard[body] = inboard;\n \t{BtJ, \
ItJ, Mass[body], Inertia[body]} =\n\t\t\t\t{BodyToJnt, InbToJnt, Mass, \
ConvertInertia[Inertia,frme]} /.\n\t\t\t\t{opts} /. Options[ AddBody ];\n\t\t\
BodyToJnt[body] = BtJ;\n\t\tInbToJnt[body] = ItJ;\n\t\tJntToJnt[body] = 0;\n\t\
\n \tAppendTo[ Kinematics, u[newudof] == qt[newqdof]'[t] ];\n \tKinematics = \
Union[Kinematics];\n \tAngVel[ body ] = AngVel[ basefrm ] + \n \t  u[newudof] \
* axis;\n \tVelJnt[ body ] = VelCOM[ inboard ] +\n \t  Cross[ \
AngVel[inboard], ItJ ];\n \tVelCOM[ body ] = VelJnt[ body ] +\n \t  Cross[ \
AngVel[body], -BtJ ] //ZF;\n \tAngAcc[ body ] = Dt[ AngVel[body], t];\n \t\
AccJnt[ body ] = AccCOM[ inboard ] +\n \t  Cross[ AngVel[inboard], Cross[ \
AngVel[inboard], ItJ ] ] +\n \t  Cross[ AngAcc[inboard], ItJ ];\n \tAccCOM[ \
body ] = AccJnt[ body ] + \n \t  Cross[ AngVel[body], Cross[ AngVel[body], \
-BtJ ] ] +\n \t  Cross[ AngAcc[body], -BtJ ] //ZF;\n \tForce[ body ] = {};\n \
\tTorque[ body ] = {};\n \tDofs[ body ] = {{newqdof}, {newudof}}\n];"
}], "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell["AddBody for Fixed joint", "Subsubsection",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell[TextData[{
 "AddBody[ body_, inboard_, Fixed, opts___Rule ] := Module[ \n\t {BtJ, ItJ, \
frme,\n  \tbasefrm, taxis},\n\t\t\n\t\tfrme = Frme /. {opts} /. Options[ \
AddBody ];\n\t\tIf[ frme == Automatic, frme = body ];\t\n\t\tbasefrm = \
RelativeTo /. {opts} /. Options[ AddBody ];\n\t\tIf[ basefrm == Automatic, \
basefrm = inboard ];\n  AddFrame[ frme, basefrm, Fixed, opts ];\n\t\n ",
 StyleBox["\t(* Handle the bodies *)",
  FontWeight->"Plain",
  FontSlant->"Italic"],
 "\n\t\n \tAppendTo[ Bodies, body ];\n \tInboard[body] = inboard;\n  BtJ = \
BodyToJnt /. {opts} /. Options[ AddBody ];\n \tItJ = InbToJnt /. {opts} /. \
Options[ AddBody ];\n\t\tBodyToJnt[body] = BtJ;\n\t\tInbToJnt[body] = ItJ;\n\t\
\tJntToJnt[body] = 0;\n \tMass[body] = Mass /. {opts} /. Options[ AddBody ];\n\
 \tInertia[body] = ConvertInertia[Inertia,frme] /. {opts} /. Options[ AddBody \
];\n\t\n \tAngVel[ body ] = AngVel[ inboard ];\n \tVelJnt[ body ] = VelCOM[ \
inboard ] +\n \t  Cross[ AngVel[inboard], ItJ ];\n \tVelCOM[ body ] = VelJnt[ \
body ] +\n \t  Cross[ AngVel[body], -BtJ ] //ZF;\n \tAngAcc[ body ] = Dt[ \
AngVel[body], t];\n \tAccJnt[ body ] = AccCOM[ inboard ] +\n \t  Cross[ \
AngVel[inboard], Cross[ AngVel[inboard], ItJ ] ] +\n \t  Cross[ \
AngAcc[inboard], ItJ ];\n \tAccCOM[ body ] = AccJnt[ body ] + \n \t  Cross[ \
AngVel[body], Cross[ AngVel[body], -BtJ ] ] +\n \t  Cross[ AngAcc[body], -BtJ \
] //ZF;\n \tForce[ body ] = {};\n \tTorque[ body ] = {};\n \tDofs[ body ] = \
{{}, {}}\n];"
}], "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"spell\"\>"}], ":", 
  " ", "\<\"Possible spelling error: new symbol name \\\"\\!\\(taxis\\)\\\" \
is similar to existing symbols \\!\\({axis, Taxis}\\). \
\\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", ButtonStyle->\\\"RefGuideLinkText\
\\\", ButtonFrame->None, ButtonData:>\\\"General::spell\\\"]\\)\"\>"}]], \
"Message"]
}, Closed]]
}, Open  ]],

Cell[CellGroupData[{

Cell["AddBody for Slider joint", "Subsubsection",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[TextData[{
 "AddBody[ body_, inboard_, Slider, opts___Rule ] := Module[ \n\t {BtJ, ItJ, \
newqdof, newudof, frme,\n  \tbasefrm, taxis},\n\t\t\n\t\tfrme = Frme /. \
{opts} /. Options[ AddBody ];\n\t\tIf[ frme == Automatic, frme = body ];\t\n\t\
\tbasefrm = RelativeTo /. {opts} /. Options[ AddBody ];\n\t\tIf[ basefrm == \
Automatic, basefrm = inboard ];\n  {newqdof} = ReplaceDofs[{Qdof} /. {opts} \
/.\n  \t Options[ AddBody ], qdofs];\n  qdofs = Union[ qdofs, {newqdof} ];\n  \
AddFrame[ frme, basefrm, Fixed, opts ];\n\t {newudof} = ReplaceDofs[{Udof} /. \
\n\t \t\t{opts} /. Options[ AddBody ], udofs];\n\t udofs = Union[ udofs, \
{newudof} ];\n\t\n\t\ttaxis = ConvertVec[TAxis, basefrm] /. {opts} /.\n\t\t\t \
Options[ AddFrame ];\n\n ",
 StyleBox["\t(* Handle the bodies *)",
  FontWeight->"Plain",
  FontSlant->"Italic"],
 "\n\t\n \tAppendTo[ Bodies, body ];\n \tInboard[body] = inboard;\n  BtJ = \
BodyToJnt /. {opts} /. Options[ AddBody ];\n \tItJ = InbToJnt /. {opts} /. \
Options[ AddBody ];\n\t\tBodyToJnt[body] = BtJ;\n\t\tInbToJnt[body] = ItJ;\n\t\
\tJntToJnt[body] = q[newqdof] taxis;\n \tMass[body] = Mass /. {opts} /. \
Options[ AddBody ];\n \tInertia[body] = ConvertInertia[Inertia,frme] /. \
{opts} /. Options[ AddBody ];\n\t\n \tAppendTo[ Kinematics, u[newudof] == \
qt[newqdof]'[t] ];\n \tKinematics = Union[Kinematics];\n \tAngVel[ body ] = \
AngVel[ inboard ];\n \tVelJnt[ body ] = VelCOM[ inboard ] +\n \t  Cross[ \
AngVel[inboard], ItJ ];\n \t(*VelJnt2[ body ] = VelJnt[ body ] + Cross[ \
AngVel[ body ],\n \t  q[newqdof] taxis ] + u[newudof] taxis;\n \tVelCOM[ body \
] = VelJnt2[ body ] +\n \t  Cross[ AngVel[body], -BtJ ]//ZF;*)\n \tVelCOM[ \
body ] = VelJnt[ body ] + Cross[ AngVel[body], q[newqdof] taxis - BtJ ] + \
u[newudof] taxis //ZF;\n \tAngAcc[ body ] = Dt[ AngVel[body], t];\n \tAccJnt[ \
body ] = AccCOM[ inboard ] +\n \t  Cross[ AngVel[inboard], Cross[ \
AngVel[inboard], ItJ ] ] +\n \t  Cross[ AngAcc[inboard], ItJ ];\n \t\
(*AccJnt2[ body ] = AccJnt[ body] +\n \t\t Cross[ AngVel[inboard], Cross[ \
AngVel[inboard], \n \t\t   q[newqdof] taxis ] ] +\n \t\t Cross[ \
AngAcc[inboard], q[newqdof] taxis ] + u[newudof]' taxis + \n \t\t 2 Cross[ \
AngVel[body], u[newudof] taxis ];\n \tAccCOM[ body ] = AccJnt2[ body ] + \n \t\
  Cross[ AngVel[body], Cross[ AngVel[body], -BtJ ] ] +\n \t  Cross[ \
AngAcc[body], -BtJ ]//ZF;*)\n \tAccCOM[ body ] = AccJnt[ body ] + Cross[ \
AngVel[body], Cross[ AngVel[body], q[newqdof] taxis - BtJ ] ] + Cross[ \
AngAcc[body], q[newqdof] taxis - BtJ ] + u[newudof]' taxis + 2 Cross[ \
AngVel[body], u[newudof] taxis ] //ZF;\n \tForce[ body ] = {};\n \tTorque[ \
body ] = {};\n \tDofs[ body ] = {{newqdof}, {newudof}}\n];"
}], "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell["AddBody for UJoint", "Subsubsection",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell[TextData[{
 "AddBody[ body_, inboard_, UJoint, opts___Rule ] := Module[ \n\t {BtJ, ItJ, \
newqdofs, newudofs, q1, q2, u1, u2, frme,\n   basefrm, axis1, axis2},\n  \t   \
  \t \n \tfrme = Frme /. {opts} /. Options[ AddBody ];\n \tIf[ frme == \
Automatic, frme = body ];\t\n \tbasefrm = RelativeTo /. {opts} /. Options[ \
AddBody ];\n \tIf[ basefrm == Automatic, basefrm = inboard ];\n  newqdofs = \
{q1, q2} = AddFrame[ frme, basefrm, UJoint, opts ];\n  newudofs = {u1, u2} = \
ReplaceDofs[{Udof1, Udof2} /. \n  \t\t{opts} /. Options[ AddBody ], udofs];\n \
 udofs = Union[ udofs, newudofs ];\n\t\n\t\taxis1 = ConvertVec[Axis1, \
basefrm] /. {opts} /.\n\t\t\t\tOptions[ AddFrame ];\n\t\taxis2 = \
ConvertVec[Axis2, frme] /. {opts} /.\n\t\t  Options[ AddFrame ];\n\t  \n \t",
 StyleBox["(* Handle the bodies *)",
  FontWeight->"Plain",
  FontSlant->"Italic"],
 "\n\t\n \tAppendTo[ Bodies, body ];\n \tInboard[body] = inboard;\n  BtJ = \
BodyToJnt /. {opts} /. Options[ AddBody ];\n \tItJ = InbToJnt /. {opts} /. \
Options[ AddBody ];\n\t\tBodyToJnt[body] = BtJ;\n\t\tInbToJnt[body] = ItJ;\n\t\
\tJntToJnt[body] = 0;\n \tMass[body] = Mass /. {opts} /. Options[ AddBody ];\n\
 \tInertia[body] = ConvertInertia[Inertia,frme] /. {opts} /. Options[ AddBody \
];\n\t\n \tAppendTo[ Kinematics, u[u1] == qt[q1]'[t] ];\n \tAppendTo[ \
Kinematics, u[u2] == qt[q2]'[t] ];\n \tKinematics = Union[Kinematics];\n \t\
AngVel[ body ] = AngVel[ inboard ] + \n \t  u[u1] axis1 +\n \t  u[u2] axis2;\n\
 \tVelJnt[ body ] = VelCOM[ inboard ] +\n \t  Cross[ AngVel[inboard], ItJ ];\n\
 \tVelCOM[ body ] = VelJnt[ body ] +\n \t  Cross[ AngVel[body], -BtJ ]//ZF;\n \
\tAngAcc[ body ] = Dt[ AngVel[body], t];\n \tAccJnt[ body ] = AccCOM[ inboard \
] +\n \t  Cross[ AngVel[inboard], Cross[ AngVel[inboard], ItJ ] ] +\n \t  \
Cross[ AngAcc[inboard], ItJ ];\n \tAccCOM[ body ] = AccJnt[ body ] + \n \t  \
Cross[ AngVel[body], Cross[ AngVel[body], -BtJ ] ] +\n \t  Cross[ \
AngAcc[body], -BtJ ]//ZF;\n \tForce[ body ] = {};\n \tTorque[ body ] = {};\n \
\tDofs[ body ] = {newqdofs, newudofs}\n];"
}], "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"spell\"\>"}], ":", 
  " ", "\<\"Possible spelling error: new symbol name \
\\\"\\!\\(newudofs\\)\\\" is similar to existing symbols \\!\\({newdofs, \
newqdofs, newudof}\\). \\!\\(\\*ButtonBox[\\\"More\[Ellipsis]\\\", \
ButtonStyle->\\\"RefGuideLinkText\\\", ButtonFrame->None, \
ButtonData:>\\\"General::spell\\\"]\\)\"\>"}]], "Message"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["AddBody for Gimbal joint", "Subsubsection",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
AddBody[ body_, inboard_, Gimbal, opts___Rule ] := Module[ 
\t {BtJ, ItJ, newqdofs, newudofs, q1, q2, q3, u1, u2, u3,
\t  frme, basefrm, axis1, axis2, axis3},
  \t     \t 
 \tfrme = Frme /. {opts} /. Options[ AddBody ];
 \tIf[ frme == Automatic, frme = body ];\t
 \tbasefrm = RelativeTo /. {opts} /. Options[ AddBody ];
 \tIf[ basefrm == Automatic, basefrm = inboard ];
  newqdofs = {q1, q2, q3} = 
  \tAddFrame[ frme, basefrm, Gimbal, opts ];
  newudofs = {u1, u2, u3} = 
  \tReplaceDofs[{Udof1, Udof2, Udof3} /. 
  \t{opts} /. Options[ AddBody ], udofs];
  udofs = Union[ udofs, newudofs ];
\t
\taxis1 = ConvertVec[Axis1, basefrm] /. {opts} /.
\t\tOptions[ AddFrame ];
\taxis2 = ConvertVec[Axis2, basefrm] /. {opts} /.
\t\tOptions[ AddFrame ];
\taxis3 = ConvertVec[Axis3, basefrm] /. {opts} /.
\t\tOptions[ AddFrame ];
\t  
 \t(* Handle the bodies *)
\t
 \tAppendTo[ Bodies, body ];
 \tInboard[body] = inboard;
  BtJ = BodyToJnt /. {opts} /. Options[ AddBody ];
 \tItJ = InbToJnt /. {opts} /. Options[ AddBody ];
\t\tBodyToJnt[body] = BtJ;
\t\tInbToJnt[body] = ItJ;
\t\tJntToJnt[body] = 0;
 \tMass[body] = Mass /. {opts} /. Options[ AddBody ];
 \tInertia[body] = ConvertInertia[Inertia,frme] /. {opts} /. Options[ AddBody \
];
\t
 \tAppendTo[ Kinematics, u[u1] == qt[q1]'[t] ];
 \tAppendTo[ Kinematics, u[u2] == qt[q2]'[t] ];
 \tAppendTo[ Kinematics, u[u3] == qt[q3]'[t] ];
 \tKinematics = Union[Kinematics];
 \tAngVel[ body ] = AngVel[ inboard ] + 
 \t  u[u1] axis1 +
 \t  u[u2] axis2 + u[u3] axis3;
 \tVelJnt[ body ] = VelCOM[ inboard ] +
 \t  Cross[ AngVel[inboard], ItJ ];
 \tVelCOM[ body ] = VelJnt[ body ] +
 \t  Cross[ AngVel[body], -BtJ ]//ZF;
 \tAngAcc[ body ] = Dt[ AngVel[body], t];
 \tAccJnt[ body ] = AccCOM[ inboard ] +
 \t  Cross[ AngVel[inboard], Cross[ AngVel[inboard], ItJ ] ] +
 \t  Cross[ AngAcc[inboard], ItJ ];
 \tAccCOM[ body ] = AccJnt[ body ] + 
 \t  Cross[ AngVel[body], Cross[ AngVel[body], -BtJ ] ] +
 \t  Cross[ AngAcc[body], -BtJ ]//ZF;
 \tForce[ body ] = {};
 \tTorque[ body ] = {};
 \tDofs[ body ] = {newqdofs, newudofs}
];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell["AddBody for Ball Joint", "Subsubsection",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
AddBody[ body_, inboard_, Ball, opts___Rule ] := Module[ 
\t{BtJ, ItJ, q1, q2, q3, q4, u1, u2, u3, frme,
  \tbasefrm, newqdofs, newudofs,Euler},
  \t 
\tfrme = Frme /. {opts} /. Options[ AddBody ];
\tIf[ frme == Automatic, frme = body ];\t
\tbasefrm = RelativeTo /. {opts} /. Options[ AddBody ];
\tIf[ basefrm == Automatic, basefrm = inboard ];
  newqdofs = {q1,q2,q3,q4} = 
  \tAddFrame[ frme, basefrm, Ball, opts ];
  newudofs = {u1, u2, u3} = ReplaceDofs[
  \t{Udof1, Udof2, Udof3} /.
  \t{opts} /. Options[ AddBody ], udofs];
\tudofs = Union[ udofs, newudofs ];
\t
 \t(* Handle the bodies *)
\t
 \tAppendTo[ Bodies, body ];
 \tInboard[body] = inboard;
  BtJ = BodyToJnt /. {opts} /. Options[ AddBody ];
 \tItJ = InbToJnt /. {opts} /. Options[ AddBody ];
\t\tBodyToJnt[body] = BtJ;
\t\tInbToJnt[body] = ItJ;
\t\tJntToJnt[body] = 0;
 \tMass[body] = Mass /. {opts} /. Options[ AddBody ];
 \tInertia[body] = ConvertInertia[Inertia,frme] /. {opts} /. Options[ AddBody \
];
\t
\tEuler = {{ q[q4], -q[q3],  q[q2]},
\t\t   { q[q3],  q[q4], -q[q1]},
\t\t   {-q[q2],  q[q1],  q[q4]},
\t\t   {-q[q1], -q[q2], -q[q3]}};
\t\t   
 \tAppendTo[ Kinematics,Thread[ 
 \t\t{qt[q1]'[t], qt[q2]'[t], qt[q3]'[t], qt[q4]'[t]} ==
 \t\t1/2 Euler . {u[u1], u[u2], u[u3]},List] ];
 \tKinematics = Union[Flatten[Kinematics]];
 \tAngVel[ body ] = AngVel[ inboard ] + 
 \t\tPV[{u[u1],frme,1},{u[u2],frme,2},
 \t\t{u[u3],frme,3}];
 \tVelJnt[ body ] = VelCOM[ inboard ] +
 \t  Cross[ AngVel[inboard], ItJ ];
 \tVelCOM[ body ] = VelJnt[ body ] +
 \t  Cross[ AngVel[body], -BtJ ]//ZF;
 \tAngAcc[ body ] = Dt[ AngVel[body], t];
 \tAccJnt[ body ] = AccCOM[ inboard ] +
 \t  Cross[ AngVel[inboard], Cross[ AngVel[inboard], ItJ ] ] +
 \t  Cross[ AngAcc[inboard], ItJ ];
 \tAccCOM[ body ] = AccJnt[ body ] + 
 \t  Cross[ AngVel[body], Cross[ AngVel[body], -BtJ ] ] +
 \t  Cross[ AngAcc[body], -BtJ ]//ZF;
 \tForce[ body ] = {};
 \tTorque[ body ] = {};
 \tDofs[ body ] = {newqdofs, newudofs}
];
\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]],

Cell[CellGroupData[{

Cell["AddBody for SixDOF Joint", "Subsubsection",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
AddBody[ body_, inboard_, SixDOF, opts___Rule ] := Module[ 
\t{BtJ, ItJ, q1, q2, q3, q4, q5, q6, q7,
\t u1, u2, u3, u4, u5, u6, frme,
  \tbasefrm, newqdofs, newudofs, taxis1, taxis2, taxis3, Euler},

\tnewqdofs = {q1,q2,q3,q4,q5,q6,q7} = ReplaceDofs[
\t\t{Qdof1,Qdof2,Qdof3,Qdof4,Qdof5,Qdof6,Qdof7}
\t\t/. {opts} /. Options[ AddBody ], qdofs];
\t\t
\tIf[ Length[#] > 0, Message[AddBody::repeatDOF, #] ] & [
  \tIntersection[newqdofs, qdofs] ];

\tqdofs = Union[ qdofs, newqdofs ]; \t
    \t 
\tfrme = Frme /. {opts} /. Options[ AddBody ];
\tIf[ frme == Automatic, frme = body ];\t
\tbasefrm = RelativeTo /. {opts} /. Options[ AddBody ];
\tIf[ basefrm == Automatic, basefrm = inboard ];
  AddFrame[ frme, basefrm, Ball, Qdof1->q4,
  \tQdof2->q5, Qdof3->q6, Qdof4->q7, opts ];
  \t
  {taxis1, taxis2, taxis3} = ConvertVec[#,basefrm]& /@
  \t{TAxis1, TAxis2, TAxis3} /.
  \t{opts} /. Options[ AddBody ];
  \t
  newudofs = {u1, u2, u3, u4, u5, u6} = ReplaceDofs[
    {Udof1, Udof2, Udof3, Udof4, Udof5, Udof6} /.
  \t{opts} /. Options[ AddBody ], udofs];
  udofs = Union[ udofs, newudofs ];

 \t(* Handle the bodies *)
\t
 \tAppendTo[ Bodies, body ];
 \tInboard[body] = inboard;
  BtJ = BodyToJnt /. {opts} /. Options[ AddBody ];
 \tItJ = InbToJnt /. {opts} /. Options[ AddBody ];
\tBodyToJnt[body] = BtJ;
\tInbToJnt[body] = ItJ;
\tJntToJnt[body] = 0;
 \tMass[body] = Mass /. {opts} /. Options[ AddBody ];
 \tInertia[body] = ConvertInertia[Inertia,frme] /. {opts} /. Options[ AddBody \
];
\t
\tEuler = {{ q[q7], -q[q6],  q[q5]},
\t\t   { q[q6],  q[q7], -q[q4]},
\t\t   {-q[q5],  q[q4],  q[q7]},
\t\t   {-q[q4], -q[q5], -q[q6]}};
\t\t   
 \tAppendTo[ Kinematics, 
 \t\t{qt[q4]'[t], qt[q5]'[t], qt[q6]'[t], qt[q7]'[t]} ==
 \t\t1/2 Euler . {u[u4], u[u5], u[u6]} ];
 \tKinematics = Union[Kinematics];
 \tAngVel[ body ] = AngVel[ inboard ] + 
 \t\tPV[{u[u4],frme,1},{u[u5],frme,2},
 \t\t{u[u6],frme,3}];
 \tVelJnt[ body ] = VelCOM[ inboard ] +
 \t  Cross[ AngVel[inboard], ItJ ];
 \tVelJnt2[ body ] = VelJnt[ body ] + Cross[ AngVel[ inboard ],
 \t  q[q1] taxis1 + q[q2] taxis2 + q[q3] taxis3 ] +
 \t  u[u1] taxis1 + u[u2] taxis2 + u[u3] taxis3;
 \tVelCOM[ body ] = VelJnt2[ body ] +
 \t  Cross[ AngVel[body], -BtJ ]//ZF;
 \tAngAcc[ body ] = Dt[ AngVel[body], t];
 \tAccJnt[ body ] = AccCOM[ inboard ] +
 \t  Cross[ AngVel[inboard], Cross[ AngVel[inboard], ItJ ] ] +
 \t  Cross[ AngAcc[inboard], ItJ ];
 \tAccJnt2[ body ] = AccJnt[ body] +
 \t\tCross[ AngVel[inboard], Cross[ AngVel[inboard], 
      q[q1] taxis1 + q[q2] taxis2 + q[q3] taxis3 ] ] +
 \t\tCross[ AngAcc[inboard], 
 \t\t\tq[q1] taxis1 + q[q2] taxis2 + q[q3] taxis3 ] +
 \t \tu[u1]' taxis1 + u[u2]' taxis2 + u[u3]' taxis3 +
 \t\t2 Cross[ AngVel[inboard], 
 \t\t   u[u1] taxis1 + u[u2] taxis2 + u[u3] taxis3 ];
 \tAccCOM[ body ] = AccJnt2[ body ] + 
 \t  Cross[ AngVel[body], Cross[ AngVel[body], -BtJ ] ] +
 \t  Cross[ AngAcc[body], -BtJ ]//ZF;
 \tForce[ body ] = {};
 \tTorque[ body ] = {};
 \tDofs[ body ] = {newqdofs, newudofs}
];
\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True]
}, Closed]]
}, Closed]]
}, Open  ]],

Cell["\<\
CloseLoop[ body_, inboard_, Hinge, opts___Rule ] := Module[ 
\t\t{BtJ, ItJ, axis, velloopjnt1, velloopjnt2,
\t\tjoint, vector1, vector2, angvel, constraints},

\taxis = ConvertVec[Axis, body] /. 
\t\t{opts} /. Options[ AddFrame ];
\t
 \t{BtJ, ItJ} = {BodyToJnt, InbToJnt} /.
\t\t{opts} /. Options[ AddBody ];

\tLoop[body] = {inboard, BtJ, ItJ};
\t
\tvelloopjnt1 = VelCOM[ body ] +
\t\tCross[ AngVel[body], BtJ];
\tvelloopjnt2 = VelCOM[ inboard ] +
\t\tCross[ AngVel[inboard], ItJ];
\tjoint = velloopjnt1 - velloopjnt2;
\tangvel = AngVel[body] - AngVel[inboard];
\t{vector1,vector2} = If[ PrincipalAxisQ[
\t\tConvertList[axis,ground] ],\t
\t\tConvertVec[ 
\t\t\tNullSpace[ {ConvertList[axis,ground]} ], ground],
\t\tConvertVec[
\t\t\tNullSpace[ {ConvertList[axis,c]} ] ], ground];\t
\tconstraints = Map[ # == 0 &, Select[ {
\t\tjoint . axis,
\t\tjoint . vector1,
\t\tjoint . vector2,
\t\tangvel . vector1,
\t\tangvel . vector2 }, # =!= 0 & ] ] /. 
\t\tJoin[replacesin,replacecos,replace2SC,replaceSC2,
\t\t\treplaceUs];
\t\t
\tNonholonomic = Join[ Nonholonomic, constraints ];
\t\t
  (* Return the number of constraints introduced *)
  Length[ constraints ]
];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["\<\
CloseLoop[ body_, inboard_, Fixed, opts___Rule ] := Module[ 
\t\t{BtJ, ItJ, axis, velloopjnt1, velloopjnt2,
\t\tjoint, vector1, vector2, angvel, constraints},

\taxis = ConvertVec[Axis, body] /. 
\t\t{opts} /. Options[ AddFrame ];
\t
 \t{BtJ, ItJ} = {BodyToJnt, InbToJnt} /.
\t\t{opts} /. Options[ AddBody ];

\tLoop[body] = {inboard, BtJ, ItJ};
\t
\tvelloopjnt1 = VelCOM[ body ] +
\t\tCross[ AngVel[body], BtJ];
\tvelloopjnt2 = VelCOM[ inboard ] +
\t\tCross[ AngVel[inboard], ItJ];
\tjoint = velloopjnt1 - velloopjnt2;
\tangvel = AngVel[body] - AngVel[inboard];
\t{vector1,vector2} = If[ PrincipalAxisQ[
\t\tConvertList[axis,inboard] ],\t
\t\tNullSpace[ {ConvertList[axis,inboard]} ],
\t\tNullSpace[ {ConvertList[axis,body]} ] ];
\tvector1 = ConvertVec[ vector1, body ];
\tvector2 = ConvertVec[ vector2, body ];
\t
\tconstraints = Map[ # == 0 &, Select[ {
\t\tjoint . vector1,
\t\tjoint . vector2,
\t\tjoint . vector3,
\t\tangvel . vector1,
\t\tangvel . vector2,
\t\tangvel . vector3}, # =!= 0 & ] ];
\t\t
\tNonholonomic = Join[ Nonholonomic, constraints ];
\t\t
  (* Return the number of constraints introduced *)
  Length[ constraints ]
];\
\>", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell["End[ ];", "Input",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["EndPackage[ ];", "Input",
 InitializationCell->True,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["And here's the playground", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["NewModel", "Input",
 AspectRatioFixed->True],

Cell[BoxData["NewModel"], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell["AddFrame[a, ground, Hinge, Axis->{0,0,1}, Qdof->1];", "Input",
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(2\\) in \\!\\(\\(\
\\({1}\\)\\) \[Union] qdofs\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Set", "::", "\<\"shape\"\>"}], ":", 
  " ", "\<\"Lists \\!\\({newqdof$10}\\) and \\!\\(replDofs[\\(\\(\\(\\({1}\\)\
\\), \\(\\({}\\)\\), \\(\\(PickDof[\\(\\(\\(\\(\\(\\({1}\\)\\) \[Union] qdofs\
\\)\\), 0\\)\\)]\\)\\)\\)\\)]\\) are not the same shape.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(qdofs \[Union] \\(\\({newqdof$10}\\)\\)\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\($RecursionLimit :: \\\"reclim\\\"\\) will \
be suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\($RecursionLimit :: \\\"reclim\\\"\\) will \
be suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"-- Message text not found -- (\\!\\(List\\)) (\\!\\(Hold\\)) (\\!\
\\(2\\)) (\\!\\(1\\))\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"-- Message text not found -- (\\!\\(List\\)) (\\!\\(Hold\\)) (\\!\
\\(2\\)) (\\!\\(1\\))\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"-- Message text not found -- (\\!\\(List\\)) (\\!\\(Hold\\)) (\\!\
\\(2\\)) (\\!\\(1\\))\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Union :: \\\"heads\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(Frames, a\\)\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, Frames\\)\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\($RecursionLimit :: \\\"reclim\\\"\\) will \
be suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Hold[\
\\(\\(Append[\\(\\(a, Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\
\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \
\\(\\(Append[\\(\\(a, \\(\\(Hold[\\(\\(Append[\\(\\(a, \
Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\).\"\
\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \
\\(\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Hold[\\(\\(Append[\\(\\(a, \
Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\
\\)\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Append :: \\\"normal\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"]
}, Open  ]],

Cell[CellGroupData[{

Cell["AddFrame[a, ground, Hinge, Axis->3]", "Input",
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\($RecursionLimit :: \\\"reclim\\\"\\) will \
be suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\($RecursionLimit :: \\\"reclim\\\"\\) will \
be suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Union :: \\\"heads\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Set", "::", "\<\"shape\"\>"}], ":", 
  " ", "\<\"Lists \\!\\({newqdof$11}\\) and \
\\!\\(replDofs[\\(\\(\\(\\({Automatic}\\)\\), \\(\\({1}\\)\\), \\(\\(PickDof[\
\\(\\(\\(\\(\[LeftSkeleton] 1 \[RightSkeleton]\\)\\), \
1\\)\\)]\\)\\)\\)\\)]\\) are not the same shape.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\($RecursionLimit :: \\\"reclim\\\"\\) will \
be suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Union :: \\\"heads\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"$RecursionLimit", "::", "\<\"reclim\"\>"}], ":", 
  " ", "\<\"Recursion depth of \\!\\(256\\) exceeded.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\($RecursionLimit :: \\\"reclim\\\"\\) will \
be suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Hold[\
\\(\\(Append[\\(\\(a, Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\
\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \
\\(\\(Append[\\(\\(a, \\(\\(Hold[\\(\\(Append[\\(\\(a, \
Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\).\"\
\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \
\\(\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Hold[\\(\\(Append[\\(\\(a, \
Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\
\\)\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Append :: \\\"normal\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(3\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{"{", "newqdof$11", "}"}]], "Output"]
}, Open  ]],

Cell[CellGroupData[{

Cell["AddFrame[b, a, Hinge, Axis->{0,0,1}, Qdof->2];", "Input",
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(Hold\\) and \\!\\(List\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Set", "::", "\<\"shape\"\>"}], ":", 
  " ", "\<\"Lists \\!\\({newqdof$12}\\) and \\!\\(replDofs[\\(\\(\\(\\({2}\\)\
\\), \\(\\({}\\)\\), \\(\\(PickDof[\\(\\(\\(\\(\[LeftSkeleton] 1 \
\[RightSkeleton]\\)\\), 0\\)\\)]\\)\\)\\)\\)]\\) are not the same \
shape.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Union :: \\\"heads\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Hold[\\(\\(Append[\\(\\(a, \
Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Hold[\\(\\(Append[\\(\\(a, \
Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Hold[\
\\(\\(Append[\\(\\(a, Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\
\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Append :: \\\"normal\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(3\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(3\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(3\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Append :: \\\"argrx\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"]
}, Open  ]],

Cell["AddFrame[c, ground, Hinge, {0,0,1}];", "Input",
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["AddFrame[d, c, Hinge, Axis->{0,0,1}];", "Input",
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(Hold\\) and \\!\\(List\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Set", "::", "\<\"shape\"\>"}], ":", 
  " ", "\<\"Lists \\!\\({newqdof$13}\\) and \
\\!\\(replDofs[\\(\\(\\(\\({Automatic}\\)\\), \\(\\({1}\\)\\), \\(\\(PickDof[\
\\(\\(\\(\\(\[LeftSkeleton] 1 \[RightSkeleton]\\)\\), \
1\\)\\)]\\)\\)\\)\\)]\\) are not the same shape.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Union :: \\\"heads\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(3\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(4\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(4\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Append :: \\\"argrx\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Hold[\\(\\(Append[\\(\\(a, \
Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Hold[\\(\\(Append[\\(\\(a, \
Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Hold[\
\\(\\(Append[\\(\\(a, Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\
\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Append :: \\\"normal\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"]
}, Open  ]],

Cell[CellGroupData[{

Cell["AddFrame[e, d, Hinge, Axis->{0,0,1}];", "Input",
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(Hold\\) and \\!\\(List\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Set", "::", "\<\"shape\"\>"}], ":", 
  " ", "\<\"Lists \\!\\({newqdof$14}\\) and \
\\!\\(replDofs[\\(\\(\\(\\({Automatic}\\)\\), \\(\\({1}\\)\\), \\(\\(PickDof[\
\\(\\(\\(\\(\[LeftSkeleton] 1 \[RightSkeleton]\\)\\), \
1\\)\\)]\\)\\)\\)\\)]\\) are not the same shape.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Union :: \\\"heads\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(4\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(5\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(5\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Append :: \\\"argrx\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Hold[\\(\\(Append[\\(\\(a, \
Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Hold[\\(\\(Append[\\(\\(a, \
Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Hold[\
\\(\\(Append[\\(\\(a, Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\
\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Append :: \\\"normal\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"]
}, Open  ]],

Cell[CellGroupData[{

Cell["AddFrame[f, b, Hinge, Axis->3];", "Input",
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(Hold\\) and \\!\\(List\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Set", "::", "\<\"shape\"\>"}], ":", 
  " ", "\<\"Lists \\!\\({newqdof$15}\\) and \
\\!\\(replDofs[\\(\\(\\(\\({Automatic}\\)\\), \\(\\({1}\\)\\), \\(\\(PickDof[\
\\(\\(\\(\\(\[LeftSkeleton] 1 \[RightSkeleton]\\)\\), \
1\\)\\)]\\)\\)\\)\\)]\\) are not the same shape.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Union :: \\\"heads\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(5\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(6\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(6\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Append :: \\\"argrx\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Hold[\\(\\(Append[\\(\\(a, \
Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Hold[\\(\\(Append[\\(\\(a, \
Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Hold[\
\\(\\(Append[\\(\\(a, Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\
\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Append :: \\\"normal\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"]
}, Open  ]],

Cell[CellGroupData[{

Cell["AddFrame[g, f, Hinge, Axis->3];", "Input",
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(Hold\\) and \\!\\(List\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Set", "::", "\<\"shape\"\>"}], ":", 
  " ", "\<\"Lists \\!\\({newqdof$16}\\) and \
\\!\\(replDofs[\\(\\(\\(\\({Automatic}\\)\\), \\(\\({1}\\)\\), \\(\\(PickDof[\
\\(\\(\\(\\(\[LeftSkeleton] 1 \[RightSkeleton]\\)\\), \
1\\)\\)]\\)\\)\\)\\)]\\) are not the same shape.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Union", "::", "\<\"heads\"\>"}], ":", 
  " ", "\<\"Heads \\!\\(List\\) and \\!\\(Hold\\) at positions \\!\\(2\\) and \
\\!\\(1\\) are expected to be the same.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Union :: \\\"heads\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(6\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(7\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"argrx\"\>"}], ":", 
  " ", "\<\"\\!\\(Append\\) called with \\!\\(7\\) arguments; \\!\\(2\\) \
arguments are expected.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Append :: \\\"argrx\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Hold[\\(\\(Append[\\(\\(a, \
Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Hold[\\(\\(Append[\\(\\(a, \
Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"Append", "::", "\<\"normal\"\>"}], ":", 
  " ", "\<\"Nonatomic expression expected at position \\!\\(1\\) in \
\\!\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Append[\\(\\(a, \\(\\(Hold[\
\\(\\(Append[\\(\\(a, Frames\\)\\)]\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\\)]\\)\\)\\)\
\\)]\\).\"\>"}]], "Message"],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"stop\"\>"}], ":", 
  " ", "\<\"Further output of \\!\\(Append :: \\\"normal\\\"\\) will be \
suppressed during this calculation.\"\>"}]], "Message"]
}, Open  ]],

Cell[CellGroupData[{

Cell["?Parents", "Input",
 AspectRatioFixed->True],

Cell[BoxData["\<\"Parents[frame] returns a list of reference frames above the \
argument's entry in the frame tree.\"\>"], "Print",
 CellTags->"Info3288294292-7563725"]
}, Open  ]],

Cell[CellGroupData[{

Cell["?Kids", "Input",
 AspectRatioFixed->True],

Cell[BoxData["\<\"Kids[frame] returns a list of reference frames below the \
argument's entry in the frame tree.\"\>"], "Print",
 CellTags->"Info3288294294-3664163"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Cross[ a[3] + 2b[3], 3c[2]+3d[1] ]", "Input",
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"(", 
   RowBox[{
    SubscriptBox[
     UnderscriptBox["a", "_"], "3"], "+", 
    TagBox[
     RowBox[{"2", " ", 
      SubscriptBox[
       UnderscriptBox["b", "_"], "3"]}],
     HoldForm]}], ")"}], "\[Cross]", 
  RowBox[{"(", 
   RowBox[{
    RowBox[{"3", " ", 
     RowBox[{"c", "[", "2", "]"}]}], "+", 
    TagBox[
     RowBox[{"3", " ", 
      SubscriptBox[
       UnderscriptBox["d", "_"], "1"]}],
     HoldForm]}], ")"}]}]], "Output"]
}, Open  ]]
}, Closed]],

Cell[CellGroupData[{

Cell["Transformation Matrix", "Section",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[TextData[{
 "Here's how the transformation matrices work:\n",
 StyleBox["Tmtx",
  FontSlant->"Plain"],
 " is the matrix that puts a vector in a frame's Parent coordinates into the \
frame's coordinates.  For example, for a frame ",
 StyleBox["a",
  FontSlant->"Plain"],
 " attached to ",
 StyleBox["ground",
  FontSlant->"Plain"],
 ", ",
 StyleBox["Tmtx . ground[1] = # a[1] + ... or Transpose[Tmtx] . a[1] = # \
ground[1] + ...\n\n",
  FontSlant->"Plain"],
 "The way we do it is to perform a coordinate transformation that makes the 3 \
axis point in the direction of the hinge axis.  Then we do an arbitrary \
coordinate transform about 3, and then transform back into the real world. ",
 StyleBox[" \n\n",
  FontSlant->"Plain"],
 "What was the hinge becomes 3: if axis is ",
 StyleBox["{z1,z2,z3}",
  FontSlant->"Plain"],
 " then ",
 StyleBox["{{x1,x2,x3},{y1,y2,y3},{z1,z2,z3}} . axis == {0,0,1}.\n\n",
  FontSlant->"Plain"],
 "Then we do the standard 3 axis coordinate transform ",
 StyleBox["{{Cos[q],Sin[q],0},{-Sin[q],Cos[q],0},{0,0,1}}\n\n",
  FontSlant->"Plain"],
 "Now what was 3 axis becomes hinge: ",
 StyleBox["{{x1,y1,z1},{x2,y2,z2},{x3,y3,z3}} . {0,0,1} == {z1,z2,z3}",
  FontSlant->"Plain"],
 "\n"
}], "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["\<\
GTmtx = Expand[{{x1,y1,z1},{x2,y2,z2},{x3,y3,z3}}.
 {{Cos[q],Sin[q],0},{-Sin[q],Cos[q],0},{0,0,1}}.
 {{x1,x2,x3},{y1,y2,y3},{z1,z2,z3}}]\
\>", "Input",
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{
      SuperscriptBox["z1", "2"], "+", 
      RowBox[{
       SuperscriptBox["x1", "2"], " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "+", 
      RowBox[{
       SuperscriptBox["y1", "2"], " ", 
       RowBox[{"Cos", "[", "q", "]"}]}]}], ",", 
     RowBox[{
      RowBox[{"z1", " ", "z2"}], "+", 
      RowBox[{"x1", " ", "x2", " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "+", 
      RowBox[{"y1", " ", "y2", " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "-", 
      RowBox[{"x2", " ", "y1", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}], "+", 
      RowBox[{"x1", " ", "y2", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}]}], ",", 
     RowBox[{
      RowBox[{"z1", " ", "z3"}], "+", 
      RowBox[{"x1", " ", "x3", " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "+", 
      RowBox[{"y1", " ", "y3", " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "-", 
      RowBox[{"x3", " ", "y1", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}], "+", 
      RowBox[{"x1", " ", "y3", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}]}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{
      RowBox[{"z1", " ", "z2"}], "+", 
      RowBox[{"x1", " ", "x2", " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "+", 
      RowBox[{"y1", " ", "y2", " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "+", 
      RowBox[{"x2", " ", "y1", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}], "-", 
      RowBox[{"x1", " ", "y2", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}]}], ",", 
     RowBox[{
      SuperscriptBox["z2", "2"], "+", 
      RowBox[{
       SuperscriptBox["x2", "2"], " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "+", 
      RowBox[{
       SuperscriptBox["y2", "2"], " ", 
       RowBox[{"Cos", "[", "q", "]"}]}]}], ",", 
     RowBox[{
      RowBox[{"z2", " ", "z3"}], "+", 
      RowBox[{"x2", " ", "x3", " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "+", 
      RowBox[{"y2", " ", "y3", " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "-", 
      RowBox[{"x3", " ", "y2", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}], "+", 
      RowBox[{"x2", " ", "y3", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}]}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{
      RowBox[{"z1", " ", "z3"}], "+", 
      RowBox[{"x1", " ", "x3", " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "+", 
      RowBox[{"y1", " ", "y3", " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "+", 
      RowBox[{"x3", " ", "y1", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}], "-", 
      RowBox[{"x1", " ", "y3", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}]}], ",", 
     RowBox[{
      RowBox[{"z2", " ", "z3"}], "+", 
      RowBox[{"x2", " ", "x3", " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "+", 
      RowBox[{"y2", " ", "y3", " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "+", 
      RowBox[{"x3", " ", "y2", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}], "-", 
      RowBox[{"x2", " ", "y3", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}]}], ",", 
     RowBox[{
      SuperscriptBox["z3", "2"], "+", 
      RowBox[{
       SuperscriptBox["x3", "2"], " ", 
       RowBox[{"Cos", "[", "q", "]"}]}], "+", 
      RowBox[{
       SuperscriptBox["y3", "2"], " ", 
       RowBox[{"Cos", "[", "q", "]"}]}]}]}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell["\<\
We have unknowns in the other 2 axes of our hinge axis world: we only know 3 \
is the hinge direction, but don't know where 1 and 2 are pointed. Luckily, we \
know a few things.
1. It's an orthonormal matrix, so rows and columns dotted against each other \
give 0.
2. Cross products: 1 x 2 = 3, 2 x 3 = 1, 3 x 1 = 2.
3. Norm of rows and columns is 1.\
\>", "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell["\<\
ar1 = AlgebraicRules[ {
  x1 x2 + y1 y2 + z1 z2 == 0,
  x1 x3 + y1 y3 + z1 z3 == 0,
  x2 x3 + y2 y3 + z2 z3 == 0},
     {x1,x2,x3,y1,y2,y3,z1,z2,z3,Cos[q],Sin[q]} ];\
\>", "Input",
 AspectRatioFixed->True],

Cell["\<\
ar2 = AlgebraicRules[ {
  x2 y3 - x3 y2 == z1,
  x3 y1 - x1 y3 == z2,
  x1 y2 - x2 y1 == z3},
  {x1,x2,x3,y1,y2,y3,z1,z2,z3,Cos[q],Sin[q]} ];\
\>", "Input",
 AspectRatioFixed->True],

Cell["\<\
 ar3 = AlgebraicRules[ {
  x1^2 + y1^2 + z1^2 == 1,
  x2^2 + y2^2 + z2^2 == 1,
  x3^2 + y3^2 + z3^2 == 1},
  {x1,x2,x3,y1,y2,y3,z1,z2,z3,Cos[q],Sin[q]} ];
\
\>", "Input",
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["Collect[ GTmtx /. ar1 /. ar2 /. ar3, {z1,z2,z3} ]", "Input",
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{
      RowBox[{
       SuperscriptBox["z1", "2"], " ", 
       RowBox[{"(", 
        RowBox[{"1", "-", 
         RowBox[{"Cos", "[", "q", "]"}]}], ")"}]}], "+", 
      RowBox[{"Cos", "[", "q", "]"}]}], ",", 
     RowBox[{
      RowBox[{"z1", " ", "z2", " ", 
       RowBox[{"(", 
        RowBox[{"1", "-", 
         RowBox[{"Cos", "[", "q", "]"}]}], ")"}]}], "+", 
      RowBox[{"z3", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}]}], ",", 
     RowBox[{
      RowBox[{"z1", " ", "z3", " ", 
       RowBox[{"(", 
        RowBox[{"1", "-", 
         RowBox[{"Cos", "[", "q", "]"}]}], ")"}]}], "-", 
      RowBox[{"z2", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}]}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{
      RowBox[{"z1", " ", "z2", " ", 
       RowBox[{"(", 
        RowBox[{"1", "-", 
         RowBox[{"Cos", "[", "q", "]"}]}], ")"}]}], "-", 
      RowBox[{"z3", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}]}], ",", 
     RowBox[{
      RowBox[{
       SuperscriptBox["z2", "2"], " ", 
       RowBox[{"(", 
        RowBox[{"1", "-", 
         RowBox[{"Cos", "[", "q", "]"}]}], ")"}]}], "+", 
      RowBox[{"Cos", "[", "q", "]"}]}], ",", 
     RowBox[{
      RowBox[{"z2", " ", "z3", " ", 
       RowBox[{"(", 
        RowBox[{"1", "-", 
         RowBox[{"Cos", "[", "q", "]"}]}], ")"}]}], "+", 
      RowBox[{"z1", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}]}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{
      RowBox[{"z1", " ", "z3", " ", 
       RowBox[{"(", 
        RowBox[{"1", "-", 
         RowBox[{"Cos", "[", "q", "]"}]}], ")"}]}], "+", 
      RowBox[{"z2", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}]}], ",", 
     RowBox[{
      RowBox[{"z2", " ", "z3", " ", 
       RowBox[{"(", 
        RowBox[{"1", "-", 
         RowBox[{"Cos", "[", "q", "]"}]}], ")"}]}], "-", 
      RowBox[{"z1", " ", 
       RowBox[{"Sin", "[", "q", "]"}]}]}], ",", 
     RowBox[{
      RowBox[{
       SuperscriptBox["z3", "2"], " ", 
       RowBox[{"(", 
        RowBox[{"1", "-", 
         RowBox[{"Cos", "[", "q", "]"}]}], ")"}]}], "+", 
      RowBox[{"Cos", "[", "q", "]"}]}]}], "}"}]}], "}"}]], "Output"]
}, Open  ]],

Cell["\<\
And by the way, here's the old, uncool way I did this: you could specify the \
1, 2, or 3 axis, and it would make a transformation matrix. Problem is, it \
can't do rotations about arbitrary axes.\
\>", "Special1",
 Evaluatable->False,
 AspectRatioFixed->True],

Cell[CellGroupData[{

Cell["\<\
AddFrame[frme_,basefrm_,Hinge,coord_?CoordQ,dof_Integer:0 ] :=
\tModule[{newdof = If[ dof != 0, dof, PickDof[dofs] ], mtx},
\tdofs = Union[ Append[dofs, newdof] ];
\tFrames = Union[ Append[Frames, frme] ];
\t
\t(* Now set up the transformation matrix between frames *)
\tmtx = IdentityMatrix[ 3 ];
\tmtx = ReplacePart[mtx, 1, {Mod3[coord],Mod3[coord]}];
\tmtx = ReplacePart[mtx, Cos[q[newdof]],
  \t{{Mod3[coord+1],Mod3[coord+1]},
  \t {Mod3[coord+2],Mod3[coord+2]}}];
\tmtx = ReplacePart[mtx, -Sin[q[newdof]],
  \t{Mod3[coord+2],Mod3[coord+1]}];
\tmtx = ReplacePart[mtx, Sin[q[newdof]],
  \t{Mod3[coord+1],Mod3[coord+2]}];
\tTmtx[frme] = mtx;
\tEvaluate[frme][n_?CoordQ] := PV[{1,frme,n}];
\tParents[frme] = Append[ Parents[basefrm], frme];
\tKids[frme] = {};
\tKids[basefrm] = Append[ Kids[basefrm], frme];
\tnewdof
];\
\>", "Input",
 AspectRatioFixed->True],

Cell[BoxData[
 RowBox[{
  RowBox[{"General", "::", "\<\"spell\"\>"}], ":", 
  " ", "\<\"Possible spelling error: new symbol name \\\"\\!\\(newdof\\)\\\" \
is similar to existing symbols \\!\\({newdofs, newqdof, newudof}\\).\"\>"}]], \
"Message"]
}, Open  ]]
}, Closed]]
}, Open  ]]
}, Open  ]]
}, Open  ]]
},
AutoGeneratedPackage->Automatic,
WindowToolbars->{},
CellGrouping->Manual,
WindowSize->{1584, 765},
WindowMargins->{{0, Automatic}, {Automatic, 0}},
PrivateNotebookOptions->{"ColorPalette"->{RGBColor, 128}},
ShowCellLabel->True,
ShowCellTags->False,
RenderingOptions->{"ObjectDithering"->True,
"RasterDithering"->False},
CharacterEncoding->"MacintoshAutomaticEncoding",
FrontEndVersion->"9.0 for Microsoft Windows (64-bit) (November 20, 2012)",
StyleDefinitions->"Default.nb"
]
(* End of Notebook Content *)

(* Internal cache information *)
(*CellTagsOutline
CellTagsIndex->{
 "Info3288294292-7563725"->{
  Cell[214323, 6350, 168, 2, 25, "Print",
   CellTags->"Info3288294292-7563725"]},
 "Info3288294294-3664163"->{
  Cell[214578, 6360, 165, 2, 25, "Print",
   CellTags->"Info3288294294-3664163"]}
 }
*)
(*CellTagsIndex
CellTagsIndex->{
 {"Info3288294292-7563725", 225760, 6726},
 {"Info3288294294-3664163", 225872, 6729}
 }
*)
(*NotebookFileOutline
Notebook[{
Cell[545, 20, 89, 2, 31, "Input",
 InitializationCell->True],
Cell[637, 24, 249, 6, 31, "Input",
 InitializationCell->True],
Cell[889, 32, 2567, 71, 212, "Input"],
Cell[CellGroupData[{
Cell[3481, 107, 69, 2, 79, "Section",
 Evaluatable->False],
Cell[3553, 111, 255, 6, 65, "Input",
 InitializationCell->True],
Cell[3811, 119, 259, 7, 65, "Input",
 InitializationCell->True],
Cell[4073, 128, 308, 7, 82, "Input",
 InitializationCell->True],
Cell[4384, 137, 337, 8, 116, "Input",
 InitializationCell->True],
Cell[4724, 147, 660, 12, 218, "Input",
 InitializationCell->True],
Cell[5387, 161, 205, 6, 48, "Input",
 InitializationCell->True],
Cell[5595, 169, 497, 8, 31, "Input",
 InitializationCell->True],
Cell[6095, 179, 283, 7, 82, "Input",
 InitializationCell->True],
Cell[6381, 188, 252, 6, 65, "Input",
 InitializationCell->True],
Cell[6636, 196, 235, 6, 65, "Input",
 InitializationCell->True],
Cell[6874, 204, 129, 2, 31, "Input",
 InitializationCell->True],
Cell[7006, 208, 385, 8, 116, "Input",
 InitializationCell->True],
Cell[7394, 218, 569, 10, 184, "Input",
 InitializationCell->True],
Cell[7966, 230, 176, 5, 48, "Input",
 InitializationCell->True],
Cell[8145, 237, 236, 6, 65, "Input",
 InitializationCell->True],
Cell[8384, 245, 210, 6, 65, "Input",
 InitializationCell->True],
Cell[8597, 253, 171, 5, 48, "Input",
 InitializationCell->True],
Cell[8771, 260, 354, 8, 99, "Input",
 InitializationCell->True],
Cell[9128, 270, 400, 8, 116, "Input",
 InitializationCell->True],
Cell[9531, 280, 187, 6, 65, "Input",
 InitializationCell->True],
Cell[9721, 288, 866, 16, 303, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[10612, 308, 214, 6, 65, "Input",
 InitializationCell->True],
Cell[10829, 316, 373, 7, 22, "Message"]
}, Open  ]],
Cell[11217, 326, 204, 6, 65, "Input",
 InitializationCell->True],
Cell[11424, 334, 152, 5, 48, "Input",
 InitializationCell->True],
Cell[11579, 341, 284, 6, 31, "Input",
 InitializationCell->True],
Cell[11866, 349, 403, 8, 116, "Input",
 InitializationCell->True],
Cell[12272, 359, 542, 10, 184, "Input",
 InitializationCell->True],
Cell[12817, 371, 183, 6, 48, "Input",
 InitializationCell->True],
Cell[13003, 379, 188, 6, 48, "Input",
 InitializationCell->True],
Cell[13194, 387, 469, 9, 150, "Input",
 InitializationCell->True],
Cell[13666, 398, 712, 12, 235, "Input",
 InitializationCell->True],
Cell[14381, 412, 444, 10, 133, "Input",
 InitializationCell->True],
Cell[14828, 424, 220, 6, 65, "Input",
 InitializationCell->True],
Cell[15051, 432, 548, 10, 167, "Input",
 InitializationCell->True],
Cell[15602, 444, 247, 6, 65, "Input",
 InitializationCell->True],
Cell[15852, 452, 192, 6, 48, "Input",
 InitializationCell->True],
Cell[16047, 460, 171, 5, 48, "Input",
 InitializationCell->True],
Cell[16221, 467, 277, 7, 82, "Input",
 InitializationCell->True],
Cell[16501, 476, 274, 7, 82, "Input",
 InitializationCell->True],
Cell[16778, 485, 214, 6, 65, "Input",
 InitializationCell->True],
Cell[16995, 493, 193, 6, 48, "Input",
 InitializationCell->True],
Cell[17191, 501, 224, 5, 65, "Input",
 InitializationCell->True],
Cell[17418, 508, 147, 3, 31, "Input",
 InitializationCell->True],
Cell[17568, 513, 175, 4, 31, "Input",
 InitializationCell->True],
Cell[17746, 519, 419, 9, 82, "Input",
 InitializationCell->True],
Cell[18168, 530, 360, 8, 116, "Input",
 InitializationCell->True],
Cell[18531, 540, 479, 9, 150, "Input",
 InitializationCell->True],
Cell[19013, 551, 220, 6, 65, "Input",
 InitializationCell->True],
Cell[19236, 559, 371, 8, 116, "Input",
 InitializationCell->True],
Cell[19610, 569, 236, 6, 65, "Input",
 InitializationCell->True],
Cell[19849, 577, 222, 6, 65, "Input",
 InitializationCell->True],
Cell[20074, 585, 414, 9, 133, "Input",
 InitializationCell->True],
Cell[20491, 596, 155, 3, 48, "Input",
 InitializationCell->True],
Cell[20649, 601, 188, 6, 48, "Input",
 InitializationCell->True],
Cell[20840, 609, 236, 6, 31, "Input",
 InitializationCell->True],
Cell[21079, 617, 319, 7, 99, "Input",
 InitializationCell->True],
Cell[21401, 626, 166, 5, 48, "Input",
 InitializationCell->True],
Cell[21570, 633, 178, 5, 48, "Input",
 InitializationCell->True],
Cell[21751, 640, 151, 5, 48, "Input",
 InitializationCell->True],
Cell[21905, 647, 794, 14, 252, "Input",
 InitializationCell->True],
Cell[22702, 663, 569, 11, 167, "Input",
 InitializationCell->True],
Cell[23274, 676, 325, 7, 99, "Input",
 InitializationCell->True],
Cell[23602, 685, 170, 5, 48, "Input",
 InitializationCell->True],
Cell[23775, 692, 71, 1, 31, "Input",
 InitializationCell->True],
Cell[23849, 695, 398, 8, 133, "Input",
 InitializationCell->True],
Cell[24250, 705, 380, 8, 116, "Input",
 InitializationCell->True],
Cell[24633, 715, 186, 6, 48, "Input",
 InitializationCell->True],
Cell[24822, 723, 151, 5, 48, "Input",
 InitializationCell->True],
Cell[24976, 730, 150, 3, 48, "Input",
 InitializationCell->True],
Cell[25129, 735, 183, 6, 48, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[25337, 745, 231, 6, 31, "Input",
 InitializationCell->True],
Cell[25571, 753, 374, 6, 22, "Message"]
}, Open  ]],
Cell[25960, 762, 564, 11, 167, "Input",
 InitializationCell->True],
Cell[26527, 775, 373, 8, 116, "Input",
 InitializationCell->True],
Cell[26903, 785, 259, 7, 65, "Input",
 InitializationCell->True],
Cell[27165, 794, 303, 7, 82, "Input",
 InitializationCell->True],
Cell[27471, 803, 340, 8, 99, "Input",
 InitializationCell->True],
Cell[27814, 813, 316, 8, 116, "Input",
 InitializationCell->True],
Cell[28133, 823, 535, 12, 212, "Input",
 InitializationCell->True],
Cell[28671, 837, 609, 12, 92, "Input",
 InitializationCell->True],
Cell[29283, 851, 337, 8, 52, "Input",
 InitializationCell->True],
Cell[29623, 861, 210, 5, 52, "Input",
 InitializationCell->True],
Cell[29836, 868, 758, 13, 112, "Input",
 InitializationCell->True],
Cell[30597, 883, 1553, 25, 212, "Input",
 InitializationCell->True],
Cell[32153, 910, 774, 16, 132, "Input",
 InitializationCell->True],
Cell[32930, 928, 612, 11, 92, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[33557, 942, 220, 7, 82, "Input",
 InitializationCell->True],
Cell[33780, 951, 84, 2, 31, "Input",
 Evaluatable->False],
Cell[CellGroupData[{
Cell[33889, 957, 89, 2, 79, "Section",
 Evaluatable->False],
Cell[33981, 961, 218, 7, 25, "Special1",
 Evaluatable->False],
Cell[34202, 970, 139, 4, 30, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[34366, 978, 204, 7, 25, "Special1",
 Evaluatable->False],
Cell[34573, 987, 242, 9, 120, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[34852, 1001, 493, 21, 25, "Special1",
 Evaluatable->False],
Cell[35348, 1024, 236, 9, 120, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[35621, 1038, 493, 21, 25, "Special1",
 Evaluatable->False],
Cell[36117, 1061, 234, 9, 120, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[36388, 1075, 370, 15, 25, "Special1",
 Evaluatable->False],
Cell[36761, 1092, 116, 5, 48, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[36914, 1102, 181, 7, 25, "Special1",
 Evaluatable->False],
Cell[37098, 1111, 107, 2, 30, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[37242, 1118, 190, 7, 25, "Special1",
 Evaluatable->False],
Cell[37435, 1127, 116, 2, 30, "Input",
 InitializationCell->True],
Cell[37554, 1131, 111, 2, 30, "Input",
 InitializationCell->True],
Cell[37668, 1135, 199, 5, 48, "Input",
 InitializationCell->True],
Cell[37870, 1142, 106, 2, 30, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[38013, 1149, 194, 7, 25, "Special1",
 Evaluatable->False],
Cell[38210, 1158, 126, 2, 30, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[38351, 1163, 200, 7, 25, "Special1",
 Evaluatable->False],
Cell[38554, 1172, 115, 2, 30, "Input",
 InitializationCell->True],
Cell[38672, 1176, 254, 8, 25, "Special1",
 Evaluatable->False],
Cell[38929, 1186, 145, 5, 48, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[39099, 1195, 296, 11, 42, "Special1",
 Evaluatable->False],
Cell[39398, 1208, 157, 5, 48, "Input",
 InitializationCell->True],
Cell[39558, 1215, 166, 5, 48, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[39761, 1225, 255, 8, 42, "Special1",
 Evaluatable->False],
Cell[40019, 1235, 417, 11, 156, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[40473, 1251, 257, 8, 42, "Special1",
 Evaluatable->False],
Cell[40733, 1261, 328, 10, 138, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[41098, 1276, 367, 9, 42, "Special1",
 Evaluatable->False],
Cell[41468, 1287, 345, 8, 84, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[41850, 1300, 270, 8, 25, "Special1",
 Evaluatable->False],
Cell[42123, 1310, 430, 10, 138, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[42590, 1325, 275, 9, 25, "Special1",
 Evaluatable->False],
Cell[42868, 1336, 252, 7, 84, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[43157, 1348, 285, 8, 25, "Special1",
 Evaluatable->False],
Cell[43445, 1358, 280, 7, 84, "Input",
 InitializationCell->True],
Cell[43728, 1367, 108, 2, 30, "Input",
 InitializationCell->True],
Cell[43839, 1371, 161, 5, 48, "Input",
 InitializationCell->True],
Cell[44003, 1378, 210, 6, 66, "Input",
 InitializationCell->True],
Cell[44216, 1386, 219, 6, 66, "Input",
 InitializationCell->True],
Cell[44438, 1394, 219, 6, 66, "Input",
 InitializationCell->True],
Cell[44660, 1402, 177, 5, 48, "Input",
 InitializationCell->True],
Cell[44840, 1409, 118, 2, 30, "Input",
 InitializationCell->True],
Cell[44961, 1413, 119, 2, 30, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[45117, 1420, 187, 7, 25, "Special1",
 Evaluatable->False],
Cell[45307, 1429, 150, 5, 48, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[45494, 1439, 202, 7, 25, "Special1",
 Evaluatable->False],
Cell[45699, 1448, 146, 5, 48, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[45882, 1458, 112, 4, 33, "Text"],
Cell[45997, 1464, 85, 1, 30, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[46119, 1470, 143, 4, 33, "Text"],
Cell[46265, 1476, 161, 5, 66, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[46463, 1486, 92, 2, 29, "Subsubsection",
 Evaluatable->False],
Cell[46558, 1490, 310, 10, 70, "Input"],
Cell[46871, 1502, 116, 2, 70, "Input",
 Evaluatable->False],
Cell[46990, 1506, 117, 2, 70, "Input",
 Evaluatable->False],
Cell[47110, 1510, 117, 2, 70, "Input",
 Evaluatable->False]
}, Closed]],
Cell[CellGroupData[{
Cell[47264, 1517, 110, 4, 30, "Text"],
Cell[47377, 1523, 94, 1, 30, "Input",
 InitializationCell->True]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[47520, 1530, 72, 2, 49, "Section",
 Evaluatable->False],
Cell[47595, 1534, 176, 7, 25, "Special1",
 Evaluatable->False],
Cell[47774, 1543, 735, 20, 318, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[48534, 1567, 273, 8, 25, "Special1",
 Evaluatable->False],
Cell[48810, 1577, 474, 14, 210, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[49321, 1596, 240, 8, 25, "Special1",
 Evaluatable->False],
Cell[CellGroupData[{
Cell[49586, 1608, 102, 2, 30, "Input",
 InitializationCell->True],
Cell[49691, 1612, 384, 7, 22, "Message"]
}, Open  ]],
Cell[50090, 1622, 188, 6, 66, "Input",
 InitializationCell->True],
Cell[50281, 1630, 98, 2, 30, "Input",
 InitializationCell->True]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[50428, 1638, 94, 2, 49, "Section",
 Evaluatable->False],
Cell[50525, 1642, 458, 15, 42, "Special1",
 Evaluatable->False],
Cell[50986, 1659, 383, 14, 210, "Input",
 InitializationCell->True],
Cell[51372, 1675, 498, 15, 42, "Special1",
 Evaluatable->False],
Cell[51873, 1692, 251, 8, 102, "Input",
 InitializationCell->True],
Cell[52127, 1702, 220, 6, 66, "Input",
 InitializationCell->True],
Cell[52350, 1710, 210, 5, 33, "Text"],
Cell[52563, 1717, 911, 29, 50, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[53511, 1751, 77, 2, 49, "Section",
 Evaluatable->False],
Cell[CellGroupData[{
Cell[53613, 1757, 76, 0, 47, "Subsection"],
Cell[53692, 1759, 135, 3, 33, "Text"],
Cell[53830, 1764, 409, 13, 50, "Input",
 Evaluatable->False],
Cell[54242, 1779, 60, 0, 33, "Text"],
Cell[54305, 1781, 719, 23, 30, "Input",
 Evaluatable->False],
Cell[55027, 1806, 825, 26, 50, "Input",
 Evaluatable->False],
Cell[55855, 1834, 53, 0, 33, "Text"],
Cell[55911, 1836, 1012, 32, 50, "Input",
 Evaluatable->False],
Cell[56926, 1870, 97, 2, 33, "Text"],
Cell[57026, 1874, 143, 4, 30, "Input",
 Evaluatable->False,
 InitializationCell->True],
Cell[57172, 1880, 109, 3, 33, "Text"],
Cell[57284, 1885, 141, 4, 30, "Input",
 Evaluatable->False,
 InitializationCell->True]
}, Closed]],
Cell[57440, 1892, 464, 16, 25, "Special1",
 Evaluatable->False],
Cell[57907, 1910, 56, 0, 47, "Subsection"],
Cell[57966, 1912, 889, 28, 30, "Input",
 InitializationCell->True],
Cell[58858, 1942, 183, 6, 66, "Input",
 InitializationCell->True],
Cell[59044, 1950, 53, 0, 47, "Subsection"],
Cell[59100, 1952, 136, 6, 66, "Input",
 InitializationCell->True],
Cell[59239, 1960, 230, 6, 66, "Input",
 InitializationCell->True],
Cell[59472, 1968, 139, 5, 48, "Input",
 InitializationCell->True],
Cell[59614, 1975, 164, 5, 48, "Input",
 InitializationCell->True],
Cell[59781, 1982, 285, 7, 84, "Input",
 InitializationCell->True],
Cell[60069, 1991, 224, 6, 66, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[60330, 2002, 79, 2, 49, "Section",
 Evaluatable->False],
Cell[60412, 2006, 598, 19, 42, "Special1",
 Evaluatable->False],
Cell[61013, 2027, 429, 15, 228, "Input",
 InitializationCell->True],
Cell[61445, 2044, 292, 9, 120, "Input",
 InitializationCell->True],
Cell[61740, 2055, 179, 5, 48, "Input",
 InitializationCell->True],
Cell[61922, 2062, 138, 5, 48, "Input",
 InitializationCell->True],
Cell[62063, 2069, 92, 2, 30, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[62192, 2076, 72, 2, 49, "Section",
 Evaluatable->False],
Cell[62267, 2080, 451, 16, 70, "Special1",
 Evaluatable->False],
Cell[62721, 2098, 329, 11, 70, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[63087, 2114, 99, 2, 49, "Section",
 Evaluatable->False],
Cell[63189, 2118, 141, 6, 84, "Input"],
Cell[63333, 2126, 464, 17, 264, "Input",
 InitializationCell->True],
Cell[63800, 2145, 499, 15, 228, "Input",
 InitializationCell->True],
Cell[64302, 2162, 141, 6, 66, "Input",
 InitializationCell->True],
Cell[64446, 2170, 654, 16, 246, "Input",
 InitializationCell->True],
Cell[65103, 2188, 194, 8, 102, "Input",
 InitializationCell->True],
Cell[65300, 2198, 190, 7, 84, "Input",
 InitializationCell->True],
Cell[65493, 2207, 226, 7, 84, "Input",
 InitializationCell->True],
Cell[65722, 2216, 106, 2, 30, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[65865, 2223, 84, 2, 49, "Section",
 Evaluatable->False],
Cell[65952, 2227, 195, 5, 48, "Input",
 InitializationCell->True],
Cell[66150, 2234, 161, 5, 65, "Input",
 InitializationCell->True],
Cell[66314, 2241, 147, 3, 31, "Input",
 InitializationCell->True],
Cell[66464, 2246, 160, 5, 65, "Input",
 InitializationCell->True]
}, Closed]],
Cell[66639, 2254, 38, 0, 49, "Section"],
Cell[66680, 2256, 974, 25, 46, "Input"],
Cell[CellGroupData[{
Cell[67679, 2285, 90, 2, 79, "Section",
 Evaluatable->False],
Cell[67772, 2289, 1502, 49, 110, "Special1",
 Evaluatable->False],
Cell[69277, 2340, 99, 2, 30, "Input",
 InitializationCell->True],
Cell[69379, 2344, 406, 10, 138, "Input",
 InitializationCell->True],
Cell[69788, 2356, 365, 10, 138, "Input",
 InitializationCell->True],
Cell[70156, 2368, 285, 8, 102, "Input",
 InitializationCell->True],
Cell[70444, 2378, 295, 8, 102, "Input",
 InitializationCell->True],
Cell[70742, 2388, 175, 5, 48, "Input",
 InitializationCell->True],
Cell[70920, 2395, 263, 7, 84, "Input",
 InitializationCell->True],
Cell[71186, 2404, 285, 8, 102, "Input",
 InitializationCell->True],
Cell[71474, 2414, 77, 1, 30, "Input"],
Cell[71554, 2417, 30, 0, 30, "Input"],
Cell[71587, 2419, 276, 8, 102, "Input",
 Evaluatable->False],
Cell[71866, 2429, 167, 6, 66, "Input",
 Evaluatable->False],
Cell[72036, 2437, 145, 5, 48, "Input",
 Evaluatable->False]
}, Closed]],
Cell[CellGroupData[{
Cell[72218, 2447, 81, 2, 49, "Section",
 Evaluatable->False],
Cell[72302, 2451, 497, 15, 218, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[72836, 2471, 34, 0, 79, "Section"],
Cell[72873, 2473, 160, 4, 48, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[73070, 2482, 83, 2, 49, "Section",
 Evaluatable->False],
Cell[73156, 2486, 195, 5, 25, "Special1",
 Evaluatable->False],
Cell[73354, 2493, 228, 7, 84, "Input",
 InitializationCell->True],
Cell[73585, 2502, 175, 5, 48, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[73797, 2512, 90, 2, 49, "Section",
 Evaluatable->False],
Cell[73890, 2516, 707, 16, 246, "Input",
 InitializationCell->True],
Cell[74600, 2534, 275, 9, 120, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[74912, 2548, 91, 2, 49, "Section",
 Evaluatable->False],
Cell[75006, 2552, 332, 7, 30, "Input"],
Cell[CellGroupData[{
Cell[75363, 2563, 2367, 56, 966, "Input",
 InitializationCell->True],
Cell[77733, 2621, 394, 7, 70, "Message"],
Cell[78130, 2630, 387, 7, 70, "Message"]
}, Open  ]],
Cell[78532, 2640, 293, 8, 102, "Input",
 InitializationCell->True],
Cell[78828, 2650, 160, 5, 48, "Input",
 InitializationCell->True],
Cell[78991, 2657, 169, 7, 84, "Input",
 InitializationCell->True],
Cell[79163, 2666, 189, 6, 66, "Input",
 InitializationCell->True],
Cell[79355, 2674, 202, 6, 66, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[79594, 2685, 23, 0, 49, "Section"],
Cell[79620, 2687, 118, 3, 70, "Input"],
Cell[79741, 2692, 185, 6, 70, "Input",
 InitializationCell->True],
Cell[79929, 2700, 255, 8, 70, "Input",
 InitializationCell->True],
Cell[80187, 2710, 837, 27, 70, "Input",
 InitializationCell->True],
Cell[81027, 2739, 981, 29, 70, "Input",
 InitializationCell->True],
Cell[82011, 2770, 981, 29, 70, "Input",
 InitializationCell->True],
Cell[82995, 2801, 906, 28, 70, "Input",
 InitializationCell->True],
Cell[83904, 2831, 553, 17, 70, "Input",
 InitializationCell->True],
Cell[84460, 2850, 792, 25, 70, "Input",
 InitializationCell->True],
Cell[85255, 2877, 527, 17, 70, "Input",
 InitializationCell->True],
Cell[85785, 2896, 268, 9, 70, "Input",
 InitializationCell->True],
Cell[86056, 2907, 838, 26, 70, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[86931, 2938, 84, 2, 49, "Section",
 Evaluatable->False],
Cell[87018, 2942, 78, 1, 31, "Input",
 InitializationCell->True],
Cell[87099, 2945, 434, 14, 201, "Input",
 InitializationCell->True],
Cell[87536, 2961, 191, 5, 23, "Special1",
 Evaluatable->False],
Cell[87730, 2968, 227, 8, 99, "Input",
 InitializationCell->True],
Cell[87960, 2978, 268, 8, 23, "Special1",
 Evaluatable->False],
Cell[88231, 2988, 157, 5, 48, "Input",
 InitializationCell->True],
Cell[88391, 2995, 209, 7, 23, "Special1",
 Evaluatable->False],
Cell[88603, 3004, 100, 2, 31, "Input",
 InitializationCell->True],
Cell[88706, 3008, 477, 13, 23, "Special1",
 Evaluatable->False],
Cell[89186, 3023, 199, 6, 65, "Input",
 InitializationCell->True],
Cell[89388, 3031, 204, 7, 23, "Special1",
 Evaluatable->False],
Cell[89595, 3040, 324, 8, 99, "Input",
 InitializationCell->True],
Cell[89922, 3050, 219, 7, 23, "Special1",
 Evaluatable->False],
Cell[CellGroupData[{
Cell[90166, 3061, 353, 13, 184, "Input",
 InitializationCell->True],
Cell[90522, 3076, 374, 6, 22, "Message"]
}, Open  ]]
}, Closed]],
Cell[90923, 3086, 28, 0, 49, "Section"],
Cell[90954, 3088, 211, 5, 25, "Input",
 InitializationCell->True],
Cell[91168, 3095, 110, 3, 30, "Text"],
Cell[CellGroupData[{
Cell[91303, 3102, 14827, 374, 637, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[106155, 3480, 1584, 45, 52, "Input",
 InitializationCell->True],
Cell[107742, 3527, 375, 6, 22, "Message"]
}, Open  ]],
Cell[108132, 3536, 214, 6, 30, "Text"],
Cell[108349, 3544, 78, 1, 31, "Input",
 InitializationCell->True],
Cell[108430, 3547, 657, 11, 68, "Text"],
Cell[CellGroupData[{
Cell[109112, 3562, 17213, 453, 912, "Input",
 InitializationCell->True],
Cell[126328, 4017, 454, 7, 49, "Text"],
Cell[126785, 4026, 4969, 125, 332, "Input",
 InitializationCell->True],
Cell[131757, 4153, 424, 8, 49, "Text"],
Cell[CellGroupData[{
Cell[132206, 4165, 2286, 69, 172, "Input",
 InitializationCell->True],
Cell[134495, 4236, 1280, 19, 125, "Text"],
Cell[135778, 4257, 326, 9, 31, "Input",
 InitializationCell->True],
Cell[136107, 4268, 16302, 388, 1052, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[152434, 4660, 81, 2, 79, "Section",
 Evaluatable->False],
Cell[CellGroupData[{
Cell[152540, 4666, 76, 2, 43, "Subsection",
 Evaluatable->False],
Cell[152619, 4670, 233, 8, 23, "Special1",
 Evaluatable->False],
Cell[152855, 4680, 1553, 45, 728, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[154445, 4730, 76, 2, 43, "Subsection",
 Evaluatable->False],
Cell[CellGroupData[{
Cell[154546, 4736, 91, 2, 34, "Subsubsection",
 Evaluatable->False],
Cell[154640, 4740, 324, 8, 99, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[155001, 4753, 122, 3, 34, "Subsubsection",
 Evaluatable->False,
 InitializationCell->True],
Cell[155126, 4758, 1363, 23, 559, "Input",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[156526, 4786, 129, 3, 34, "Subsubsection",
 Evaluatable->False,
 InitializationCell->True],
Cell[156658, 4791, 729, 16, 264, "Input",
 InitializationCell->True],
Cell[157390, 4809, 730, 16, 264, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[158157, 4830, 118, 3, 28, "Subsubsection",
 Evaluatable->False,
 InitializationCell->True],
Cell[CellGroupData[{
Cell[158300, 4837, 2067, 32, 763, "Input",
 InitializationCell->True],
Cell[160370, 4871, 383, 7, 22, "Message"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[160802, 4884, 121, 3, 34, "Subsubsection",
 Evaluatable->False,
 InitializationCell->True],
Cell[160926, 4889, 959, 32, 534, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[161922, 4926, 123, 3, 28, "Subsubsection",
 Evaluatable->False,
 InitializationCell->True],
Cell[162048, 4931, 2292, 35, 966, "Input",
 InitializationCell->True]
}, Closed]]
}, Open  ]],
Cell[CellGroupData[{
Cell[164389, 4972, 75, 2, 43, "Subsection",
 Evaluatable->False],
Cell[CellGroupData[{
Cell[164489, 4978, 90, 2, 34, "Subsubsection",
 Evaluatable->False],
Cell[CellGroupData[{
Cell[164604, 4984, 635, 16, 235, "Input",
 InitializationCell->True],
Cell[165242, 5002, 375, 7, 22, "Message"],
Cell[165620, 5011, 374, 7, 22, "Message"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[166043, 5024, 94, 2, 34, "Subsubsection",
 Evaluatable->False],
Cell[166140, 5028, 1845, 28, 840, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[168022, 5061, 94, 2, 28, "Subsubsection",
 Evaluatable->False],
Cell[CellGroupData[{
Cell[168141, 5067, 1560, 25, 661, "Input",
 InitializationCell->True],
Cell[169704, 5094, 375, 7, 22, "Message"]
}, Closed]]
}, Open  ]],
Cell[CellGroupData[{
Cell[170128, 5107, 95, 2, 34, "Subsubsection",
 Evaluatable->False],
Cell[170226, 5111, 2760, 41, 1074, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[173023, 5157, 89, 2, 28, "Subsubsection",
 Evaluatable->False],
Cell[CellGroupData[{
Cell[173137, 5163, 2134, 32, 882, "Input",
 InitializationCell->True],
Cell[175274, 5197, 393, 7, 22, "Message"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[175716, 5210, 95, 2, 34, "Subsubsection",
 Evaluatable->False],
Cell[175814, 5214, 2134, 60, 1020, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[177985, 5279, 93, 2, 28, "Subsubsection",
 Evaluatable->False],
Cell[178081, 5283, 2036, 59, 1002, "Input",
 InitializationCell->True]
}, Closed]],
Cell[CellGroupData[{
Cell[180154, 5347, 95, 2, 28, "Subsubsection",
 Evaluatable->False],
Cell[180252, 5351, 3064, 85, 1470, "Input",
 InitializationCell->True]
}, Closed]]
}, Closed]]
}, Open  ]],
Cell[183355, 5441, 1237, 41, 660, "Input",
 InitializationCell->True],
Cell[184595, 5484, 1219, 41, 660, "Input",
 InitializationCell->True],
Cell[185817, 5527, 70, 2, 31, "Input",
 Evaluatable->False],
Cell[185890, 5531, 83, 2, 31, "Input",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[185998, 5537, 90, 2, 79, "Section",
 Evaluatable->False],
Cell[CellGroupData[{
Cell[186113, 5543, 50, 1, 30, "Input"],
Cell[186166, 5546, 35, 0, 29, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[186238, 5551, 93, 1, 30, "Input"],
Cell[186334, 5554, 205, 4, 24, "Message"],
Cell[186542, 5560, 306, 5, 24, "Message"],
Cell[186851, 5567, 214, 4, 24, "Message"],
Cell[187068, 5573, 158, 3, 24, "Message"],
Cell[187229, 5578, 158, 3, 24, "Message"],
Cell[187390, 5583, 158, 3, 24, "Message"],
Cell[187551, 5588, 213, 4, 24, "Message"],
Cell[187767, 5594, 158, 3, 24, "Message"],
Cell[187928, 5599, 158, 3, 24, "Message"],
Cell[188089, 5604, 158, 3, 24, "Message"],
Cell[188250, 5609, 213, 4, 24, "Message"],
Cell[188466, 5615, 194, 4, 24, "Message"],
Cell[188663, 5621, 194, 4, 24, "Message"],
Cell[188860, 5627, 194, 4, 24, "Message"],
Cell[189057, 5633, 202, 4, 24, "Message"],
Cell[189262, 5639, 205, 4, 24, "Message"],
Cell[189470, 5645, 205, 4, 24, "Message"],
Cell[189678, 5651, 158, 3, 24, "Message"],
Cell[189839, 5656, 158, 3, 24, "Message"],
Cell[190000, 5661, 158, 3, 24, "Message"],
Cell[190161, 5666, 213, 4, 24, "Message"],
Cell[190377, 5672, 332, 6, 24, "Message"],
Cell[190712, 5680, 369, 7, 24, "Message"],
Cell[191084, 5689, 404, 7, 24, "Message"],
Cell[191491, 5698, 204, 4, 24, "Message"]
}, Open  ]],
Cell[CellGroupData[{
Cell[191732, 5707, 77, 1, 30, "Input"],
Cell[191812, 5710, 158, 3, 24, "Message"],
Cell[191973, 5715, 158, 3, 24, "Message"],
Cell[192134, 5720, 158, 3, 24, "Message"],
Cell[192295, 5725, 213, 4, 24, "Message"],
Cell[192511, 5731, 158, 3, 24, "Message"],
Cell[192672, 5736, 158, 3, 24, "Message"],
Cell[192833, 5741, 158, 3, 24, "Message"],
Cell[192994, 5746, 213, 4, 24, "Message"],
Cell[193210, 5752, 213, 4, 24, "Message"],
Cell[193426, 5758, 213, 4, 24, "Message"],
Cell[193642, 5764, 213, 4, 24, "Message"],
Cell[193858, 5770, 202, 4, 24, "Message"],
Cell[194063, 5776, 321, 6, 24, "Message"],
Cell[194387, 5784, 158, 3, 24, "Message"],
Cell[194548, 5789, 158, 3, 24, "Message"],
Cell[194709, 5794, 158, 3, 24, "Message"],
Cell[194870, 5799, 213, 4, 24, "Message"],
Cell[195086, 5805, 213, 4, 24, "Message"],
Cell[195302, 5811, 213, 4, 24, "Message"],
Cell[195518, 5817, 213, 4, 24, "Message"],
Cell[195734, 5823, 202, 4, 24, "Message"],
Cell[195939, 5829, 158, 3, 24, "Message"],
Cell[196100, 5834, 158, 3, 24, "Message"],
Cell[196261, 5839, 158, 3, 24, "Message"],
Cell[196422, 5844, 213, 4, 24, "Message"],
Cell[196638, 5850, 332, 6, 24, "Message"],
Cell[196973, 5858, 369, 7, 24, "Message"],
Cell[197345, 5867, 404, 7, 24, "Message"],
Cell[197752, 5876, 204, 4, 24, "Message"],
Cell[197959, 5882, 193, 4, 24, "Message"],
Cell[198155, 5888, 59, 1, 29, "Output"]
}, Open  ]],
Cell[CellGroupData[{
Cell[198251, 5894, 88, 1, 30, "Input"],
Cell[198342, 5897, 213, 4, 24, "Message"],
Cell[198558, 5903, 312, 6, 24, "Message"],
Cell[198873, 5911, 213, 4, 24, "Message"],
Cell[199089, 5917, 213, 4, 24, "Message"],
Cell[199305, 5923, 202, 4, 24, "Message"],
Cell[199510, 5929, 260, 5, 24, "Message"],
Cell[199773, 5936, 295, 5, 24, "Message"],
Cell[200071, 5943, 332, 6, 24, "Message"],
Cell[200406, 5951, 204, 4, 24, "Message"],
Cell[200613, 5957, 193, 4, 24, "Message"],
Cell[200809, 5963, 193, 4, 24, "Message"],
Cell[201005, 5969, 193, 4, 24, "Message"],
Cell[201201, 5975, 203, 4, 24, "Message"]
}, Open  ]],
Cell[201419, 5982, 78, 1, 30, "Input"],
Cell[CellGroupData[{
Cell[201522, 5987, 79, 1, 30, "Input"],
Cell[201604, 5990, 213, 4, 24, "Message"],
Cell[201820, 5996, 321, 6, 24, "Message"],
Cell[202144, 6004, 213, 4, 24, "Message"],
Cell[202360, 6010, 213, 4, 24, "Message"],
Cell[202576, 6016, 202, 4, 24, "Message"],
Cell[202781, 6022, 193, 4, 24, "Message"],
Cell[202977, 6028, 193, 4, 24, "Message"],
Cell[203173, 6034, 193, 4, 24, "Message"],
Cell[203369, 6040, 203, 4, 24, "Message"],
Cell[203575, 6046, 260, 5, 24, "Message"],
Cell[203838, 6053, 295, 5, 24, "Message"],
Cell[204136, 6060, 332, 6, 24, "Message"],
Cell[204471, 6068, 204, 4, 24, "Message"]
}, Open  ]],
Cell[CellGroupData[{
Cell[204712, 6077, 79, 1, 30, "Input"],
Cell[204794, 6080, 213, 4, 24, "Message"],
Cell[205010, 6086, 321, 6, 24, "Message"],
Cell[205334, 6094, 213, 4, 24, "Message"],
Cell[205550, 6100, 213, 4, 24, "Message"],
Cell[205766, 6106, 202, 4, 24, "Message"],
Cell[205971, 6112, 193, 4, 24, "Message"],
Cell[206167, 6118, 193, 4, 24, "Message"],
Cell[206363, 6124, 193, 4, 24, "Message"],
Cell[206559, 6130, 203, 4, 24, "Message"],
Cell[206765, 6136, 260, 5, 24, "Message"],
Cell[207028, 6143, 295, 5, 24, "Message"],
Cell[207326, 6150, 332, 6, 24, "Message"],
Cell[207661, 6158, 204, 4, 24, "Message"]
}, Open  ]],
Cell[CellGroupData[{
Cell[207902, 6167, 73, 1, 30, "Input"],
Cell[207978, 6170, 213, 4, 24, "Message"],
Cell[208194, 6176, 321, 6, 24, "Message"],
Cell[208518, 6184, 213, 4, 24, "Message"],
Cell[208734, 6190, 213, 4, 24, "Message"],
Cell[208950, 6196, 202, 4, 24, "Message"],
Cell[209155, 6202, 193, 4, 24, "Message"],
Cell[209351, 6208, 193, 4, 24, "Message"],
Cell[209547, 6214, 193, 4, 24, "Message"],
Cell[209743, 6220, 203, 4, 24, "Message"],
Cell[209949, 6226, 260, 5, 24, "Message"],
Cell[210212, 6233, 295, 5, 24, "Message"],
Cell[210510, 6240, 332, 6, 24, "Message"],
Cell[210845, 6248, 204, 4, 24, "Message"]
}, Open  ]],
Cell[CellGroupData[{
Cell[211086, 6257, 73, 1, 30, "Input"],
Cell[211162, 6260, 213, 4, 24, "Message"],
Cell[211378, 6266, 321, 6, 24, "Message"],
Cell[211702, 6274, 213, 4, 24, "Message"],
Cell[211918, 6280, 213, 4, 24, "Message"],
Cell[212134, 6286, 202, 4, 24, "Message"],
Cell[212339, 6292, 193, 4, 24, "Message"],
Cell[212535, 6298, 193, 4, 24, "Message"],
Cell[212731, 6304, 193, 4, 24, "Message"],
Cell[212927, 6310, 203, 4, 24, "Message"],
Cell[213133, 6316, 260, 5, 24, "Message"],
Cell[213396, 6323, 295, 5, 24, "Message"],
Cell[213694, 6330, 332, 6, 24, "Message"],
Cell[214029, 6338, 204, 4, 24, "Message"]
}, Open  ]],
Cell[CellGroupData[{
Cell[214270, 6347, 50, 1, 30, "Input"],
Cell[214323, 6350, 168, 2, 25, "Print",
 CellTags->"Info3288294292-7563725"]
}, Open  ]],
Cell[CellGroupData[{
Cell[214528, 6357, 47, 1, 30, "Input"],
Cell[214578, 6360, 165, 2, 25, "Print",
 CellTags->"Info3288294294-3664163"]
}, Open  ]],
Cell[CellGroupData[{
Cell[214780, 6367, 76, 1, 30, "Input"],
Cell[214859, 6370, 476, 19, 30, "Output"]
}, Open  ]]
}, Closed]],
Cell[CellGroupData[{
Cell[215384, 6395, 86, 2, 49, "Section",
 Evaluatable->False],
Cell[215473, 6399, 1281, 35, 195, "Special1",
 Evaluatable->False],
Cell[CellGroupData[{
Cell[216779, 6438, 186, 5, 66, "Input"],
Cell[216968, 6445, 3293, 92, 67, "Output"]
}, Open  ]],
Cell[220276, 6540, 424, 10, 76, "Special1",
 Evaluatable->False],
Cell[220703, 6552, 215, 7, 102, "Input"],
Cell[220921, 6561, 191, 7, 102, "Input"],
Cell[221115, 6570, 205, 8, 120, "Input"],
Cell[CellGroupData[{
Cell[221345, 6582, 91, 1, 30, "Input"],
Cell[221439, 6585, 2225, 71, 48, "Output"]
}, Open  ]],
Cell[223679, 6659, 270, 6, 25, "Special1",
 Evaluatable->False],
Cell[CellGroupData[{
Cell[223974, 6669, 870, 24, 408, "Input"],
Cell[224847, 6695, 245, 5, 24, "Message"]
}, Open  ]]
}, Closed]]
}, Open  ]]
}, Open  ]]
}, Open  ]]
}
]
*)

(* End of internal cache information *)

classdef CompassWalker < Walker

  properties

    L = 0;
    MLeg = 0;
    ILeg = 0;
    MPelvis = 0;
    IPelvis = 0;
    
    controllers = {};
    
  end

  methods

    function [this] = CompassWalker(input)
      this = this@Walker();
      if (nargin == 1 && ~isempty(input))
        this.L = input.L
        this.MLeg = input.MLeg
        this.ILeg = input.ILeg
        this.MPelvis = input.MPelvis
        this.IPelvis = input.IPelvis
      end
    end

    function [state] = getWalkerStateObjectFromVector(this, stateVector)
      state = CompassWalkerState(stateVector);
    end

    function [qs, us] = getWalkerStateObjectFromVector(this)
      qs = 1:6;
      us = 7:12;
    end

    function [] = setWalkerParamsInCurrentFunction(this)
      ws = 'caller';
      assignin(ws, 'L', this.L);
      assignin(ws, 'MLeg', this.MLeg);
      assignin(ws, 'ILeg', this.ILeg);
      assignin(ws, 'MPelvis', this.MPelvis);
      assignin(ws, 'IPelvis', this.IPelvis);
    end

    function [points] = getKinematicPoints(this, state, uDot)
      state.setQsUsAndTrigInCurrentFunction();
      this.setWalkerParamsInCurrentFunction();

      points.pelvis.position(1) = q1; 
      points.pelvis.position(2) = 0; 
      points.pelvis.position(3) = q2; 
      
      
      points.pelvis.R(1,1) = cos(q3); points.pelvis.R(1,2) = 0; ...
      points.pelvis.R(1,3) = sin(q3); 
      points.pelvis.R(2,1) = 0; points.pelvis.R(2,2) = 1; points.pelvis.R(2,3) = 0; 
      points.pelvis.R(3,1) = -sin(q3); points.pelvis.R(3,2) = 0; ...
      points.pelvis.R(3,3) = cos(q3); 
      
      
      points.stanceLeg.position(1) = q1 + c4*legMassForwardOffset - ...
      s4*legMassVerticalOffsetBelowPelvis; 
      points.stanceLeg.position(2) = 0; 
      points.stanceLeg.position(3) = q2 - s4*legMassForwardOffset - ...
      c4*legMassVerticalOffsetBelowPelvis; 
      
      
      points.stanceLeg.R(1,1) = c4; points.stanceLeg.R(1,2) = 0; ...
      points.stanceLeg.R(1,3) = s4; 
      points.stanceLeg.R(2,1) = 0; points.stanceLeg.R(2,2) = 1; ...
      points.stanceLeg.R(2,3) = 0; 
      points.stanceLeg.R(3,1) = -s4; points.stanceLeg.R(3,2) = 0; ...
      points.stanceLeg.R(3,3) = c4; 
      
      
      points.swingLeg.position(1) = q1 + c5*legMassForwardOffset - ...
      s5*legMassVerticalOffsetBelowPelvis; 
      points.swingLeg.position(2) = 0; 
      points.swingLeg.position(3) = q2 - s5*legMassForwardOffset - ...
      c5*legMassVerticalOffsetBelowPelvis; 
      
      
      points.swingLeg.R(1,1) = c5; points.swingLeg.R(1,2) = 0; ...
      points.swingLeg.R(1,3) = s5; 
      points.swingLeg.R(2,1) = 0; points.swingLeg.R(2,2) = 1; ...
      points.swingLeg.R(2,3) = 0; 
      points.swingLeg.R(3,1) = -s5; points.swingLeg.R(3,2) = 0; ...
      points.swingLeg.R(3,3) = c5; 
      
      
      points.stanceFootContactPoint(1) = q1 - s4*L; 
      points.stanceFootContactPoint(2) = 0; 
      points.stanceFootContactPoint(3) = q2 - c4*L; 
      
      
      points.swingFootContactPoint(1) = q1 - s5*L; 
      points.swingFootContactPoint(2) = 0; 
      points.swingFootContactPoint(3) = q2 - c5*L; 
      
      
      points.comVelocity(1) = u1 - s4*u4*legMassForwardOffset*MLeg*power(2*MLeg + ...
      MPelvis,-1) - s5*u5*legMassForwardOffset*MLeg*power(2*MLeg + MPelvis,-1) - ...
      c4*u4*legMassVerticalOffsetBelowPelvis*MLeg*power(2*MLeg + MPelvis,-1) - ...
      c5*u5*legMassVerticalOffsetBelowPelvis*MLeg*power(2*MLeg + MPelvis,-1); 
      points.comVelocity(2) = 0; 
      points.comVelocity(3) = u2 - c4*u4*legMassForwardOffset*MLeg*power(2*MLeg + ...
      MPelvis,-1) - c5*u5*legMassForwardOffset*MLeg*power(2*MLeg + MPelvis,-1) + ...
      s4*u4*legMassVerticalOffsetBelowPelvis*MLeg*power(2*MLeg + MPelvis,-1) + ...
      s5*u5*legMassVerticalOffsetBelowPelvis*MLeg*power(2*MLeg + MPelvis,-1); 
      
      
      points.centerOfMassPosition(1) = c4*legMassForwardOffset*MLeg*power(2*MLeg + ...
      MPelvis,-1) + c5*legMassForwardOffset*MLeg*power(2*MLeg + MPelvis,-1) - ...
      s4*legMassVerticalOffsetBelowPelvis*MLeg*power(2*MLeg + MPelvis,-1) - ...
      s5*legMassVerticalOffsetBelowPelvis*MLeg*power(2*MLeg + MPelvis,-1) + ...
      (2*q1*MLeg + q1*MPelvis)*power(2*MLeg + MPelvis,-1); 
      points.centerOfMassPosition(2) = 0; 
      points.centerOfMassPosition(3) = -(s4*legMassForwardOffset*MLeg*power(2*MLeg ...
      + MPelvis,-1)) - s5*legMassForwardOffset*MLeg*power(2*MLeg + MPelvis,-1) - ...
      c4*legMassVerticalOffsetBelowPelvis*MLeg*power(2*MLeg + MPelvis,-1) - ...
      c5*legMassVerticalOffsetBelowPelvis*MLeg*power(2*MLeg + MPelvis,-1) + ...
      (2*q2*MLeg + q2*MPelvis)*power(2*MLeg + MPelvis,-1); 
      
      
      points.velStanceFootContactPoint(1) = u1 - c4*u4*L; 
      points.velStanceFootContactPoint(2) = 0; 
      points.velStanceFootContactPoint(3) = u2 + s4*u4*L; 
      
    end

    function [MM, rhs] = getMassMatrixAndRightHandSide(this, time, state)
      state = this.getWalkerStateObjectFromVector(state);
      state.setQsUsAndTrigInCurrentFunction();
      this.setWalkerParamsInCurrentFunction();

      for i = 1 : length(this.controllers)
        this.controllers{i}.calculateControlAndSetInCurrentFunction(this, time, state);
      end

      MM = zeros(5,5); rhs = zeros(5,1);
      
      % Mass Matrix
      MM(1,1) = 2*MLeg + MPelvis; MM(1,2) = 0; MM(1,3) = 0; MM(1,4) = ...
      -((s4*legMassForwardOffset + c4*legMassVerticalOffsetBelowPelvis)*MLeg); ...
      MM(1,5) = -((s5*legMassForwardOffset + ...
      c5*legMassVerticalOffsetBelowPelvis)*MLeg); 
      MM(2,1) = MM(1,2); MM(2,2) = 2*MLeg + MPelvis; MM(2,3) = 0; MM(2,4) = ...
      -(c4*legMassForwardOffset*MLeg) + s4*legMassVerticalOffsetBelowPelvis*MLeg; ...
      MM(2,5) = -(c5*legMassForwardOffset*MLeg) + ...
      s5*legMassVerticalOffsetBelowPelvis*MLeg; 
      MM(3,1) = MM(1,3); MM(3,2) = MM(2,3); MM(3,3) = IPelvis; MM(3,4) = 0; MM(3,5) ...
      = 0; 
      MM(4,1) = MM(1,4); MM(4,2) = MM(2,4); MM(4,3) = MM(3,4); MM(4,4) = ILeg + ...
      MLeg*(legMassForwardOffset*legMassForwardOffset + ...
      legMassVerticalOffsetBelowPelvis*legMassVerticalOffsetBelowPelvis); MM(4,5) = ...
      0; 
      MM(5,1) = MM(1,5); MM(5,2) = MM(2,5); MM(5,3) = MM(3,5); MM(5,4) = MM(4,5); ...
      MM(5,5) = ILeg + MLeg*(legMassForwardOffset*legMassForwardOffset + ...
      legMassVerticalOffsetBelowPelvis*legMassVerticalOffsetBelowPelvis); 
      
      % righthand side terms
      rhs(1) = (c4*legMassForwardOffset - ...
      s4*legMassVerticalOffsetBelowPelvis)*MLeg*(u4*u4) + (c5*legMassForwardOffset ...
      - s5*legMassVerticalOffsetBelowPelvis)*MLeg*(u5*u5) + g*(2*MLeg + ...
      MPelvis)*sin(groundAngle); 
      rhs(2) = -(g*(2*MLeg + MPelvis)*cos(groundAngle)) - (s4*legMassForwardOffset ...
      + c4*legMassVerticalOffsetBelowPelvis)*MLeg*(u4*u4) - ...
      (s5*legMassForwardOffset + c5*legMassVerticalOffsetBelowPelvis)*MLeg*(u5*u5); 
      rhs(3) = 0; 
      rhs(4) = g*MLeg*(legMassForwardOffset*cos(q4 + groundAngle) - ...
      legMassVerticalOffsetBelowPelvis*sin(q4 + groundAngle)); 
      rhs(5) = g*MLeg*(legMassForwardOffset*cos(q5 + groundAngle) - ...
      legMassVerticalOffsetBelowPelvis*sin(q5 + groundAngle)); 
      
    end

    function [C, CDot] = getConstraintMatrix(this, state, mode)
      state = this.getWalkerStateObjectFromVector(state);
      state.setQsUsAndTrigInCurrentFunction();
      this.setWalkerParamsInCurrentFunction();

      switch mode
        case 'stanceFootHinged'
          constraintJacobianStanceFootHinged(2,5) = 0;
          constraintJacobianStanceFootHingedDot(2,5) = 0;

          constraintJacobianStanceFootHinged(1,1) = 1; ...
          constraintJacobianStanceFootHinged(1,2) = 0; ...
          constraintJacobianStanceFootHinged(1,3) = 0; ...
          constraintJacobianStanceFootHinged(1,4) = -(c4*L); ...
          constraintJacobianStanceFootHinged(1,5) = 0; 
          constraintJacobianStanceFootHinged(2,1) = 0; ...
          constraintJacobianStanceFootHinged(2,2) = 1; ...
          constraintJacobianStanceFootHinged(2,3) = 0; ...
          constraintJacobianStanceFootHinged(2,4) = s4*L; ...
          constraintJacobianStanceFootHinged(2,5) = 0; 
          
          
          constraintJacobianStanceFootHingedDot(1,1) = 0; ...
          constraintJacobianStanceFootHingedDot(1,2) = 0; ...
          constraintJacobianStanceFootHingedDot(1,3) = 0; ...
          constraintJacobianStanceFootHingedDot(1,4) = s4*u4*L; ...
          constraintJacobianStanceFootHingedDot(1,5) = 0; 
          constraintJacobianStanceFootHingedDot(2,1) = 0; ...
          constraintJacobianStanceFootHingedDot(2,2) = 0; ...
          constraintJacobianStanceFootHingedDot(2,3) = 0; ...
          constraintJacobianStanceFootHingedDot(2,4) = c4*u4*L; ...
          constraintJacobianStanceFootHingedDot(2,5) = 0; 
          
          C = constraintJacobianStanceFootHinged;
          CDot = constraintJacobianStanceFootHingedDot;

        otherwise
          error('unknown mode for walker: %s', mode);
        end
      end

      function [energies] = getEnergyOfState(this, state)
        state = this.getWalkerStateObjectFromVector(state);
        state.setQsUsAndTrigInCurrentFunction();
        this.setWalkerParamsInCurrentFunction();

        energies.PE = -(g*(-(q2*(2*MLeg + MPelvis)*cos(groundAngle)) + q1*(2*MLeg + ...
        MPelvis)*sin(groundAngle) + MLeg*(legMassVerticalOffsetBelowPelvis*cos(q4 + ...
        groundAngle) + legMassVerticalOffsetBelowPelvis*cos(q5 + groundAngle) + ...
        legMassForwardOffset*(sin(q4 + groundAngle) + sin(q5 + groundAngle)))));
        
        energies.PEGravity = -(g*(-(q2*(2*MLeg + MPelvis)*cos(groundAngle)) + ...
        q1*(2*MLeg + MPelvis)*sin(groundAngle) + ...
        MLeg*(legMassVerticalOffsetBelowPelvis*cos(q4 + groundAngle) + ...
        legMassVerticalOffsetBelowPelvis*cos(q5 + groundAngle) + ...
        legMassForwardOffset*(sin(q4 + groundAngle) + sin(q5 + groundAngle)))));
        
        energies.PESpring = 0;
        
        energies.KE = (IPelvis*(u3*u3) + ILeg*(u4*u4 + u5*u5))/2. + ...
        (-2*u1*(u4*(s4*legMassForwardOffset + c4*legMassVerticalOffsetBelowPelvis) + ...
        u5*(s5*legMassForwardOffset + c5*legMassVerticalOffsetBelowPelvis))*MLeg - ...
        2*u2*(u4*(c4*legMassForwardOffset - s4*legMassVerticalOffsetBelowPelvis) + ...
        u5*(c5*legMassForwardOffset - s5*legMassVerticalOffsetBelowPelvis))*MLeg + ...
        (2*MLeg + MPelvis)*(u1*u1) + (2*MLeg + MPelvis)*(u2*u2) + MLeg*(u4*u4 + ...
        u5*u5)*(legMassForwardOffset*legMassForwardOffset + ...
        legMassVerticalOffsetBelowPelvis*legMassVerticalOffsetBelowPelvis))/2.;
        
        energies.KELinear = (-2*u1*(u4*(s4*legMassForwardOffset + ...
        c4*legMassVerticalOffsetBelowPelvis) + u5*(s5*legMassForwardOffset + ...
        c5*legMassVerticalOffsetBelowPelvis))*MLeg - ...
        2*u2*(u4*(c4*legMassForwardOffset - s4*legMassVerticalOffsetBelowPelvis) + ...
        u5*(c5*legMassForwardOffset - s5*legMassVerticalOffsetBelowPelvis))*MLeg + ...
        (2*MLeg + MPelvis)*(u1*u1) + (2*MLeg + MPelvis)*(u2*u2) + MLeg*(u4*u4 + ...
        u5*u5)*(legMassForwardOffset*legMassForwardOffset + ...
        legMassVerticalOffsetBelowPelvis*legMassVerticalOffsetBelowPelvis))/2.;
        
        energies.KERotational = (IPelvis*(u3*u3) + ILeg*(u4*u4 + u5*u5))/2.;
        
      end

    end

    
  end


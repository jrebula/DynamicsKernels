classdef ThreeDWalkerSplayFromGround < ThreeDWalker
  % ThreeDWalkerSplayFromGround
  
  properties
    
    ILegSmall = 0.003;
    
    IPelvisX = 0.05; %;
    IPelvisY = 0.03; %;
    IPelvisZ = 0.01; %;
    
    stanceAnkleTorque = 0; %
    alwaysInFlightPhase = 0; %1; %
    
    
  end
  
  methods (Static)
    
    function [] = test()
      %% test energy conservation during random falling
      
      % Initial conditions chosen by hand to give something that looks like a step, but isn't
      format compact;
      
      initialConditions = ThreeDWalkerSplayFromGroundState();
      
      walker = ThreeDWalkerSplayFromGround();
      
%       walker.R = 0;
      % walker.legMassVerticalOffset = 0;
      %       walker.MLeg = 1e-5;
      % walker.ILeg = 1e-5;
      % walker.KSwing = 0.0;
      %       walker.KSwing = 0.3;
      %       walker.MPelvis = 1e-5; %
      
      %       walker.ILegSmall = 1e-5;
      %       walker.ILeg = 1e-5;
      %       walker.IPelvisX = 1e-5;
      %       walker.IPelvisY = 1e-5;
      %       walker.IPelvisZ = 1e-5;
      
      %       walker.g = 0;
      %       walker.groundAngle = 0;
      
      initialConditions.pelvis.xDot = 2.0; %0.08;
      initialConditions.pelvis.yDot = -2; %-0.1;
      initialConditions.pelvis.zDot = -5; %0.1;
      
      initialConditions.pelvis.roll = 0;
      initialConditions.pelvis.rollDot = 10; %-0.1;
      
      initialConditions.stanceLeg.roll = -0.08;
      initialConditions.stanceLeg.pitch = -0.08;
      initialConditions.stanceLeg.rollDot = -2;
      initialConditions.stanceLeg.pitchDot = 2; %0.03;
      
      initialConditions.swingLeg.roll = -0.2;
      initialConditions.swingLeg.pitch = 0.08;
      initialConditions.swingLeg.pitchDot = -0.3;
      
      walker.plot(initialConditions);
      
      %%
      % ensure the velocities start consistent with the stance phase
      mode = 'stanceFootRolling';
      [qs, us] = walker.getQAndUIndeces();
      x = initialConditions.getVector();
      x = walker.modeTransition(0, x, mode);
      %       if (norm(walker.getConstraintMatrix(initialConditions, mode) * x(us)') > 1e-6)
      %         error('transition into constrained state failed!');
      %       end
      
      
      figure;
      switchedState = walker.findSwitchedWalkerState(x);
      walker.plot(switchedState);
      
      return;
      initialConditions = ThreeDWalkerSplayFromGroundState(x);
      x = initialConditions.getVector();
      %       if (norm(walker.getConstraintMatrix(initialConditions, mode) * x(us)) > 1e-6)
      %         error('transition into constrained state failed after recreating state object (check constructor?)!');
      %       end
      
      ThreeDWalkerSplay.testEnergyConservation(walker, initialConditions);
      
      %%
      %       walker.groundAngle = 0.1329;
      %       walker.KSwing = 0.0632;
      %       limitCycleHipRollWalker =[ -0.0000   -0.0000    1.0000   -0.1616   -0.3811    0.1657    0.3297    0.1575    0.4117    0.0276    0.1690   -0.4373    0.4462    0.4373    0.2290 0.3716]';
      %
      %       ThreeDWalkerSplay.testEnergyConservation(walker, limitCycleHipRollWalker);
      
    end
    
    function [] = testEnergyConservation(walker, initialConditions)
      %%
      [finalState, finalTime, allStates, allTimes] = walker.oneStep(initialConditions.getVector(), ...
        'interleaveAnimation', 1);
      
      initiaEnergies = walker.getEnergyOfState(allStates(:, 1));
      for i = 1 : (length(allStates) - 1)
        energies = walker.getEnergyOfState(allStates(:, i));
        energies.total
        if abs(energies.total - initiaEnergies.total) > 1e-4
          error('energy conservation failed');
        end
      end
      
    end
    
  end
  
  methods
    
    function [this] = ThreeDWalkerSplayFromGround(input)
      %%
      if (nargin == 0)
        input = [];
      end
      this = this@ThreeDWalker(input);
      
      if (isa(input, 'ThreeDWalkerSplayFromGround'))
        
        this.IPelvisX = input.IPelvisX;
        this.IPelvisY = input.IPelvisY;
        this.IPelvisZ = input.IPelvisZ;
        
        this.ILegSmall = input.ILegSmall;
        this.stanceAnkleTorque = input.stanceAnkleTorque;
        this.alwaysInFlightPhase = input.alwaysInFlightPhase;
      end
      
    end
    
    function [errVals] = getSwitchedLegsError(this, currentState, switchedState)
      [c, errVals] = this.getSwitchedLegsConstraints(currentState, switchedState);
      errVals = norm(errVals);
    end
    
    function [c, errVals] = getSwitchedLegsConstraints(this, currentState, switchedState)
      %%
      c = [];
      currentState = this.getWalkerStateObjectFromVector(currentState);
      switchedState = this.getWalkerStateObjectFromVector(switchedState);
      
      currentPoints = this.getKinematicPoints(currentState);
      currentPointVector = this.kinematicPointsToArray(currentPoints);
      
      switchedPoints = this.getKinematicPoints(switchedState);
      ...switchedPoints = this.reflectPointsLaterally(switchedPoints);
        
    switchedPointsTemp = switchedPoints;
    
    switchedPoints.stanceFootCenter = switchedPointsTemp.swingFootCenter;
    switchedPoints.swingFootCenter = switchedPointsTemp.stanceFootCenter;
    
    %       switchedPoints.stanceFootContactPoint = switchedPointsTemp.swingFootContactPoint;
    %       switchedPoints.swingFootContactPoint = switchedPointsTemp.stanceFootContactPoint;
    
    switchedPoints.stanceHipPoint = switchedPointsTemp.swingHipPoint;
    switchedPoints.swingHipPoint = switchedPointsTemp.stanceHipPoint;
    
    switchedPoints.stanceLeg = switchedPointsTemp.swingLeg;
    switchedPoints.swingLeg = switchedPointsTemp.stanceLeg;
    
    switchedPointVector = this.kinematicPointsToArray(switchedPoints);
    
    errVals = currentPointVector - switchedPointVector;
    %     reshape(errVals, 3, 7)
    norm(errVals);
    end
    
    function [points] = reflectPointsLaterally(this, points)
      %%
      pointFields = fieldnames(points);
      index.type = '()';
      index.subs = {2};
      for i = 1 : length(pointFields)
        v = points.(pointFields{i});
        if (isnumeric(v) && length(v) == 3)
          points.(pointFields{i}) = subsasgn(points.(pointFields{i}), index, -v(2));
        end
      end
    end
    
    function [pointVector] = kinematicPointsToArray(this, points)
      pointVector = [ ...
        ...points.pelvis.position, ...
        points.pelvis.velocity, ...(1:2)
        ...reshape(points.pelvis.R, [1, 9]), ...
        ...
        ...points.stanceLeg.position, ...
        points.stanceLeg.velocity, ...
        ...reshape(points.stanceLeg.R, [1, 9]), ...
        ...
        ...points.swingLeg.position, ...
        points.swingLeg.velocity, ...
        ...reshape(points.swingLeg.R, [1, 9]), ...
        ...
        points.stanceFootCenter, ...
        points.swingFootCenter, ...
        ...
        ...points.stanceFootContactPoint, ...
        ...points.swingFootContactPoint, ...
        ...
        points.stanceHipPoint, ... x coordinate here is messed up (2:3)
        points.swingHipPoint, ...
        ...
        ...points.comVelocity, ...
        ...
        ...points.centerOfMassPosition
        ];
    end
    
    function [newState] = findSwitchedWalkerState(this, stateOriginal)
      %%
      state = this.getWalkerStateObjectFromVector(stateOriginal);
      %       initialGuess = randn(size(state.getVector())) * 0.01;
      
      state.stanceLeg.roll = state.stanceLeg.roll + pi;
      state.swingLeg.roll = state.swingLeg.roll + pi;
      initialGuess = state.getVector();
      %       figure
      %       this.plot(initialGuess)
      %       initialGuess
      
      %%
      
      tic
      options = optimset('algorithm', 'sqp', 'MaxFunEvals', 1e4);
      newState = fmincon(@(x) 0, initialGuess, [], [], [], [], [], [], @(x) this.getSwitchedLegsConstraints(stateOriginal, x), options);
      newState = fmincon(@(x) 0, newState, [], [], [], [], [], [], @(x) this.getSwitchedLegsConstraints(stateOriginal, x), options);

      %       newState = fminunc(@(x) this.getSwitchedLegsError(stateOriginal, x), initialGuess, options);
      toc
      
      newPoints = this.getKinematicPoints(this.getWalkerStateObjectFromVector(newState));
    end
    
    function [state] = getWalkerStateObjectFromVector(this, stateVector)
      %%
      state = ThreeDWalkerSplayFromGroundState(stateVector);
    end
    
    function [energies] = plot(this, state, varargin)
      %%
      
      plotLegsSwitched = 0;
      
      for i = 1 : 2 : length(varargin)
        option = varargin{i};
        value = varargin{i + 1};
        switch option
          case 'plotLegsSwitched'
            plotLegsSwitched = value;
        end
      end
      
      %%
      state = this.getWalkerStateObjectFromVector(state);
      
      if (plotLegsSwitched)
        state = state.switchLegs();
      end
      
      % tic
      points = this.getKinematicPoints(state);
      % toc
      % clarice
      
      plotter = WalkerPlotter;
      
      stanceFoot.R = points.stanceLeg.R;
      stanceFoot.position = points.stanceFootCenter;
      plotter.plotFoot(stanceFoot, this.R);
      
      plotter.drawCOMSymbol(points.pelvis);
      plotter.drawCOMSymbol(points.stanceLeg);
      plotter.drawCOMSymbol(points.swingLeg);
      
      plotter.plotSegmentBetweenPoints(points.stanceHipPoint, points.swingHipPoint);
      plotter.plotSegmentBetweenPoints(points.stanceHipPoint, points.stanceFootCenter);
      
      plotter.plotSegmentBetweenPoints(points.stanceFootCenter, points.stanceFootContactPoint);
      
      plotter.plotSegmentBetweenPoints(points.swingHipPoint, points.swingFootCenter);
      plotter.plotSegmentBetweenPoints(points.swingFootCenter, points.swingFootContactPoint);
      
      %       plotVectorFromPoint(points.swingFoot, points.swingFootSpringForce, 'vectorColor', 'g', 'scaleFactor', 0.02);
      %       plotVectorFromPoint(points.stanceFoot, points.stanceFootSpringForce, 'vectorColor', 'c', 'scaleFactor', 0.02);
      
      
      axis equal;
      
      try
        if (~isnan(points.pelvis.position(1)))
          xlim(points.pelvis.position(1) + [-0.5 0.5]);
          %         ylim(points.pelvis.position(2) + [-0.5 0.5]);
          %         zlim([-0.05, 1]);
          %         xlim([-0.5 1.5]);
        else
          xlim(points.stanceLeg.position(1) + [-0.5 0.5]);
        end
      catch e
        xlim(points.stanceLeg.position(1) + [-0.5 0.5]);
      end
      %
      ylim([-0.5 0.5]);
      zlim([-0.05, 1]);
      
      %       xlim(points.pelvis.position(1) + [-0.5 0.5]);
      %       ylim(points.pelvis.position(2) + [-0.5 0.5]);
      %       zlim(points.pelvis.position(3) + [-0.5 0.5]);
      
      set(gca, 'XGrid', 'on');
      
      energies = this.getEnergyOfState(state);
      
      try
        [xDot, uDot, lambda] = this.stateDerivative(0, state.getVector(), 'stanceFootRolling');
        
        text(points.pelvis.position(1), points.pelvis.position(2), points.pelvis.position(3) - 0.2, ...
          sprintf(['E = %g, KE = %g, PE = %g, PEg = %g, \nverticalFootAcc. = %g, verticalFootVel = %g\n' ...
          'KLinear = %g, KRot = %g'], ...
          energies.total, energies.KE, energies.PE, energies.PEGravity, uDot(3), xDot(3), ...
          energies.KELinear, energies.KERotational));
        
        text(points.stanceFootContactPoint(1), points.stanceFootContactPoint(2), points.stanceFootContactPoint(3), ...
          sprintf('contact point height = %g\nstance foot contact v = %g, %g, %g', ...
          points.stanceFootContactPoint(3), points.velStanceFootContactPoint));
        
        text(points.stanceFootCenter(1), points.stanceFootCenter(2), points.stanceFootCenter(3), ...
          sprintf('stance foot center = %g, %g, %g', points.stanceFootCenter));
        
        text(points.stanceLeg.position(1), points.stanceLeg.position(2), points.stanceLeg.position(3), ...
          sprintf('stance leg com height = %g', points.stanceLeg.position(3)));
        
        text(points.stanceLeg.position(1), points.stanceLeg.position(2), points.stanceLeg.position(3), ...
          sprintf('\nstance leg vel = %s', sprintf('%g, ', points.stanceLeg.velocity)));
        
        text(points.swingLeg.position(1), points.swingLeg.position(2), points.swingLeg.position(3), ...
          sprintf('\n\nswing leg vel = %s', sprintf('%g, ', points.swingLeg.velocity)));

      catch e
      end
      
    end
    
    function [value, isTerminal, direction] = fellOrSwingFootTouchdown(this, t, state)
      %%
      if (this.alwaysInFlightPhase)
        value = 1;
        isTerminal = 0;
        direction = 1;
      else
        [value, isTerminal, direction] = fellOrSwingFootTouchdown@ThreeDWalker(this, t, state);
      end
    end
    
    function [finalState, finalTime, allStates, allTimes] = oneStep(this, initialState, varargin)
      %%
      initialState = this.getWalkerStateObjectFromVector(initialState);
      initialState = initialState.getVector();
      
      if (isempty(varargin))
        [finalState, finalTime, allStates, allTimes] = ...
          oneStep@ThreeDWalker(this, initialState);
      else
        [finalState, finalTime, allStates, allTimes] = ...
          oneStep@ThreeDWalker(this, initialState, varargin{:});
      end
    end
    
    function [c, ceq] = limitCycleConstraintsOnInitialPositionAndSplayAngle(this, xInitial, xFinal)
      %%
      %       [c, ceq] = this.limitCycleConstraintsOnInitialPosition(xInitial, xFinal);
      
      xInitial = this.getWalkerStateObjectFromVector(xInitial);
      c = [];
      ceq = [xInitial.stanceAnkle.x; xInitial.stanceAnkle.y; xInitial.stanceAnkle.z];
      
      
      %       c = [c -xInitial.stanceLeg.roll];
      
      %       ceq = [ceq; ...
      %         xInitial.stanceLeg.roll + xInitial.swingLeg.roll; ...
      %         xInitial.stanceLeg.rollDot + xInitial.swingLeg.rollDot; ...
      %         ];
    end
    
    function [initialCondition, limitCycleError, ...
        extraInequalityConstraintError, extraEqualityConstraintErrors] = findLimitCycle(this, initialConditionGuess, varargin)
      %% gets a limit cycle for a 3d walker, uses Walker.findLimitCycle, ignoring appropriate dofs (pelvis x and y),
      % and adds a constaint on the otherwise free initial position of the
      % pelvis to (0, 0, 1). Takes all of the same optional arguments as
      % Walker.findLimitCycle, any args you specify take precedence over
      % the default ones generated by this function.
      
      varargin = [ ...
        {'additionalConstraintFunction', @(xInitial, xFinal) this.limitCycleConstraintsOnInitialPositionAndSplayAngle(xInitial, xFinal)}, ...
        varargin];
      
      [initialCondition, limitCycleError, ...
        extraInequalityConstraintError, extraEqualityConstraintErrors] = ...
        findLimitCycle@ThreeDWalker(this, initialConditionGuess, varargin{:});
    end
    
    function [qs, us] = getQAndUIndeces(this)
      %%
      qs = 1:8;
      us = 9:16;
    end
    
    function [] = setWalkerParamsInCurrentFunction(this)
      %%
      ws = 'caller';
      assignin(ws, 'L', this.L);
      assignin(ws, 'R', this.R);
      assignin(ws, 'MPelvis', this.MPelvis);
      %       assignin(ws, 'IPelvis', this.IPelvis);
      assignin(ws, 'pelvisWidth', this.pelvisWidth);
      assignin(ws, 'MLeg', this.MLeg);
      assignin(ws, 'ILeg', this.ILeg);
      assignin(ws, 'legMassVerticalOffset', this.legMassVerticalOffset);
      assignin(ws, 'legMassForwardOffset', this.legMassForwardOffset);
      assignin(ws, 'splayAngle', this.splayAngle);
      assignin(ws, 'g', this.g);
      assignin(ws, 'groundAngle', this.groundAngle);
      assignin(ws, 'KSwing', this.KSwing);
      assignin(ws, 'lateralPelvisForce', this.lateralPelvisForce);
      
      assignin(ws, 'IPelvisX', this.IPelvisX);
      assignin(ws, 'IPelvisY', this.IPelvisY);
      assignin(ws, 'IPelvisZ', this.IPelvisZ);
      
      assignin(ws, 'ILegSmall', this.ILegSmall);
      assignin(ws, 'stanceAnkleTorque', this.stanceAnkleTorque);
    end
    
    function [points] = getKinematicPoints(this, state, uDot)
      %%
      state.setQsUsAndTrigInCurrentFunction();
      this.setWalkerParamsInCurrentFunction();
      
      
      
      points.pelvis.position(1) = q1 + s4*(-(s5p6*pelvisWidth)/2. + c5*(L - R));
      points.pelvis.position(2) = q2 - (c5p6*pelvisWidth)/2. - s5*(L - R);
      points.pelvis.position(3) = q3 + c4*(-(s5p6*pelvisWidth)/2. + c5*(L - R));
      
      
      points.pelvis.velocity(1) = c4*(c4*u1 - s4*u3 + (u4*(-(s5p6*pelvisWidth) + ...
        2*c5*(L - R)))/2.) + s4*(s5p6*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + ...
        c4*c5*s6*u3 - c6*u5*L + c6*u5*R) + c5p6*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - ...
        c4*s5*s6*u3 + s6*u5*L - (u5*pelvisWidth)/2. - (u6*pelvisWidth)/2. - ...
        s6*u5*R));
      points.pelvis.velocity(2) = c5p6*(s4*s5p6*u1 + c5p6*u2 + c4*s5p6*u3 - c6*u5*L ...
        + c6*u5*R) - s5p6*(c5p6*s4*u1 - s5p6*u2 + c4*c5p6*u3 + s6*u5*L - ...
        (u5*pelvisWidth)/2. - (u6*pelvisWidth)/2. - s6*u5*R);
      points.pelvis.velocity(3) = -(s4*(c4*u1 - s4*u3 + (u4*(-(s5p6*pelvisWidth) + ...
        2*c5*(L - R)))/2.)) + c4*(s5p6*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + ...
        c4*c5*s6*u3 - c6*u5*L + c6*u5*R) + c5p6*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - ...
        c4*s5*s6*u3 + s6*u5*L - (u5*pelvisWidth)/2. - (u6*pelvisWidth)/2. - ...
        s6*u5*R));
      
      
      points.pelvis.R(1,1) = c4; points.pelvis.R(1,2) = s4*s5p6; ...
        points.pelvis.R(1,3) = c5p6*s4;
      points.pelvis.R(2,1) = 0; points.pelvis.R(2,2) = c5p6; points.pelvis.R(2,3) = ...
        -s5p6;
      points.pelvis.R(3,1) = -s4; points.pelvis.R(3,2) = c4*s5p6; ...
        points.pelvis.R(3,3) = c4*c5p6;
      
      
      points.stanceLeg.position(1) = q1 + c5*s4*(L - legMassVerticalOffset - R);
      points.stanceLeg.position(2) = q2 - s5*(L - legMassVerticalOffset - R);
      points.stanceLeg.position(3) = q3 + c4*c5*(L - legMassVerticalOffset - R);
      
      
      points.stanceLeg.velocity(1) = s4*(c5*(c5*s4*u1 - s5*u2 + c4*c5*u3) + ...
        s5*(s4*s5*u1 + c5*u2 + c4*s5*u3 - u5*(L - legMassVerticalOffset - R))) + ...
        c4*(c4*u1 - s4*u3 + c5*u4*(L - legMassVerticalOffset - R));
      points.stanceLeg.velocity(2) = -(s5*(-(s5*u2) + c5*(s4*u1 + c4*u3))) + ...
        c5*(c5*u2 + s5*(s4*u1 + c4*u3) - u5*(L - legMassVerticalOffset - R));
      points.stanceLeg.velocity(3) = c4*(c5*(c5*s4*u1 - s5*u2 + c4*c5*u3) + ...
        s5*(s4*s5*u1 + c5*u2 + c4*s5*u3 - u5*(L - legMassVerticalOffset - R))) - ...
        s4*(c4*u1 - s4*u3 + c5*u4*(L - legMassVerticalOffset - R));
      
      
      points.stanceLeg.R(1,1) = c4; points.stanceLeg.R(1,2) = s4*s5; ...
        points.stanceLeg.R(1,3) = c5*s4;
      points.stanceLeg.R(2,1) = 0; points.stanceLeg.R(2,2) = c5; ...
        points.stanceLeg.R(2,3) = -s5;
      points.stanceLeg.R(3,1) = -s4; points.stanceLeg.R(3,2) = c4*s5; ...
        points.stanceLeg.R(3,3) = c4*c5;
      
      
      points.swingLeg.position(1) = q1 - (c4*c8*s7 + s4*(s5*(-(c7*c8*s6) - c6*s8) + ...
        c5*(c6*c7*c8 - s6*s8)))*legMassVerticalOffset + s4*(-(s5p6*pelvisWidth) + ...
        c5*(L - R));
      points.swingLeg.position(2) = q2 - (c5*(-(c7*c8*s6) - c6*s8) - s5*(c6*c7*c8 - ...
        s6*s8))*legMassVerticalOffset - c5p6*pelvisWidth - s5*(L - R);
      points.swingLeg.position(3) = q3 - (-(c8*s4*s7) + c4*(s5*(-(c7*c8*s6) - ...
        c6*s8) + c5*(c6*c7*c8 - s6*s8)))*legMassVerticalOffset + ...
        c4*(-(s5p6*pelvisWidth) + c5*(L - R));
      
      
      points.swingLeg.velocity(1) = (c4*c7 - c5p6*s4*s7)*(-(((-(s5*(c8*s6 + ...
        c6*c7*s8)) + c5*(c6*c8 - c7*s6*s8))*u4 + s7*s8*(u5 + u6) + ...
        c8*u7)*legMassVerticalOffset) + c7*(c4*u1 - s4*u3 + u4*(-(s5p6*pelvisWidth) + ...
        c5*(L - R))) - s7*(c5p6*s4*u1 - s5p6*u2 + c4*c5p6*u3 + s6*u5*L - ...
        u5*pelvisWidth - u6*pelvisWidth - s6*u5*R)) + (c4*c8*s7 + s4*(s5*(-(c7*c8*s6) ...
        - c6*s8) + c5*(c6*c7*c8 - s6*s8)))*(-(s8*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 ...
        + c4*c5*s6*u3 - c6*u5*L + c6*u5*R)) + c8*(s7*(c4*u1 - s4*u3 + ...
        u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + c7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - ...
        s6*u5*R))) + (c4*s7*s8 + s4*(c5*(c8*s6 + c6*c7*s8) + s5*(c6*c8 - ...
        c7*s6*s8)))*((s5p6*s7*u4 + c7*(u5 + u6) + u8)*legMassVerticalOffset + ...
        c8*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + c6*u5*R) + ...
        s8*(s7*(c4*u1 - s4*u3 + u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + ...
        c7*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - ...
        u5*pelvisWidth - u6*pelvisWidth - s6*u5*R)));
      points.swingLeg.velocity(2) = s5p6*s7*(-(((-(s5*(c8*s6 + c6*c7*s8)) + ...
        c5*(c6*c8 - c7*s6*s8))*u4 + s7*s8*(u5 + u6) + c8*u7)*legMassVerticalOffset) + ...
        c7*(c4*u1 - s4*u3 + u4*(-(s5p6*pelvisWidth) + c5*(L - R))) - s7*(c5p6*s4*u1 - ...
        s5p6*u2 + c4*c5p6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - s6*u5*R)) ...
        + (c5*(-(c7*c8*s6) - c6*s8) - s5*(c6*c7*c8 - s6*s8))*(-(s8*(s4*s5p6*u1 + ...
        c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + c6*u5*R)) + c8*(s7*(c4*u1 - ...
        s4*u3 + u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + c7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - ...
        s6*u5*R))) + (-(s5*(c8*s6 + c6*c7*s8)) + c5*(c6*c8 - c7*s6*s8))*((s5p6*s7*u4 ...
        + c7*(u5 + u6) + u8)*legMassVerticalOffset + c8*(s4*s5p6*u1 + c5p6*u2 + ...
        c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + c6*u5*R) + s8*(s7*(c4*u1 - s4*u3 + ...
        u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + c7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - ...
        s6*u5*R)));
      points.swingLeg.velocity(3) = (-(c7*s4) - c4*c5p6*s7)*(-(((-(s5*(c8*s6 + ...
        c6*c7*s8)) + c5*(c6*c8 - c7*s6*s8))*u4 + s7*s8*(u5 + u6) + ...
        c8*u7)*legMassVerticalOffset) + c7*(c4*u1 - s4*u3 + u4*(-(s5p6*pelvisWidth) + ...
        c5*(L - R))) - s7*(c5p6*s4*u1 - s5p6*u2 + c4*c5p6*u3 + s6*u5*L - ...
        u5*pelvisWidth - u6*pelvisWidth - s6*u5*R)) + (-(c8*s4*s7) + ...
        c4*(s5*(-(c7*c8*s6) - c6*s8) + c5*(c6*c7*c8 - s6*s8)))*(-(s8*(s4*s5p6*u1 + ...
        c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + c6*u5*R)) + c8*(s7*(c4*u1 - ...
        s4*u3 + u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + c7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - ...
        s6*u5*R))) + (-(s4*s7*s8) + c4*(c5*(c8*s6 + c6*c7*s8) + s5*(c6*c8 - ...
        c7*s6*s8)))*((s5p6*s7*u4 + c7*(u5 + u6) + u8)*legMassVerticalOffset + ...
        c8*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + c6*u5*R) + ...
        s8*(s7*(c4*u1 - s4*u3 + u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + ...
        c7*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - ...
        u5*pelvisWidth - u6*pelvisWidth - s6*u5*R)));
      
      
      points.swingLeg.R(1,1) = c4*c7 - c5p6*s4*s7; points.swingLeg.R(1,2) = ...
        c4*s7*s8 + s4*(c5*(c8*s6 + c6*c7*s8) + s5*(c6*c8 - c7*s6*s8)); ...
        points.swingLeg.R(1,3) = c4*c8*s7 + s4*(s5*(-(c7*c8*s6) - c6*s8) + ...
        c5*(c6*c7*c8 - s6*s8));
      points.swingLeg.R(2,1) = s5p6*s7; points.swingLeg.R(2,2) = -(s5*(c8*s6 + ...
        c6*c7*s8)) + c5*(c6*c8 - c7*s6*s8); points.swingLeg.R(2,3) = c5*(-(c7*c8*s6) ...
        - c6*s8) - s5*(c6*c7*c8 - s6*s8);
      points.swingLeg.R(3,1) = -(c7*s4) - c4*c5p6*s7; points.swingLeg.R(3,2) = ...
        -(s4*s7*s8) + c4*(c5*(c8*s6 + c6*c7*s8) + s5*(c6*c8 - c7*s6*s8)); ...
        points.swingLeg.R(3,3) = -(c8*s4*s7) + c4*(s5*(-(c7*c8*s6) - c6*s8) + ...
        c5*(c6*c7*c8 - s6*s8));
      
      
      points.stanceFootCenter(1) = q1;
      points.stanceFootCenter(2) = q2;
      points.stanceFootCenter(3) = q3;
      
      
      points.swingFootCenter(1) = q1 + s4*(-(s5p6*pelvisWidth) + c5*(L - R)) + ...
        (c4*c8*s7 + s4*(s5*(-(c7*c8*s6) - c6*s8) + c5*(c6*c7*c8 - s6*s8)))*(-L + R);
      points.swingFootCenter(2) = q2 - c5p6*pelvisWidth - s5*(L - R) + ...
        (c5*(-(c7*c8*s6) - c6*s8) - s5*(c6*c7*c8 - s6*s8))*(-L + R);
      points.swingFootCenter(3) = q3 + c4*(-(s5p6*pelvisWidth) + c5*(L - R)) + ...
        (-(c8*s4*s7) + c4*(s5*(-(c7*c8*s6) - c6*s8) + c5*(c6*c7*c8 - s6*s8)))*(-L + ...
        R);
      
      
      points.stanceFootContactPoint(1) = q1;
      points.stanceFootContactPoint(2) = q2;
      points.stanceFootContactPoint(3) = q3 - R;
      
      
      points.swingFootContactPoint(1) = q1 + s4*(-(s5p6*pelvisWidth) + c5*(L - R)) ...
        + (c4*c8*s7 + s4*(s5*(-(c7*c8*s6) - c6*s8) + c5*(c6*c7*c8 - s6*s8)))*(-L + ...
        R);
      points.swingFootContactPoint(2) = q2 - c5p6*pelvisWidth - s5*(L - R) + ...
        (c5*(-(c7*c8*s6) - c6*s8) - s5*(c6*c7*c8 - s6*s8))*(-L + R);
      points.swingFootContactPoint(3) = q3 + c4*(-(s5p6*pelvisWidth) + c5*(L - R)) ...
        - R + (-(c8*s4*s7) + c4*(s5*(-(c7*c8*s6) - c6*s8) + c5*(c6*c7*c8 - ...
        s6*s8)))*(-L + R);
      
      
      points.stanceHipPoint(1) = q1 + c5*s4*(L - R);
      points.stanceHipPoint(2) = q2 - s5*(L - R);
      points.stanceHipPoint(3) = q3 + c4*c5*(L - R);
      
      
      points.swingHipPoint(1) = q1 + s4*(-(s5p6*pelvisWidth) + c5*(L - R));
      points.swingHipPoint(2) = q2 - c5p6*pelvisWidth - s5*(L - R);
      points.swingHipPoint(3) = q3 + c4*(-(s5p6*pelvisWidth) + c5*(L - R));
      
      
      points.comVelocity(1) = c5*s4*(c5*s4*u1 - s5*u2 + c4*c5*u3)*MLeg*power(2*MLeg ...
        + MPelvis,-1) + s4*s5*MLeg*(s4*s5*u1 + c5*u2 + c4*s5*u3 - u5*(L - ...
        legMassVerticalOffset - R))*power(2*MLeg + MPelvis,-1) + ...
        s4*s5p6*MPelvis*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + ...
        c6*u5*R)*power(2*MLeg + MPelvis,-1) + c5p6*s4*MPelvis*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - (u5*pelvisWidth)/2. - ...
        (u6*pelvisWidth)/2. - s6*u5*R)*power(2*MLeg + MPelvis,-1) + (c4*c8*s7 + ...
        s4*(s5*(-(c7*c8*s6) - c6*s8) + c5*(c6*c7*c8 - s6*s8)))*MLeg*(c8*s7*(c4*u1 - ...
        s4*u3 + u4*(-(s5p6*pelvisWidth) + c5*(L - R))) - s8*(s4*s5p6*u1 + c5p6*u2 + ...
        c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + c6*u5*R) + c7*c8*(c5p6*s4*u1 - s5p6*u2 ...
        + c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - ...
        s6*u5*R))*power(2*MLeg + MPelvis,-1) + (c4*c7 - ...
        c5p6*s4*s7)*MLeg*(-(((-(s5*(c8*s6 + c6*c7*s8)) + c5*(c6*c8 - c7*s6*s8))*u4 + ...
        s7*s8*(u5 + u6) + c8*u7)*legMassVerticalOffset) + c7*(c4*u1 - s4*u3 + ...
        u4*(-(s5p6*pelvisWidth) + c5*(L - R))) - s7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - ...
        s6*u5*R))*power(2*MLeg + MPelvis,-1) + (c4*s7*s8 + s4*(c5*(c8*s6 + c6*c7*s8) ...
        + s5*(c6*c8 - c7*s6*s8)))*MLeg*((s5p6*s7*u4 + c7*(u5 + u6) + ...
        u8)*legMassVerticalOffset + s7*s8*(c4*u1 - s4*u3 + u4*(-(s5p6*pelvisWidth) + ...
        c5*(L - R))) + c8*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L ...
        + c6*u5*R) + c7*s8*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - c4*s5*s6*u3 + ...
        s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - s6*u5*R))*power(2*MLeg + ...
        MPelvis,-1) + c4*(MPelvis*(c4*u1 - s4*u3 + (u4*(-(s5p6*pelvisWidth) + 2*c5*(L ...
        - R)))/2.)*power(2*MLeg + MPelvis,-1) + MLeg*(c4*u1 - s4*u3 + c5*u4*(L - ...
        legMassVerticalOffset - R))*power(2*MLeg + MPelvis,-1));
      points.comVelocity(2) = -(s5*(c5*s4*u1 - s5*u2 + c4*c5*u3)*MLeg*power(2*MLeg ...
        + MPelvis,-1)) + c5*MLeg*(s4*s5*u1 + c5*u2 + c4*s5*u3 - u5*(L - ...
        legMassVerticalOffset - R))*power(2*MLeg + MPelvis,-1) + ...
        c5p6*MPelvis*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + ...
        c6*u5*R)*power(2*MLeg + MPelvis,-1) + (c5*(-(c7*c8*s6) - c6*s8) - ...
        s5*(c6*c7*c8 - s6*s8))*MLeg*(c8*s7*(c4*u1 - s4*u3 + u4*(-(s5p6*pelvisWidth) + ...
        c5*(L - R))) - s8*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L ...
        + c6*u5*R) + c7*c8*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - c4*s5*s6*u3 + ...
        s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - s6*u5*R))*power(2*MLeg + ...
        MPelvis,-1) + (-(s5*(c8*s6 + c6*c7*s8)) + c5*(c6*c8 - ...
        c7*s6*s8))*MLeg*((s5p6*s7*u4 + c7*(u5 + u6) + u8)*legMassVerticalOffset + ...
        s7*s8*(c4*u1 - s4*u3 + u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + ...
        c8*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + c6*u5*R) + ...
        c7*s8*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - ...
        u5*pelvisWidth - u6*pelvisWidth - s6*u5*R))*power(2*MLeg + MPelvis,-1) + ...
        s5p6*(-(MPelvis*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - ...
        (u5*pelvisWidth)/2. - (u6*pelvisWidth)/2. - s6*u5*R)*power(2*MLeg + ...
        MPelvis,-1)) + s7*MLeg*(-(((-(s5*(c8*s6 + c6*c7*s8)) + c5*(c6*c8 - ...
        c7*s6*s8))*u4 + s7*s8*(u5 + u6) + c8*u7)*legMassVerticalOffset) + c7*(c4*u1 - ...
        s4*u3 + u4*(-(s5p6*pelvisWidth) + c5*(L - R))) - s7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - ...
        s6*u5*R))*power(2*MLeg + MPelvis,-1));
      points.comVelocity(3) = -(s4*MPelvis*(c4*u1 - s4*u3 + ...
        (u4*(-(s5p6*pelvisWidth) + 2*c5*(L - R)))/2.)*power(2*MLeg + MPelvis,-1)) - ...
        s4*MLeg*(c4*u1 - s4*u3 + c5*u4*(L - legMassVerticalOffset - R))*power(2*MLeg ...
        + MPelvis,-1) + c4*s5p6*MPelvis*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + ...
        c4*c5*s6*u3 - c6*u5*L + c6*u5*R)*power(2*MLeg + MPelvis,-1) + ...
        c4*c5p6*MPelvis*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - ...
        (u5*pelvisWidth)/2. - (u6*pelvisWidth)/2. - s6*u5*R)*power(2*MLeg + ...
        MPelvis,-1) + (-(c8*s4*s7) + c4*(s5*(-(c7*c8*s6) - c6*s8) + c5*(c6*c7*c8 - ...
        s6*s8)))*MLeg*(c8*s7*(c4*u1 - s4*u3 + u4*(-(s5p6*pelvisWidth) + c5*(L - R))) ...
        - s8*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + c6*u5*R) + ...
        c7*c8*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - ...
        u5*pelvisWidth - u6*pelvisWidth - s6*u5*R))*power(2*MLeg + MPelvis,-1) + ...
        (-(c7*s4) - c4*c5p6*s7)*MLeg*(-(((-(s5*(c8*s6 + c6*c7*s8)) + c5*(c6*c8 - ...
        c7*s6*s8))*u4 + s7*s8*(u5 + u6) + c8*u7)*legMassVerticalOffset) + c7*(c4*u1 - ...
        s4*u3 + u4*(-(s5p6*pelvisWidth) + c5*(L - R))) - s7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - ...
        s6*u5*R))*power(2*MLeg + MPelvis,-1) + (-(s4*s7*s8) + c4*(c5*(c8*s6 + ...
        c6*c7*s8) + s5*(c6*c8 - c7*s6*s8)))*MLeg*((s5p6*s7*u4 + c7*(u5 + u6) + ...
        u8)*legMassVerticalOffset + s7*s8*(c4*u1 - s4*u3 + u4*(-(s5p6*pelvisWidth) + ...
        c5*(L - R))) + c8*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L ...
        + c6*u5*R) + c7*s8*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - c4*s5*s6*u3 + ...
        s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - s6*u5*R))*power(2*MLeg + ...
        MPelvis,-1) + c4*(c5*(c5*s4*u1 - s5*u2 + c4*c5*u3)*MLeg*power(2*MLeg + ...
        MPelvis,-1) + s5*MLeg*(s4*s5*u1 + c5*u2 + c4*s5*u3 - u5*(L - ...
        legMassVerticalOffset - R))*power(2*MLeg + MPelvis,-1));
      
      
      points.centerOfMassPosition(1) = q1 - (c4*c8*s7 + s4*(s5*(-(c7*c8*s6) - ...
        c6*s8) + c5*(c6*c7*c8 - s6*s8)))*legMassVerticalOffset*MLeg*power(2*MLeg + ...
        MPelvis,-1) + s4*(-(s5p6*pelvisWidth)/2. + c5*(-(legMassVerticalOffset*MLeg) ...
        + L*(2*MLeg + MPelvis) - (2*MLeg + MPelvis)*R)*power(2*MLeg + MPelvis,-1));
      points.centerOfMassPosition(2) = q2 - (c5p6*pelvisWidth)/2. - ...
        (c5*(-(c7*c8*s6) - c6*s8) - s5*(c6*c7*c8 - ...
        s6*s8))*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1) - ...
        s5*(-(legMassVerticalOffset*MLeg) + L*(2*MLeg + MPelvis) - (2*MLeg + ...
        MPelvis)*R)*power(2*MLeg + MPelvis,-1);
      points.centerOfMassPosition(3) = q3 - (-(c8*s4*s7) + c4*(s5*(-(c7*c8*s6) - ...
        c6*s8) + c5*(c6*c7*c8 - s6*s8)))*legMassVerticalOffset*MLeg*power(2*MLeg + ...
        MPelvis,-1) + c4*(-(s5p6*pelvisWidth)/2. + c5*(-(legMassVerticalOffset*MLeg) ...
        + L*(2*MLeg + MPelvis) - (2*MLeg + MPelvis)*R)*power(2*MLeg + MPelvis,-1));
      
      
      points.velStanceFootContactPoint(1) = u1;
      points.velStanceFootContactPoint(2) = u2;
      points.velStanceFootContactPoint(3) = u3;
      
      
      
      
      
      if (nargin > 2)
        u1dot = uDot(1);
        u2dot = uDot(2);
        u3dot = uDot(3);
        u4dot = uDot(4);
        u5dot = uDot(5);
        u6dot = uDot(6);
        u7dot = uDot(7);
        u8dot = uDot(8);
      end
      
    end
    
    function [MM, rhs] = getMassMatrixAndRightHandSide(this, time, state)
      %%
      [MM, rhs] = getMassMatrixAndRHSForThreeDWalkerHipRollFromStanceFoot(this, time, state);
    end
    
    function [C, CDot] = getConstraintMatrix(this, state, mode)
      %%
      state = this.getWalkerStateObjectFromVector(state);
      
      state.setQsUsAndTrigInCurrentFunction();
      this.setWalkerParamsInCurrentFunction();
      
      if (this.alwaysInFlightPhase)
        C = []; %constraintJacobianStanceFootRolling;
        CDot = []; %constraintJacobianStanceFootRollingDot;
        return;
      end
      
      switch mode
        
        case 'stanceFootRolling'
          
          constraintJacobianStanceFootRolling(3, 8) = 0;
          constraintJacobianStanceFootRollingDot(3, 8) = 0;
          
          
          
          
          constraintJacobianStanceFootRolling(1,1) = 0; ...
            constraintJacobianStanceFootRolling(1,2) = 1; ...
            constraintJacobianStanceFootRolling(1,3) = 0; ...
            constraintJacobianStanceFootRolling(1,4) = 0; ...
            constraintJacobianStanceFootRolling(1,5) = 0; ...
            constraintJacobianStanceFootRolling(1,6) = 0; ...
            constraintJacobianStanceFootRolling(1,7) = 0; ...
            constraintJacobianStanceFootRolling(1,8) = 0;
          constraintJacobianStanceFootRolling(2,1) = 0; ...
            constraintJacobianStanceFootRolling(2,2) = 0; ...
            constraintJacobianStanceFootRolling(2,3) = 1; ...
            constraintJacobianStanceFootRolling(2,4) = 0; ...
            constraintJacobianStanceFootRolling(2,5) = 0; ...
            constraintJacobianStanceFootRolling(2,6) = 0; ...
            constraintJacobianStanceFootRolling(2,7) = 0; ...
            constraintJacobianStanceFootRolling(2,8) = 0;
          constraintJacobianStanceFootRolling(3,1) = 1; ...
            constraintJacobianStanceFootRolling(3,2) = 0; ...
            constraintJacobianStanceFootRolling(3,3) = 0; ...
            constraintJacobianStanceFootRolling(3,4) = -R; ...
            constraintJacobianStanceFootRolling(3,5) = 0; ...
            constraintJacobianStanceFootRolling(3,6) = 0; ...
            constraintJacobianStanceFootRolling(3,7) = 0; ...
            constraintJacobianStanceFootRolling(3,8) = 0;
          
          
          constraintJacobianStanceFootRollingDot(1,1) = 0; ...
            constraintJacobianStanceFootRollingDot(1,2) = 0; ...
            constraintJacobianStanceFootRollingDot(1,3) = 0; ...
            constraintJacobianStanceFootRollingDot(1,4) = 0; ...
            constraintJacobianStanceFootRollingDot(1,5) = 0; ...
            constraintJacobianStanceFootRollingDot(1,6) = 0; ...
            constraintJacobianStanceFootRollingDot(1,7) = 0; ...
            constraintJacobianStanceFootRollingDot(1,8) = 0;
          constraintJacobianStanceFootRollingDot(2,1) = 0; ...
            constraintJacobianStanceFootRollingDot(2,2) = 0; ...
            constraintJacobianStanceFootRollingDot(2,3) = 0; ...
            constraintJacobianStanceFootRollingDot(2,4) = 0; ...
            constraintJacobianStanceFootRollingDot(2,5) = 0; ...
            constraintJacobianStanceFootRollingDot(2,6) = 0; ...
            constraintJacobianStanceFootRollingDot(2,7) = 0; ...
            constraintJacobianStanceFootRollingDot(2,8) = 0;
          constraintJacobianStanceFootRollingDot(3,1) = 0; ...
            constraintJacobianStanceFootRollingDot(3,2) = 0; ...
            constraintJacobianStanceFootRollingDot(3,3) = 0; ...
            constraintJacobianStanceFootRollingDot(3,4) = 0; ...
            constraintJacobianStanceFootRollingDot(3,5) = 0; ...
            constraintJacobianStanceFootRollingDot(3,6) = 0; ...
            constraintJacobianStanceFootRollingDot(3,7) = 0; ...
            constraintJacobianStanceFootRollingDot(3,8) = 0;
          
          
          
          C = constraintJacobianStanceFootRolling;
          CDot = constraintJacobianStanceFootRollingDot;
          
        otherwise
          error('unknown mode for walker: %s', mode);
      end
      
    end
    
    function [energies] = getEnergyOfState(this, state)
      %%
      state = this.getWalkerStateObjectFromVector(state);
      
      state.setQsUsAndTrigInCurrentFunction();
      this.setWalkerParamsInCurrentFunction();
      
      
      energies.PE = (KSwing*((-q5 + q7)*(-q5 + q7)))/2. + (g*(-2*(-(c8*s4*s7) + ...
        c4*(-(s5*(c7*c8*s6 + c6*s8)) + c5*(c6*c7*c8 - ...
        s6*s8)))*legMassVerticalOffset*MLeg*cos(groundAngle) + 2*q3*(2*MLeg + ...
        MPelvis)*cos(groundAngle) - c4*s5p6*(2*MLeg + ...
        MPelvis)*pelvisWidth*cos(groundAngle) - 2*c5*(legMassVerticalOffset*MLeg - ...
        L*(2*MLeg + MPelvis) + (2*MLeg + MPelvis)*R)*cos(q4 + groundAngle) + ...
        2*(c4*c8*s7 + s4*(-(s5*(c7*c8*s6 + c6*s8)) + c5*(c6*c7*c8 - ...
        s6*s8)))*legMassVerticalOffset*MLeg*sin(groundAngle) - 2*q1*(2*MLeg + ...
        MPelvis)*sin(groundAngle) + s4*s5p6*(2*MLeg + ...
        MPelvis)*pelvisWidth*sin(groundAngle)))/2.;
      
      energies.PEGravity = (g*(-2*(-(c8*s4*s7) + c4*(-(s5*(c7*c8*s6 + c6*s8)) + ...
        c5*(c6*c7*c8 - s6*s8)))*legMassVerticalOffset*MLeg*cos(groundAngle) + ...
        2*q3*(2*MLeg + MPelvis)*cos(groundAngle) - c4*s5p6*(2*MLeg + ...
        MPelvis)*pelvisWidth*cos(groundAngle) - 2*c5*(legMassVerticalOffset*MLeg - ...
        L*(2*MLeg + MPelvis) + (2*MLeg + MPelvis)*R)*cos(q4 + groundAngle) + ...
        2*(c4*c8*s7 + s4*(-(s5*(c7*c8*s6 + c6*s8)) + c5*(c6*c7*c8 - ...
        s6*s8)))*legMassVerticalOffset*MLeg*sin(groundAngle) - 2*q1*(2*MLeg + ...
        MPelvis)*sin(groundAngle) + s4*s5p6*(2*MLeg + ...
        MPelvis)*pelvisWidth*sin(groundAngle)))/2.;
      
      energies.PESpring = (KSwing*((-q5 + q7)*(-q5 + q7)))/2.;
      
      energies.KE = (MLeg*((-(s5*u2) + c5*(s4*u1 + c4*u3))*(-(s5*u2) + c5*(s4*u1 + ...
        c4*u3)) + (c4*u1 - s4*u3 + c5*u4*(L - legMassVerticalOffset - R))*(c4*u1 - ...
        s4*u3 + c5*u4*(L - legMassVerticalOffset - R)) + (c5*u2 + s5*(s4*u1 + c4*u3) ...
        - u5*(L - legMassVerticalOffset - R))*(c5*u2 + s5*(s4*u1 + c4*u3) - u5*(L - ...
        legMassVerticalOffset - R))) + MPelvis*((c4*u1 - s4*u3 + ...
        (u4*(-(s5p6*pelvisWidth) + 2*c5*(L - R)))/2.)*(c4*u1 - s4*u3 + ...
        (u4*(-(s5p6*pelvisWidth) + 2*c5*(L - R)))/2.) + (s4*s5p6*u1 + c5p6*u2 + ...
        c4*s5p6*u3 - c6*u5*L + c6*u5*R)*(s4*s5p6*u1 + c5p6*u2 + c4*s5p6*u3 - c6*u5*L ...
        + c6*u5*R) + (c5p6*s4*u1 - s5p6*u2 + c4*c5p6*u3 + s6*u5*L - ...
        (u5*pelvisWidth)/2. - (u6*pelvisWidth)/2. - s6*u5*R)*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5p6*u3 + s6*u5*L - (u5*pelvisWidth)/2. - (u6*pelvisWidth)/2. - s6*u5*R)) ...
        + MLeg*((-(((-(s5*(c8*s6 + c6*c7*s8)) + c5*(c6*c8 - c7*s6*s8))*u4 + s7*s8*(u5 ...
        + u6) + c8*u7)*legMassVerticalOffset) + c7*(c4*u1 - s4*u3 + ...
        u4*(-(s5p6*pelvisWidth) + c5*(L - R))) - s7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5p6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - ...
        s6*u5*R))*(-(((-(s5*(c8*s6 + c6*c7*s8)) + c5*(c6*c8 - c7*s6*s8))*u4 + ...
        s7*s8*(u5 + u6) + c8*u7)*legMassVerticalOffset) + c7*(c4*u1 - s4*u3 + ...
        u4*(-(s5p6*pelvisWidth) + c5*(L - R))) - s7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5p6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - s6*u5*R)) + ...
        (-(s8*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + c6*u5*R)) ...
        + c8*(s7*(c4*u1 - s4*u3 + u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + ...
        c7*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - ...
        u5*pelvisWidth - u6*pelvisWidth - s6*u5*R)))*(-(s8*(s4*s5p6*u1 + c5p6*u2 + ...
        c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + c6*u5*R)) + c8*(s7*(c4*u1 - s4*u3 + ...
        u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + c7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - ...
        s6*u5*R))) + ((s5p6*s7*u4 + c7*(u5 + u6) + u8)*legMassVerticalOffset + ...
        c8*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + c6*u5*R) + ...
        s8*(s7*(c4*u1 - s4*u3 + u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + ...
        c7*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - ...
        u5*pelvisWidth - u6*pelvisWidth - s6*u5*R)))*((s5p6*s7*u4 + c7*(u5 + u6) + ...
        u8)*legMassVerticalOffset + c8*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + ...
        c4*c5*s6*u3 - c6*u5*L + c6*u5*R) + s8*(s7*(c4*u1 - s4*u3 + ...
        u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + c7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - ...
        s6*u5*R)))))/2. + (2*u4*(2*s5p6*s7*u8*ILeg + 2*c8*s7*(c6*(c7*c8*s5 + c5*s8) + ...
        s6*(c5*c7*c8 - s5*s8))*u5*(ILeg - ILegSmall) + 2*c8*s7*(c6*(c7*c8*s5 + c5*s8) ...
        + s6*(c5*c7*c8 - s5*s8))*u6*(ILeg - ILegSmall) + 2*c5*c6*u7*ILeg*(c8*c8) - ...
        2*s5*s6*u7*ILeg*(c8*c8) + 2*c5*c6*u7*ILegSmall*(s8*s8) - ...
        2*s5*s6*u7*ILegSmall*(s8*s8) - c6*c7*s5*u7*ILeg*sin(2*q8) - ...
        c5*c7*s6*u7*ILeg*sin(2*q8) + c6*c7*s5*u7*ILegSmall*sin(2*q8) + ...
        c5*c7*s6*u7*ILegSmall*sin(2*q8)) + 2*((ILeg + IPelvisX + ILeg*(c7*c7) + ...
        ILegSmall*(c8*c8)*(s7*s7) + ILeg*(s7*s7)*(s8*s8))*(u5*u5) + (IPelvisX + ...
        ILeg*(c7*c7) + ILegSmall*(c8*c8)*(s7*s7) + ILeg*(s7*s7)*(s8*s8))*(u6*u6) + ...
        ILeg*(c8*c8)*(u7*u7) + ILegSmall*(s8*s8)*(u7*u7) + ILeg*(u8*u8) + ...
        u6*(2*c7*u8*ILeg + s7*u7*(ILeg - ILegSmall)*sin(2*q8)) + u5*(2*c7*u8*ILeg + ...
        2*u6*(IPelvisX + ILeg*(c7*c7) + ILegSmall*(c8*c8)*(s7*s7) + ...
        ILeg*(s7*s7)*(s8*s8)) + s7*u7*(ILeg - ILegSmall)*sin(2*q8))) + ...
        u4*u4*(2*IPelvisY*(c5p6*c5p6) + 2*ILegSmall*(s5*s5) + ...
        2*ILegSmall*(c6*c6)*(c7*c7)*(c8*c8)*(s5*s5) + 2*IPelvisZ*(s5p6*s5p6) + ...
        2*ILeg*(c8*c8)*(s5*s5)*(s6*s6) + 2*ILeg*(s5p6*s5p6)*(s7*s7) + ...
        2*ILeg*(c6*c6)*(c7*c7)*(s5*s5)*(s8*s8) + 2*ILegSmall*(s5*s5)*(s6*s6)*(s8*s8) ...
        - ILeg*(c8*c8)*sin(2*q5)*sin(2*q6) + ...
        ILegSmall*(c7*c7)*(c8*c8)*sin(2*q5)*sin(2*q6) - ...
        ILegSmall*(s8*s8)*sin(2*q5)*sin(2*q6) + ...
        ILeg*(c7*c7)*(s8*s8)*sin(2*q5)*sin(2*q6) - ...
        c7*ILeg*(c6*c6)*sin(2*q5)*sin(2*q8) + ...
        c7*ILegSmall*(c6*c6)*sin(2*q5)*sin(2*q8) + ...
        c7*ILeg*(s6*s6)*sin(2*q5)*sin(2*q8) - ...
        c7*ILegSmall*(s6*s6)*sin(2*q5)*sin(2*q8) + ...
        c7*ILeg*(s5*s5)*sin(2*q6)*sin(2*q8) - ...
        c7*ILegSmall*(s5*s5)*sin(2*q6)*sin(2*q8) + c5*c5*(2*ILeg - (-ILeg - ILegSmall ...
        + (ILeg - ILegSmall)*cos(2*q8))*(c7*c7)*(s6*s6) + 2*(c6*c6)*(ILeg*(c8*c8) + ...
        ILegSmall*(s8*s8)) - c7*(ILeg - ILegSmall)*sin(2*q6)*sin(2*q8))))/4.;
      
      energies.KERotational = (2*u4*(2*s5p6*s7*u8*ILeg + 2*c8*s7*(c6*(c7*c8*s5 + ...
        c5*s8) + s6*(c5*c7*c8 - s5*s8))*u5*(ILeg - ILegSmall) + 2*c8*s7*(c6*(c7*c8*s5 ...
        + c5*s8) + s6*(c5*c7*c8 - s5*s8))*u6*(ILeg - ILegSmall) + ...
        2*c5*c6*u7*ILeg*(c8*c8) - 2*s5*s6*u7*ILeg*(c8*c8) + ...
        2*c5*c6*u7*ILegSmall*(s8*s8) - 2*s5*s6*u7*ILegSmall*(s8*s8) - ...
        c6*c7*s5*u7*ILeg*sin(2*q8) - c5*c7*s6*u7*ILeg*sin(2*q8) + ...
        c6*c7*s5*u7*ILegSmall*sin(2*q8) + c5*c7*s6*u7*ILegSmall*sin(2*q8)) + 2*((ILeg ...
        + IPelvisX + ILeg*(c7*c7) + ILegSmall*(c8*c8)*(s7*s7) + ...
        ILeg*(s7*s7)*(s8*s8))*(u5*u5) + (IPelvisX + ILeg*(c7*c7) + ...
        ILegSmall*(c8*c8)*(s7*s7) + ILeg*(s7*s7)*(s8*s8))*(u6*u6) + ...
        ILeg*(c8*c8)*(u7*u7) + ILegSmall*(s8*s8)*(u7*u7) + ILeg*(u8*u8) + ...
        u6*(2*c7*u8*ILeg + s7*u7*(ILeg - ILegSmall)*sin(2*q8)) + u5*(2*c7*u8*ILeg + ...
        2*u6*(IPelvisX + ILeg*(c7*c7) + ILegSmall*(c8*c8)*(s7*s7) + ...
        ILeg*(s7*s7)*(s8*s8)) + s7*u7*(ILeg - ILegSmall)*sin(2*q8))) + ...
        u4*u4*(2*IPelvisY*(c5p6*c5p6) + 2*ILegSmall*(s5*s5) + ...
        2*ILegSmall*(c6*c6)*(c7*c7)*(c8*c8)*(s5*s5) + 2*IPelvisZ*(s5p6*s5p6) + ...
        2*ILeg*(c8*c8)*(s5*s5)*(s6*s6) + 2*ILeg*(s5p6*s5p6)*(s7*s7) + ...
        2*ILeg*(c6*c6)*(c7*c7)*(s5*s5)*(s8*s8) + 2*ILegSmall*(s5*s5)*(s6*s6)*(s8*s8) ...
        - ILeg*(c8*c8)*sin(2*q5)*sin(2*q6) + ...
        ILegSmall*(c7*c7)*(c8*c8)*sin(2*q5)*sin(2*q6) - ...
        ILegSmall*(s8*s8)*sin(2*q5)*sin(2*q6) + ...
        ILeg*(c7*c7)*(s8*s8)*sin(2*q5)*sin(2*q6) - ...
        c7*ILeg*(c6*c6)*sin(2*q5)*sin(2*q8) + ...
        c7*ILegSmall*(c6*c6)*sin(2*q5)*sin(2*q8) + ...
        c7*ILeg*(s6*s6)*sin(2*q5)*sin(2*q8) - ...
        c7*ILegSmall*(s6*s6)*sin(2*q5)*sin(2*q8) + ...
        c7*ILeg*(s5*s5)*sin(2*q6)*sin(2*q8) - ...
        c7*ILegSmall*(s5*s5)*sin(2*q6)*sin(2*q8) + c5*c5*(2*ILeg - (-ILeg - ILegSmall ...
        + (ILeg - ILegSmall)*cos(2*q8))*(c7*c7)*(s6*s6) + 2*(c6*c6)*(ILeg*(c8*c8) + ...
        ILegSmall*(s8*s8)) - c7*(ILeg - ILegSmall)*sin(2*q6)*sin(2*q8))))/4.;
      
      energies.KELinear = (MLeg*((-(s5*u2) + c5*(s4*u1 + c4*u3))*(-(s5*u2) + ...
        c5*(s4*u1 + c4*u3)) + (c4*u1 - s4*u3 + c5*u4*(L - legMassVerticalOffset - ...
        R))*(c4*u1 - s4*u3 + c5*u4*(L - legMassVerticalOffset - R)) + (c5*u2 + ...
        s5*(s4*u1 + c4*u3) - u5*(L - legMassVerticalOffset - R))*(c5*u2 + s5*(s4*u1 + ...
        c4*u3) - u5*(L - legMassVerticalOffset - R))) + MPelvis*((c4*u1 - s4*u3 + ...
        (u4*(-(s5p6*pelvisWidth) + 2*c5*(L - R)))/2.)*(c4*u1 - s4*u3 + ...
        (u4*(-(s5p6*pelvisWidth) + 2*c5*(L - R)))/2.) + (s4*s5p6*u1 + c5p6*u2 + ...
        c4*s5p6*u3 - c6*u5*L + c6*u5*R)*(s4*s5p6*u1 + c5p6*u2 + c4*s5p6*u3 - c6*u5*L ...
        + c6*u5*R) + (c5p6*s4*u1 - s5p6*u2 + c4*c5p6*u3 + s6*u5*L - ...
        (u5*pelvisWidth)/2. - (u6*pelvisWidth)/2. - s6*u5*R)*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5p6*u3 + s6*u5*L - (u5*pelvisWidth)/2. - (u6*pelvisWidth)/2. - s6*u5*R)) ...
        + MLeg*((-(((-(s5*(c8*s6 + c6*c7*s8)) + c5*(c6*c8 - c7*s6*s8))*u4 + s7*s8*(u5 ...
        + u6) + c8*u7)*legMassVerticalOffset) + c7*(c4*u1 - s4*u3 + ...
        u4*(-(s5p6*pelvisWidth) + c5*(L - R))) - s7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5p6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - ...
        s6*u5*R))*(-(((-(s5*(c8*s6 + c6*c7*s8)) + c5*(c6*c8 - c7*s6*s8))*u4 + ...
        s7*s8*(u5 + u6) + c8*u7)*legMassVerticalOffset) + c7*(c4*u1 - s4*u3 + ...
        u4*(-(s5p6*pelvisWidth) + c5*(L - R))) - s7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5p6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - s6*u5*R)) + ...
        (-(s8*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + c6*u5*R)) ...
        + c8*(s7*(c4*u1 - s4*u3 + u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + ...
        c7*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - ...
        u5*pelvisWidth - u6*pelvisWidth - s6*u5*R)))*(-(s8*(s4*s5p6*u1 + c5p6*u2 + ...
        c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + c6*u5*R)) + c8*(s7*(c4*u1 - s4*u3 + ...
        u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + c7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - ...
        s6*u5*R))) + ((s5p6*s7*u4 + c7*(u5 + u6) + u8)*legMassVerticalOffset + ...
        c8*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + c4*c5*s6*u3 - c6*u5*L + c6*u5*R) + ...
        s8*(s7*(c4*u1 - s4*u3 + u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + ...
        c7*(c5p6*s4*u1 - s5p6*u2 + c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - ...
        u5*pelvisWidth - u6*pelvisWidth - s6*u5*R)))*((s5p6*s7*u4 + c7*(u5 + u6) + ...
        u8)*legMassVerticalOffset + c8*(s4*s5p6*u1 + c5p6*u2 + c4*c6*s5*u3 + ...
        c4*c5*s6*u3 - c6*u5*L + c6*u5*R) + s8*(s7*(c4*u1 - s4*u3 + ...
        u4*(-(s5p6*pelvisWidth) + c5*(L - R))) + c7*(c5p6*s4*u1 - s5p6*u2 + ...
        c4*c5*c6*u3 - c4*s5*s6*u3 + s6*u5*L - u5*pelvisWidth - u6*pelvisWidth - ...
        s6*u5*R)))))/2.;
      
      
      energies.total = energies.KE + energies.PE;
    end
    
  end
  
end


classdef ThreeDWalkerSplay < ThreeDWalker
  % ThreeDWalkerSplay
  
  % cop is found by setting finding the spot where "the forces cancel the
  % torques"
  
  properties
    
    ILegSmall = 0.003;
    stanceAnkleTorque = 0.0;
    extraSwingTorque = 0;
    
    alwaysInFlightPhase = 0; %1; %
    KSwingRoll = 0.0;
  end
  
  methods (Static)
    
    
    function [] = test()
      format compact;
      ThreeDWalkerSplay.testEnergy();
      %       ThreeDWalkerSplay.testSwitchingLegs();
      %       ThreeDWalkerSplay.testFindLimitCycle();
      %       ThreeDWalkerSplay.renderTestVideo();
    end
    
    function [] = renderTestVideo()
      %%
      set(0, 'DefaultFigureRenderer', 'OpenGL'); %'zbuffer'); %'zbuffer'); %
      opengl software;
      
      aviWriter = VideoWriter('test.avi');
      aviWriter.FrameRate = 30;
      open(aviWriter);
      
      walker = ThreeDWalkerSplay();
      limitCycleHipRollWalker = ThreeDWalkerSplayState([0.000000000000000  -0.000000000000000   1.000000000000000   0.092782839469035  -0.332422165389413 ...
        -0.050771981351022   0.363939245170571  -0.137939942205706   0.441917526331963  -0.085969598806670 ...
        0.095554796329744  -0.757883683880587   0.480711208135867   0.801777232517588   0.249007236095320 ...
        0.843764731844449]');
      walker.groundAngle = 0.096686630828179;
      walker.KSwing = 0.165721074223436;

      stepsToPlot = 1;
      walker.walkNSteps(limitCycleHipRollWalker.getVector(), stepsToPlot, ...
        'interleaveAnimation', 1, 'aviWriter', aviWriter, 'shouldAntiAlias', 1);
      
      close(aviWriter);
      
    end
    
    
    function [] = testFindLimitCycle()
      %% check what happens at the end of a step:
      
      walker = ThreeDWalkerSplay();
      
      %       limitCycleSplayInitial = ThreeDWalkerSplayState([0 0 1.0000 0.2800   -0.3193   -0.2425    0.3383   -0.4035    0.4032   -0.0955    0.1396   -0.1496    0.4729    0.1873    0.3827    0.0484]');
      %       walker.groundAngle = 0.1113;
      %       walker.KSwing = 0.1098;
      
      limitCycleSplayInitial = ThreeDWalkerSplayState([0.000000000000000  -0.000000000000000   1.000000000000000   0.092782839469035  -0.332422165389413 ...
        -0.050771981351022   0.363939245170571  -0.137939942205706   0.441917526331963  -0.085969598806670 ...
        0.095554796329744  -0.757883683880587   0.480711208135867   0.801777232517588   0.249007236095320 ...
        0.843764731844449]');
      walker.groundAngle = 0.096686630828179;
      walker.KSwing = 0.165721074223436;
      
      
      limitCycleSplayInitial.pelvis
      limitCycleSplayInitial.stanceLeg
      limitCycleSplayInitial.swingLeg
      

      limitCycleSplayInitial.pelvis.roll = 0;
      limitCycleSplayInitial.pelvis.rollDot = -0.6;

      limitCycleSplayInitial.stanceLeg.roll = 0;

      limitCycleSplayInitial.swingLeg.roll = -0.1;
      limitCycleSplayInitial.swingLeg.rollDot = 0.5;

      
      
      [finalState, finalTime, allStates, allTimes, thisWalker] = walker.oneStep(limitCycleSplayInitial, 'interleaveAnimation', 0);
      finalState = finalState.getVector();
      
      [limitCycleSplayInitial.getVector() finalState]
      
      errorVector = finalState - limitCycleSplayInitial.getVector()
      
      
      figure
      walker.plot(limitCycleSplayInitial)
      walker.plot(finalState)
      
      
      %%
      
      figure;
      plot(allTimes, allStates(1:3, :)');
      hold on;
      plot(finalTime, finalState(1:3), 'ok');
      

      plot(allTimes, allStates(9:11, :)');
      hold on;
      plot(finalTime, finalState(9:11), 'ok');
      
      %%
      parametersToAlter = {'groundAngle', 'KSwing'}; %, 'KSwingRoll'};
      desiredSpeed = 0.4;
      desiredStepLength = 0.68;
      
      limitCycleSplayInitial = ThreeDWalkerSplayState([0.000000000000000  -0.000000000000000   1.000000000000000   0.092782839469035  -0.332422165389413 ...
        -0.050771981351022   0.363939245170571  -0.137939942205706   0.441917526331963  -0.085969598806670 ...
        0.095554796329744  -0.757883683880587   0.480711208135867   0.801777232517588   0.249007236095320 ...
        0.843764731844449]');
      walker.groundAngle = 0.096686630828179;
      walker.KSwing = 0.165721074223436;
      
      %       fprintf('finding limit cycle with speed = %g L / time, step length = %g\n', desiredSpeed, desiredStepLength);
      %       [limitCycleHipRollWalker, finalParameters, limitCycleError] = walker.findLimitCycle(limitCycleSplayInitial.getVector(), ...
      %         'parametersToAlter', parametersToAlter, ...); %
      %         'desiredSpeed', desiredSpeed, 'desiredStepLength', desiredStepLength);
      %       walker = walker.setParametersFromList(parametersToAlter, finalParameters);
      %
      %
      %       limitCycleHipRollWalker'
      %       finalParameters'
      
      
      limitCycleHipRollWalker = limitCycleSplayInitial;
      
      %%
      if (0)
        %       walker.pelvisWidth = -walker.pelvisWidth;
        [nextState, finalTime, allStates, allTimes, nextWalker] = walker.oneStep(limitCycleHipRollWalker, 'interleaveAnimation', 1);
        %       nextState = nextState.switchLegs();
        %       nextWalker = walker;
        [limitCycleHipRollWalker.getVector()'; nextState.getVector()']
        
        %
        [nextState2, finalTime, allStates, allTimes, nextWalker2] = walker.oneStep(nextState, 'interleaveAnimation', 1);
        [nextState.getVector()'; nextState2.getVector()']
      end
      
      %       finalParameters
      
      %       return
      
      %       finalParameters
      %       limitCycleHipRollWalker = limitCycleSplayInitial;
      
      %%
      thisState = ThreeDWalkerSplayState(limitCycleHipRollWalker);
      thisWalker = walker;
      %       thisWalker.pelvisWidth = -thisWalker.pelvisWidth;
      box off;
      
      stepsToPlot = 10;
      walker.walkNSteps(limitCycleHipRollWalker.getVector(), stepsToPlot, ...
        'interleaveAnimation', 1);
      
      %%
      
      %       for i = 1 : 10
      %         thisState.getVector()'
      %         thisWalker.pelvisWidth;
      %         oppositeStanceLeg = mod(i, 2) == 0;
      %         initialPelvisY = 0; %thisState.pelvis.y;
      %         [thisState, finalTime, allStates, allTimes, walkerNext] = thisWalker.oneStep(thisState, ...
      %           'interleaveAnimation', 1, ...
      %           'initialPelvisY', initialPelvisY, ...
      %           'plotLegsSwitched', oppositeStanceLeg);
      %         thisState.pelvis.y = -thisState.pelvis.y;
      %       end
    end
    
    function [] = testSwitchingLegs()
      %% check what happens at the end of a step:
      
      limitCycleSplayInitial = ThreeDWalkerSplayState([0 0 1.0000 0.2800   -0.3193   -0.2425    0.3383   -0.4035    0.4032   -0.0955    0.1396   -0.1496    0.4729    0.1873    0.3827    0.0484]');
      walker = ThreeDWalkerSplay();
      walker.groundAngle = 0.1113;
      walker.KSwing = 0.1098;
      
      %       figure;
      %       [nextState, finalTime, allStates, allTimes, walker2] = walker.oneStep(limitCycleSplayInitial.getVector(), 'interleaveAnimation', 1);
      %       %       walker.plot(nextState);
      %       figure;
      %       walker2.plot(nextState);
      %       [nextState2, finalTime, allStates, allTimes, walker3] = walker2.oneStep(nextState, 'interleaveAnimation', 1);
      
      thisState = limitCycleSplayInitial;
      thisWalker = walker;
      
      for i = 1 : 10
        thisState.getVector()'
        [thisState, finalTime, allStates, allTimes, thisWalker] = thisWalker.oneStep(thisState, 'interleaveAnimation', 1);
      end
      
      
    end
    
    function [] = testEnergy()
      %% test energy conservation during random falling
      
      % Initial conditions chosen by hand to give something that looks like a step, but isn't
      format compact;
      
      initialConditions = ThreeDWalkerSplayState();
      
      walker = ThreeDWalkerSplay();
      
      % walker.legMassVerticalOffset = 0;
      %       walker.MLeg = 1e-5;
      % walker.ILeg = 1e-5;
      % walker.KSwing = 0.0;
      walker.KSwing = 0.03;
      
      initialConditions.pelvis.xDot = 0.08;
      initialConditions.pelvis.yDot = -0.1;
      initialConditions.pelvis.zDot = 0.1;
      
      initialConditions.pelvis.roll = 0;
      initialConditions.pelvis.rollDot = -0.1;
      
      initialConditions.stanceLeg.roll = -0.08;
      initialConditions.stanceLeg.pitch = -0.08;
      initialConditions.stanceLeg.pitchDot = 0.03;
      
      initialConditions.swingLeg.roll = -0.2;
      initialConditions.swingLeg.pitch = 0.08;
      initialConditions.swingLeg.pitchDot = -0.3;
      
      
      %%
      figure
      walker.plot(initialConditions);
      initialConditionsSwitched = initialConditions.switchLegs(walker);
      
      figure
      walker.plot(initialConditionsSwitched);
      
      %       return;
      
      
      %%
      % ensure the velocities start consistent with the stance phase
      mode = 'stanceFootRolling';
      [qs, us] = walker.getQAndUIndeces();
      x = initialConditions.getVector();
      x = walker.modeTransition(0, x, mode);
      %       if (norm(walker.getConstraintMatrix(initialConditions, mode) * x(us)') > 1e-6)
      %         error('transition into constrained state failed!');
      %       end
      
      initialConditions = ThreeDWalkerSplayState(x);
      x = initialConditions.getVector();
      %       if (norm(walker.getConstraintMatrix(initialConditions, mode) * x(us)) > 1e-6)
      %         error('transition into constrained state failed after recreating state object (check constructor?)!');
      %       end
      
      ThreeDWalkerSplay.testEnergyConservation(walker, initialConditions);
      
      %%
      %       walker.groundAngle = 0.1329;
      %       walker.KSwing = 0.0632;
      %       limitCycleHipRollWalker =[ -0.0000   -0.0000    1.0000   -0.1616   -0.3811    0.1657    0.3297    0.1575    0.4117    0.0276    0.1690   -0.4373    0.4462    0.4373    0.2290 0.3716]';
      %
      %       ThreeDWalkerSplay.testEnergyConservation(walker, limitCycleHipRollWalker);
      
    end
    
    function [] = testEnergyConservation(walker, initialConditions)
      %%
      [finalState, finalTime, allStates, allTimes] = walker.oneStep(initialConditions.getVector(), ...
        'interleaveAnimation', 1);
      initiaEnergies = walker.getEnergyOfState(allStates(:, 1));
      for i = 1 : (size(allStates, 2) - 1)
        energies = walker.getEnergyOfState(allStates(:, i));
        energies.total
        if abs(energies.total - initiaEnergies.total) > 1e-4
          error('energy conservation failed');
        end
      end
    end
    
  end
  
  methods
    
    function [this] = ThreeDWalkerSplay(input)
      %%
      if (nargin == 0)
        input = [];
      end
      this = this@ThreeDWalker(input);
      
      if (isa(input, 'ThreeDWalkerSplay'))
        this.ILegSmall = input.ILegSmall;
      end
      
    end
    
    function [errVals] = getSwitchedLegsError(this, currentState, switchedState)
      [c, errVals] = this.getSwitchedLegsConstraints(currentState, switchedState);
      errVals = norm(errVals);
    end
    
    function [c, errVals] = getSwitchedLegsConstraints(this, currentState, switchedState)
      %%
      c = [];
      currentState = this.getWalkerStateObjectFromVector(currentState);
      switchedState = this.getWalkerStateObjectFromVector(switchedState);
      
      currentPoints = this.getKinematicPoints(currentState);
      currentPointVector = this.kinematicPointsToArray(currentPoints);
      
      switchedPoints = this.getKinematicPoints(switchedState);
      ...switchedPoints = this.reflectPointsLaterally(switchedPoints);
        
    switchedPointsTemp = switchedPoints;
    
    switchedPoints.stanceFootCenter = switchedPointsTemp.swingFootCenter;
    switchedPoints.swingFootCenter = switchedPointsTemp.stanceFootCenter;
    
    %       switchedPoints.stanceFootContactPoint = switchedPointsTemp.swingFootContactPoint;
    %       switchedPoints.swingFootContactPoint = switchedPointsTemp.stanceFootContactPoint;
    
    switchedPoints.stanceHipPoint = switchedPointsTemp.swingHipPoint;
    switchedPoints.swingHipPoint = switchedPointsTemp.stanceHipPoint;
    
    switchedPoints.stanceLeg = switchedPointsTemp.swingLeg;
    switchedPoints.swingLeg = switchedPointsTemp.stanceLeg;
    
    switchedPointVector = this.kinematicPointsToArray(switchedPoints);
    
    errVals = currentPointVector - switchedPointVector;
    %     reshape(errVals, 3, 7)
    norm(errVals);
    end
    
    function [points] = reflectPointsLaterally(this, points)
      %%
      pointFields = fieldnames(points);
      index.type = '()';
      index.subs = {2};
      for i = 1 : length(pointFields)
        v = points.(pointFields{i});
        if (isnumeric(v) && length(v) == 3)
          points.(pointFields{i}) = subsasgn(points.(pointFields{i}), index, -v(2));
        end
      end
    end
    
    function [pointVector] = kinematicPointsToArray(this, points)
      pointVector = [ ...
        ...points.pelvis.position, ...
        points.pelvis.velocity, ...(1:2)
        ...reshape(points.pelvis.R, [1, 9]), ...
        ...
        ...points.stanceLeg.position, ...
        points.stanceLeg.velocity, ...
        ...reshape(points.stanceLeg.R, [1, 9]), ...
        ...
        ...points.swingLeg.position, ...
        points.swingLeg.velocity, ...
        ...reshape(points.swingLeg.R, [1, 9]), ...
        ...
        points.stanceFootCenter, ...
        points.swingFootCenter, ...
        ...
        ...points.stanceFootContactPoint, ...
        ...points.swingFootContactPoint, ...
        ...
        points.stanceHipPoint, ... x coordinate here is messed up (2:3)
        points.swingHipPoint, ...
        ...
        ...points.comVelocity, ...
        ...
        ...points.centerOfMassPosition
        ];
    end
    
    function [newState] = findSwitchedWalkerState(this, stateOriginal)
      %%
      state = this.getWalkerStateObjectFromVector(stateOriginal);
      %       initialGuess = randn(size(state.getVector())) * 0.01;
      
      %       state.stanceLeg.roll = state.stanceLeg.roll + pi;
      %       state.swingLeg.roll = state.swingLeg.roll + pi;
      initialGuess = state.getVector();
      %       figure
      %       this.plot(initialGuess)
      %       initialGuess
      
      %%
      
      tic
      options = optimset('algorithm', 'sqp', 'MaxFunEvals', 1e4);
      newState = fmincon(@(x) 0, initialGuess, [], [], [], [], [], [], @(x) this.getSwitchedLegsConstraints(stateOriginal, x), options);
      newState = fmincon(@(x) 0, newState, [], [], [], [], [], [], @(x) this.getSwitchedLegsConstraints(stateOriginal, x), options);
      
      %       newState = fminunc(@(x) this.getSwitchedLegsError(stateOriginal, x), initialGuess, options);
      toc
      
      newPoints = this.getKinematicPoints(this.getWalkerStateObjectFromVector(newState));
    end
    
    function [value, isTerminal, direction] = fellOrSwingFootTouchdown(this, t, state)
      %%
      if (this.alwaysInFlightPhase)
        value = 1;
        isTerminal = 0;
        direction = 1;
      else
        [value, isTerminal, direction] = fellOrSwingFootTouchdown@ThreeDWalker(this, t, state);
      end
    end
    
    function [value, isTerminal, direction] = fellOrStanceFootTouchdown(this, t, state)
      %%
      if (this.alwaysInFlightPhase)
        value = 1;
        isTerminal = 0;
        direction = 1;
      else
        [value, isTerminal, direction] = fellOrStanceFootTouchdown@ThreeDWalker(this, t, state);
      end
    end
    
    function [state] = getWalkerStateObjectFromVector(this, stateVector)
      %%
      state = ThreeDWalkerSplayState(stateVector);
    end
    
    function [states] = walkNSteps(this, initialState, N, varargin)
      %%
      interleaveAnimation = 0;
      doneFunction = @(x) 0;
      for i = 1 : 2 : length(varargin)
        option = varargin{i};
        value = varargin{i + 1};
        switch option
          case 'interleaveAnimation'
            interleaveAnimation = value;
          case 'doneFunction'
            doneFunction = value;
        end
      end
      
      states = initialState;
      
      [nextState, finalTime, allStates, allTimes, this2] = this.oneStep(initialState, 'interleaveAnimation', interleaveAnimation, ...
        'plotLegsSwitched', 0, varargin{:});
      nextState.pelvis.y = -nextState.pelvis.y;
      
      states = [states nextState.getVector()];
      
      i = 2;
      while i <= N
        [nextState, finalTime, allStates, allTimes, this2] = this.oneStep(nextState, 'interleaveAnimation', interleaveAnimation, ...
          'plotLegsSwitched', 1, ...
          varargin{:});
        nextState.pelvis.y = -nextState.pelvis.y;
        states = [states nextState.getVector()];
        i = i + 1;
        if (i > N)
          break;
        end
        if (doneFunction(nextState))
          break;
        end
        
        [nextState, finalTime, allStates, allTimes, this2] = this.oneStep(nextState, 'interleaveAnimation', interleaveAnimation, ...
          'plotLegsSwitched', 0, ...
          varargin{:});
        nextState.pelvis.y = -nextState.pelvis.y;
        states = [states nextState.getVector()];
        i = i + 1;
        if (i > N)
          break;
        end

        if (doneFunction(nextState))
          break;
        end
      end
    end
    
    %     function [finalState, finalTime, allStates, allTimes] = oneStep(this, initialState, varargin)
    %       %%
    %       initialState = this.getWalkerStateObjectFromVector(initialState);
    %       splayError = initialState.stanceLeg.roll + initialState.swingLeg.roll;
    %       if abs(splayError) > 1e-3
    %         %         fprintf('warning, initial state doesn''t satisify splay angle equality constraint, error = %g\n', splayError);
    %       end
    %       initialState = initialState.getVector();
    %
    %       if (isempty(varargin))
    %         [finalState, finalTime, allStates, allTimes] = ...
    %           oneStep@ThreeDWalker(this, initialState);
    %       else
    %         [finalState, finalTime, allStates, allTimes] = ...
    %           oneStep@ThreeDWalker(this, initialState, varargin{:});
    %       end
    %     end
    
    function [finalState, finalTime, allStates, allTimes, this, additionalOutputs] = ...
      oneStep(this, initialState, varargin)
      %%
      RelTol = 1e-6; %10; %
      AbsTol = 1e-6; %10; %
      tMax = 4; %5; %2; %6;
      dt = 1e-2;
      interleaveAnimation = 0; %1; %
      interleaveAnimationFrameskip = 2;
      plotLegsSwitched = 0;
      initialPelvisY = 0;
      additionalOutputCalculator = [];

      for i = 1 : 2 : length(varargin)
        option = varargin{i};
        value = varargin{i + 1};
        switch option
          case 'interleaveAnimation'
            interleaveAnimation = value;
          case 'interleaveAnimationFrameskip'
            interleaveAnimationFrameskip = value;
          case 'plotLegsSwitched'
            plotLegsSwitched = value;
          case 'tMax'
            tMax = value;
          case 'initialPelvisY'
            initialPelvisY = value;
          case 'additionalOutputCalculator'
            additionalOutputCalculator = value;
        end
      end
      
      additionalOutputs = [];
      allModes = {...
        'stanceFootRolling', ...
        'swingFootRolling'};
      modeNumber = 1;
      
      initialState = this.getWalkerStateObjectFromVector(initialState);
      
      %% Ensure initial state is in the desired initial mode:
      initialState = this.modeTransition(0, initialState.getVector(), allModes{modeNumber});
      initialState = this.getWalkerStateObjectFromVector(initialState);
      
      tStart = 0;
      allTimes = tStart;
      allStates = initialState.getVector();
      allPhases = [modeNumber];
      
      %% simulate continuous mode:
      mode = allModes{modeNumber};
      
      options = odeset('Events', @(t, x) this.fellOrSwingFootTouchdown(t, x), ...
        'RelTol', RelTol, 'AbsTol', AbsTol);
      %       options = odeset('RelTol', RelTol, 'AbsTol', AbsTol);
      
      
      [t, newStates] = ode45(@(t, x) this.stateDerivative(t, x, mode), ...
        tStart : dt : tMax, ...
        initialState.getVector(), ....
        options);
      
      %       [t, newStates] = ode23t(@(t, x) this.stateDerivative(t, x, mode), ...
      %         tStart : dt : tMax, ...
      %         initialState.getVector(), ....
      %         options);
      
      tEnd = t(end);
      initialState = initialState.setFromVector(newStates(end, :)');
      allTimes = [allTimes t'];
      allStates = [allStates newStates'];
      allPhases = [allPhases; ones(length(t),1) * modeNumber];
      tStart = tEnd;
      
      %       initialPelvisY = initialState.pelvis.y;
      if (interleaveAnimation)
        for i = 1 : interleaveAnimationFrameskip : size(newStates, 1)
          cla;
          thisState = initialState.setFromVector(newStates(i, :));
          this.plot(thisState, 'plotLegsSwitched', plotLegsSwitched, 'initialPelvisY', initialPelvisY, ...
            varargin{:});
          title(sprintf('in mode %s', mode));
          pause(0.001);
        end
      end
      
      %%
      if (~isempty(additionalOutputCalculator))
        state = allStates(1, :);
        try
          theseOutputs = additionalOutputCalculator(state);
        catch e
          e
        end
        fields = fieldnames(theseOutputs);
        
        for j = 1 : length(fields)
          additionalOutputs.(fields{j}) = []; %zeros(1, size(allStates, 2));
        end
        
        subs.type = '()';
        for i = 1 : size(allStates, 2)
          state = allStates(:, i);
          theseOutputs = additionalOutputCalculator(state);
          
          subs.subs = {[i]};
          
          for j = 1 : length(fields)
            %             additionalOutputs.(fields{j}) = theseOutputs.(fields{j});
            %             subsasgn(additionalOutputs.(fields{j}), subs, theseOutputs.(fields{j}));
            additionalOutputs.(fields{j}) = ...
              [additionalOutputs.(fields{j}) theseOutputs.(fields{j})];
          end
          %           ();
          
        end
      end
      
      %%
      finalTime = tEnd;
      if (tMax - tEnd) <= dt % || (~isConsistent && checkStatesForConsistency)
        fprintf('Walker ends simulation in %s\n',  mode);
        finalState = initialState;
        return;
      end
      
      
      %       %% transfer to swingFootRolling
      %       modeNumber = 2;
      %
      %       mode = allModes{modeNumber};
      %       initialState = this.modeTransition(0, initialState.getVector(), mode);
      %       initialState = this.getWalkerStateObjectFromVector(initialState);
      %
      %       tStart = 0;
      %       allTimes = tStart;
      %       allStates = initialState.getVector();
      %       allPhases = [modeNumber];
      %
      %       %% simulate continuous swingFootRolling mode:
      %
      %       options = odeset('Events', @(t, x) this.fellOrStanceFootTouchdown(t, x), ...
      %         'RelTol', RelTol, 'AbsTol', AbsTol);
      %
      %       [t, newStates] = ode45(@(t, x) this.stateDerivative(t, x, mode), ...
      %         tStart : dt : tMax, ...
      %         initialState.getVector(), ....
      %         options);
      %
      %       tEnd = t(end);
      %       initialState = initialState.setFromVector(newStates(end, :)');
      %       allTimes = [allTimes t'];
      %       allStates = [allStates newStates'];
      %       allPhases = [allPhases; ones(length(t),1) * modeNumber];
      %       tStart = tEnd;
      %
      %       if (interleaveAnimation)
      %         for i = 1 : interleaveAnimationFrameskip : size(newStates, 1)
      %           cla;
      %           thisState = initialState.setFromVector(newStates(i, :));
      %           this.plot(thisState);
      %           title(sprintf('in mode %s', mode));
      %           pause(0.01);
      %         end
      %       end
      %
      %       finalTime = tEnd;
      %       if (tMax - tEnd) <= dt % || (~isConsistent && checkStatesForConsistency)
      %         fprintf('Walker ends simulation in %s\n',  mode);
      %         finalState = initialState;
      %         return;
      %       end
      
      %% switch states for next step
      modeNumber = 1;
      
      mode = allModes{modeNumber};
      initialState = initialState.switchLegs(this);
      this.pelvisWidth = -this.pelvisWidth;
      finalState = this.getWalkerStateObjectFromVector(this.modeTransition(finalTime, initialState.getVector(), mode));
    end
    
    
    function [c, ceq] = limitCycleConstraintsOnInitialPositionAndSplayAngle(this, xInitial, xFinal)
      %%
      [c, ceq] = this.limitCycleConstraintsOnInitialPosition(xInitial, xFinal);
      
      xInitial = this.getWalkerStateObjectFromVector(xInitial);
      
      %       c = [c -xInitial.stanceLeg.roll];
      
      %       ceq = [ceq; ...
      %         xInitial.stanceLeg.roll + xInitial.swingLeg.roll; ...
      %         xInitial.stanceLeg.rollDot + xInitial.swingLeg.rollDot; ...
      %         ];
    end
    
    function [initialCondition, limitCycleError, ...
        extraInequalityConstraintError, extraEqualityConstraintErrors] = findLimitCycle(this, initialConditionGuess, varargin)
      %% gets a limit cycle for a 3d walker, uses Walker.findLimitCycle, ignoring appropriate dofs (pelvis x and y),
      % and adds a constaint on the otherwise free initial position of the
      % pelvis to (0, 0, 1). Takes all of the same optional arguments as
      % Walker.findLimitCycle, any args you specify take precedence over
      % the default ones generated by this function.
      
      varargin = [ ...
        {'additionalConstraintFunction', @(xInitial, xFinal) this.limitCycleConstraintsOnInitialPositionAndSplayAngle(xInitial, xFinal)}, ...
        varargin];
      
      [initialCondition, limitCycleError, ...
        extraInequalityConstraintError, extraEqualityConstraintErrors] = ...
        findLimitCycle@ThreeDWalker(this, initialConditionGuess, varargin{:});
    end
    
    function [qs, us] = getQAndUIndeces(this)
      %%
      qs = 1:8;
      us = 9:16;
    end
    
    function [] = setWalkerParamsInCurrentFunction(this)
      %%
      ws = 'caller';
      assignin(ws, 'L', this.L);
      assignin(ws, 'R', this.R);
      assignin(ws, 'MPelvis', this.MPelvis);
      assignin(ws, 'IPelvis', this.IPelvis);
      assignin(ws, 'pelvisWidth', this.pelvisWidth);
      assignin(ws, 'MLeg', this.MLeg);
      assignin(ws, 'ILeg', this.ILeg);
      assignin(ws, 'legMassVerticalOffset', this.legMassVerticalOffset);
      assignin(ws, 'legMassForwardOffset', this.legMassForwardOffset);
      assignin(ws, 'splayAngle', this.splayAngle);
      assignin(ws, 'g', this.g);
      assignin(ws, 'groundAngle', this.groundAngle);
      assignin(ws, 'KSwing', this.KSwing);
      assignin(ws, 'KSwingRoll', this.KSwingRoll);
      
      assignin(ws, 'lateralPelvisForce', this.lateralPelvisForce);
      
      assignin(ws, 'ILegSmall', this.ILegSmall);
      assignin(ws, 'stanceAnkleTorque', this.stanceAnkleTorque);
      assignin(ws, 'extraSwingTorque', this.extraSwingTorque);
    end
    
    function [points] = getKinematicPoints(this, state, uDot)
      %%
      state = this.getWalkerStateObjectFromVector(state);
      
      state.setQsUsAndTrigInCurrentFunction();
      this.setWalkerParamsInCurrentFunction();
      
      
      points.pelvis.position(1) = q1;
      points.pelvis.position(2) = q2;
      points.pelvis.position(3) = q3;
      
      
      points.pelvis.velocity(1) = u1;
      points.pelvis.velocity(2) = u2;
      points.pelvis.velocity(3) = u3;
      
      
      points.pelvis.R(1,1) = 1; points.pelvis.R(1,2) = 0; points.pelvis.R(1,3) = 0;
      points.pelvis.R(2,1) = 0; points.pelvis.R(2,2) = c4; points.pelvis.R(2,3) = ...
        -s4;
      points.pelvis.R(3,1) = 0; points.pelvis.R(3,2) = s4; points.pelvis.R(3,3) = ...
        c4;
      
      
      points.stanceLeg.position(1) = q1 - c6*s5*legMassVerticalOffset;
      points.stanceLeg.position(2) = q2 - (-(c5*c6*s4) - ...
        c4*s6)*legMassVerticalOffset + (c4*pelvisWidth)/2.;
      points.stanceLeg.position(3) = q3 - (c4*c5*c6 - s4*s6)*legMassVerticalOffset ...
        + (s4*pelvisWidth)/2.;
      
      
      points.stanceLeg.velocity(1) = u1 - c5*(s5*s6*u4 + ...
        c6*u5)*legMassVerticalOffset + s5*s6*(c5*u4 + u6)*legMassVerticalOffset;
      points.stanceLeg.velocity(2) = u2 + (c4*c6 - c5*s4*s6)*(c5*u4 + ...
        u6)*legMassVerticalOffset + s4*(-(s5*(s5*s6*u4 + ...
        c6*u5)*legMassVerticalOffset) - (u4*pelvisWidth)/2.);
      points.stanceLeg.velocity(3) = u3 + (c6*s4 + c4*c5*s6)*(c5*u4 + ...
        u6)*legMassVerticalOffset + c4*(s5*(s5*s6*u4 + c6*u5)*legMassVerticalOffset + ...
        (u4*pelvisWidth)/2.);
      
      
      points.stanceLeg.R(1,1) = c5; points.stanceLeg.R(1,2) = s5*s6; ...
        points.stanceLeg.R(1,3) = c6*s5;
      points.stanceLeg.R(2,1) = s4*s5; points.stanceLeg.R(2,2) = c4*c6 - c5*s4*s6; ...
        points.stanceLeg.R(2,3) = -(c5*c6*s4) - c4*s6;
      points.stanceLeg.R(3,1) = -(c4*s5); points.stanceLeg.R(3,2) = c6*s4 + ...
        c4*c5*s6; points.stanceLeg.R(3,3) = c4*c5*c6 - s4*s6;
      
      
      points.swingLeg.position(1) = q1 - c8*s7*legMassVerticalOffset;
      points.swingLeg.position(2) = q2 - (-(c7*c8*s4) - ...
        c4*s8)*legMassVerticalOffset - (c4*pelvisWidth)/2.;
      points.swingLeg.position(3) = q3 - (c4*c7*c8 - s4*s8)*legMassVerticalOffset - ...
        (s4*pelvisWidth)/2.;
      
      
      points.swingLeg.velocity(1) = u1 - c7*(s7*s8*u4 + ...
        c8*u7)*legMassVerticalOffset + s7*s8*(c7*u4 + u8)*legMassVerticalOffset;
      points.swingLeg.velocity(2) = u2 + (c4*c8 - c7*s4*s8)*(c7*u4 + ...
        u8)*legMassVerticalOffset + s4*(-(s7*(s7*s8*u4 + ...
        c8*u7)*legMassVerticalOffset) + (u4*pelvisWidth)/2.);
      points.swingLeg.velocity(3) = u3 + (c8*s4 + c4*c7*s8)*(c7*u4 + ...
        u8)*legMassVerticalOffset + c4*(s7*(s7*s8*u4 + c8*u7)*legMassVerticalOffset - ...
        (u4*pelvisWidth)/2.);
      
      
      points.swingLeg.R(1,1) = c7; points.swingLeg.R(1,2) = s7*s8; ...
        points.swingLeg.R(1,3) = c8*s7;
      points.swingLeg.R(2,1) = s4*s7; points.swingLeg.R(2,2) = c4*c8 - c7*s4*s8; ...
        points.swingLeg.R(2,3) = -(c7*c8*s4) - c4*s8;
      points.swingLeg.R(3,1) = -(c4*s7); points.swingLeg.R(3,2) = c8*s4 + c4*c7*s8; ...
        points.swingLeg.R(3,3) = c4*c7*c8 - s4*s8;
      
      
      points.stanceFootCenter(1) = q1 + c6*s5*(-1 + R);
      points.stanceFootCenter(2) = q2 + (c4*pelvisWidth)/2. + (-(c5*c6*s4) - ...
        c4*s6)*(-1 + R);
      points.stanceFootCenter(3) = q3 + (s4*pelvisWidth)/2. + (c4*c5*c6 - ...
        s4*s6)*(-1 + R);
      
      
      points.swingFootCenter(1) = q1 + c8*s7*(-1 + R);
      points.swingFootCenter(2) = q2 - (c4*pelvisWidth)/2. + (-(c7*c8*s4) - ...
        c4*s8)*(-1 + R);
      points.swingFootCenter(3) = q3 - (s4*pelvisWidth)/2. + (c4*c7*c8 - s4*s8)*(-1 ...
        + R);
      
      
      points.stanceFootContactPoint(1) = q1 + c6*s5*(-1 + R);
      points.stanceFootContactPoint(2) = q2 + (c4*pelvisWidth)/2. + (-(c5*c6*s4) - ...
        c4*s6)*(-1 + R);
      points.stanceFootContactPoint(3) = q3 + (s4*pelvisWidth)/2. + (c4*c5*c6 - ...
        s4*s6)*(-1 + R) - R;
      
      
      points.swingFootContactPoint(1) = q1 + c8*s7*(-1 + R);
      points.swingFootContactPoint(2) = q2 - (c4*pelvisWidth)/2. + (-(c7*c8*s4) - ...
        c4*s8)*(-1 + R);
      points.swingFootContactPoint(3) = q3 - (s4*pelvisWidth)/2. + (c4*c7*c8 - ...
        s4*s8)*(-1 + R) - R;
      
      
      points.stanceHipPoint(1) = q1;
      points.stanceHipPoint(2) = q2 + (c4*pelvisWidth)/2.;
      points.stanceHipPoint(3) = q3 + (s4*pelvisWidth)/2.;
      
      
      points.swingHipPoint(1) = q1;
      points.swingHipPoint(2) = q2 - (c4*pelvisWidth)/2.;
      points.swingHipPoint(3) = q3 - (s4*pelvisWidth)/2.;
      
      
      points.comVelocity(1) = u1 - c5*(s5*s6*u4 + ...
        c6*u5)*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1) + s5*s6*(c5*u4 + ...
        u6)*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1) - c7*(s7*s8*u4 + ...
        c8*u7)*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1) + s7*s8*(c7*u4 + ...
        u8)*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1);
      points.comVelocity(2) = u2 + (c4*c6 - c5*s4*s6)*(c5*u4 + ...
        u6)*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1) + (c4*c8 - ...
        c7*s4*s8)*(c7*u4 + u8)*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1) ...
        + s4*(-(s5*(s5*s6*u4 + c6*u5)*legMassVerticalOffset*MLeg*power(2*MLeg + ...
        MPelvis,-1)) - s7*(s7*s8*u4 + c8*u7)*legMassVerticalOffset*MLeg*power(2*MLeg ...
        + MPelvis,-1));
      points.comVelocity(3) = u3 + (c6*s4 + c4*c5*s6)*(c5*u4 + ...
        u6)*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1) + (c8*s4 + ...
        c4*c7*s8)*(c7*u4 + u8)*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1) ...
        + c4*(s5*(s5*s6*u4 + c6*u5)*legMassVerticalOffset*MLeg*power(2*MLeg + ...
        MPelvis,-1) + s7*(s7*s8*u4 + c8*u7)*legMassVerticalOffset*MLeg*power(2*MLeg + ...
        MPelvis,-1));
      
      
      points.centerOfMassPosition(1) = q1 - ...
        c6*s5*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1) - ...
        c8*s7*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1);
      points.centerOfMassPosition(2) = q2 - (-(c5*c6*s4) - ...
        c4*s6)*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1) - (-(c7*c8*s4) - ...
        c4*s8)*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1);
      points.centerOfMassPosition(3) = q3 - (c4*c5*c6 - ...
        s4*s6)*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1) - (c4*c7*c8 - ...
        s4*s8)*legMassVerticalOffset*MLeg*power(2*MLeg + MPelvis,-1);
      
      
      
      points.velStanceFootContactPoint(1) = u1 + c5*(s5*s6*u4 + c6*u5)*(-1 + R) - ...
        s5*s6*(c5*u4 + u6)*(-1 + R) - (c4*u5 + s4*s5*u6)*R;
      points.velStanceFootContactPoint(2) = u2 + s4*(-(u4*pelvisWidth)/2. + ...
        s5*(s5*s6*u4 + c6*u5)*(-1 + R)) - (c4*c6 - c5*s4*s6)*(c5*u4 + u6)*(-1 + R) + ...
        (u4 + c5*u6)*R;
      points.velStanceFootContactPoint(3) = u3 + c4*((u4*pelvisWidth)/2. - ...
        s5*(s5*s6*u4 + c6*u5)*(-1 + R)) - (c6*s4 + c4*c5*s6)*(c5*u4 + u6)*(-1 + R);
      
      
      
      if (nargin > 2)
        u1dot = uDot(1);
        u2dot = uDot(2);
        u3dot = uDot(3);
        u4dot = uDot(4);
        u5dot = uDot(5);
        u6dot = uDot(6);
        u7dot = uDot(7);
        u8dot = uDot(8);
        
        
        points.totalForceOnCOM(1) = u1dot*(2*MLeg + MPelvis) - ...
          c5*legMassVerticalOffset*MLeg*(s5*s6*u4dot + c6*u5dot + 2*c6*s5*u4*u6 - ...
          2*s6*u5*u6 + c5*c6*s5*(u4*u4)) - c7*legMassVerticalOffset*MLeg*(s7*s8*u4dot + ...
          c8*u7dot + 2*c8*s7*u4*u8 - 2*s8*u7*u8 + c7*c8*s7*(u4*u4)) + ...
          s5*(s6*legMassVerticalOffset*MLeg*(c5*u4dot + u6dot - 2*s5*u4*u5*(c6*c6) - ...
          c6*s6*(s5*s5)*(u4*u4) + c6*s6*(u5*u5)) + ...
          c6*legMassVerticalOffset*MLeg*((s5*s6*u4 + c6*u5)*(s5*s6*u4 + c6*u5) + (c5*u4 ...
          + u6)*(c5*u4 + u6))) + s7*s8*legMassVerticalOffset*MLeg*(c7*u4dot + u8dot - ...
          2*s7*u4*u7*(c8*c8) - c8*s8*(s7*s7)*(u4*u4) + c8*s8*(u7*u7)) + ...
          c8*s7*legMassVerticalOffset*MLeg*((s7*s8*u4 + c8*u7)*(s7*s8*u4 + c8*u7) + ...
          (c7*u4 + u8)*(c7*u4 + u8));
        points.totalForceOnCOM(2) = u2dot*(2*MLeg + MPelvis) + ...
          s4*(-(s5*legMassVerticalOffset*MLeg*(s5*s6*u4dot + c6*u5dot + 2*c6*s5*u4*u6 - ...
          2*s6*u5*u6 + c5*c6*s5*(u4*u4))) - s7*legMassVerticalOffset*MLeg*(s7*s8*u4dot ...
          + c8*u7dot + 2*c8*s7*u4*u8 - 2*s8*u7*u8 + c7*c8*s7*(u4*u4))) + (c4*c6 - ...
          c5*s4*s6)*legMassVerticalOffset*MLeg*(c5*u4dot + u6dot - 2*s5*u4*u5*(c6*c6) - ...
          c6*s6*(s5*s5)*(u4*u4) + c6*s6*(u5*u5)) + (-(c5*c6*s4) - ...
          c4*s6)*legMassVerticalOffset*MLeg*((s5*s6*u4 + c6*u5)*(s5*s6*u4 + c6*u5) + ...
          (c5*u4 + u6)*(c5*u4 + u6)) + (c4*c8 - ...
          c7*s4*s8)*legMassVerticalOffset*MLeg*(c7*u4dot + u8dot - 2*s7*u4*u7*(c8*c8) - ...
          c8*s8*(s7*s7)*(u4*u4) + c8*s8*(u7*u7)) + (-(c7*c8*s4) - ...
          c4*s8)*legMassVerticalOffset*MLeg*((s7*s8*u4 + c8*u7)*(s7*s8*u4 + c8*u7) + ...
          (c7*u4 + u8)*(c7*u4 + u8));
        points.totalForceOnCOM(3) = u3dot*(2*MLeg + MPelvis) + ...
          c4*(s5*legMassVerticalOffset*MLeg*(s5*s6*u4dot + c6*u5dot + 2*c6*s5*u4*u6 - ...
          2*s6*u5*u6 + c5*c6*s5*(u4*u4)) + s7*legMassVerticalOffset*MLeg*(s7*s8*u4dot + ...
          c8*u7dot + 2*c8*s7*u4*u8 - 2*s8*u7*u8 + c7*c8*s7*(u4*u4))) + (c6*s4 + ...
          c4*c5*s6)*legMassVerticalOffset*MLeg*(c5*u4dot + u6dot - 2*s5*u4*u5*(c6*c6) - ...
          c6*s6*(s5*s5)*(u4*u4) + c6*s6*(u5*u5)) + (c4*c5*c6 - ...
          s4*s6)*legMassVerticalOffset*MLeg*((s5*s6*u4 + c6*u5)*(s5*s6*u4 + c6*u5) + ...
          (c5*u4 + u6)*(c5*u4 + u6)) + (c8*s4 + ...
          c4*c7*s8)*legMassVerticalOffset*MLeg*(c7*u4dot + u8dot - 2*s7*u4*u7*(c8*c8) - ...
          c8*s8*(s7*s7)*(u4*u4) + c8*s8*(u7*u7)) + (c4*c7*c8 - ...
          s4*s8)*legMassVerticalOffset*MLeg*((s7*s8*u4 + c8*u7)*(s7*s8*u4 + c8*u7) + ...
          (c7*u4 + u8)*(c7*u4 + u8));
        
        
        points.totalTorqueAroundCOM(1) = c5*(c5*u4dot - s5*u4*u5 + u6dot)*ILeg + ...
          s7*s8*(s7*s8*u4dot + c8*u7dot - s8*u7*u8 + u4*(c7*s8*u7 + c8*s7*u8))*ILeg + ...
          c7*(c7*u4dot - s7*u4*u7 + u8dot)*ILeg + c8*s7*(c8*s7*u4dot - s8*u7dot - ...
          c8*u7*u8 + u4*(c7*c8*u7 - s7*s8*u8))*ILegSmall + s5*(s6*(s5*s6*u4dot + ...
          c6*u5dot - s6*u5*u6 + u4*(c5*s6*u5 + c6*s5*u6))*ILeg + c6*(c6*s5*u4dot - ...
          s6*u5dot - c6*u5*u6 + u4*(c5*c6*u5 - s5*s6*u6))*ILegSmall) + u4dot*IPelvis;
        points.totalTorqueAroundCOM(2) = (c4*c6 - c5*s4*s6)*(s5*s6*u4dot + c6*u5dot - ...
          s6*u5*u6 + u4*(c5*s6*u5 + c6*s5*u6))*ILeg + (c4*c8 - c7*s4*s8)*(s7*s8*u4dot + ...
          c8*u7dot - s8*u7*u8 + u4*(c7*s8*u7 + c8*s7*u8))*ILeg + s4*(s5*(c5*u4dot - ...
          s5*u4*u5 + u6dot)*ILeg + s7*(c7*u4dot - s7*u4*u7 + u8dot)*ILeg) + ...
          (-(c5*c6*s4) - c4*s6)*(c6*s5*u4dot - s6*u5dot - c6*u5*u6 + u4*(c5*c6*u5 - ...
          s5*s6*u6))*ILegSmall + (-(c7*c8*s4) - c4*s8)*(c8*s7*u4dot - s8*u7dot - ...
          c8*u7*u8 + u4*(c7*c8*u7 - s7*s8*u8))*ILegSmall;
        points.totalTorqueAroundCOM(3) = (c6*s4 + c4*c5*s6)*(s5*s6*u4dot + c6*u5dot - ...
          s6*u5*u6 + u4*(c5*s6*u5 + c6*s5*u6))*ILeg + (c8*s4 + c4*c7*s8)*(s7*s8*u4dot + ...
          c8*u7dot - s8*u7*u8 + u4*(c7*s8*u7 + c8*s7*u8))*ILeg + c4*(-(s5*(c5*u4dot - ...
          s5*u4*u5 + u6dot)*ILeg) - s7*(c7*u4dot - s7*u4*u7 + u8dot)*ILeg) + (c4*c5*c6 ...
          - s4*s6)*(c6*s5*u4dot - s6*u5dot - c6*u5*u6 + u4*(c5*c6*u5 - ...
          s5*s6*u6))*ILegSmall + (c4*c7*c8 - s4*s8)*(c8*s7*u4dot - s8*u7dot - c8*u7*u8 ...
          + u4*(c7*c8*u7 - s7*s8*u8))*ILegSmall;
      end
      
    end
    
    function [MM, rhs] = getMassMatrixAndRightHandSide(this, time, state)
      %%
      %       state = this.getWalkerStateObjectFromVector(state);
      %       state.setQsUsAndTrigInCurrentFunction();
      
      ThreeDWalkerSplayState.setQsUsAndTrigInCurrentFunctionFromState(state);
      
      this.setWalkerParamsInCurrentFunction();
      
      for i = 1 : length(this.controllers)
        this.controllers{i}.calculateControlAndSetInCurrentFunction(this, time, state);
      end
      
      %       stanceAnkleTorque
      %       state.getVector()'
      
      MM = zeros(8,8); rhs = zeros(8,1);
      
      %       MM(1,1) = 2*MLeg + MPelvis; MM(1,2) = 0; MM(1,3) = 0; MM(1,4) = 0; MM(1,5) = ...
      %         -(c5*c6*legMassVerticalOffset*MLeg); MM(1,6) = 0; MM(1,7) = ...
      %         -(c7*c8*legMassVerticalOffset*MLeg); MM(1,8) = 0;
      %       MM(2,1) = MM(1,2); MM(2,2) = 2*MLeg + MPelvis; MM(2,3) = 0; MM(2,4) = ...
      %         (c4p6*c5 + c4p8*c7)*legMassVerticalOffset*MLeg; MM(2,5) = ...
      %         -(s4*s5*legMassVerticalOffset*MLeg); MM(2,6) = ...
      %         c4p6*c5*legMassVerticalOffset*MLeg; MM(2,7) = ...
      %         -(s4*s7*legMassVerticalOffset*MLeg); MM(2,8) = ...
      %         c4p8*c7*legMassVerticalOffset*MLeg;
      %       MM(3,1) = MM(1,3); MM(3,2) = MM(2,3); MM(3,3) = 2*MLeg + MPelvis; MM(3,4) = ...
      %         (c5*s4p6 + c7*s4p8)*legMassVerticalOffset*MLeg; MM(3,5) = ...
      %         c4*s5*legMassVerticalOffset*MLeg; MM(3,6) = ...
      %         c5*s4p6*legMassVerticalOffset*MLeg; MM(3,7) = ...
      %         c4*s7*legMassVerticalOffset*MLeg; MM(3,8) = ...
      %         c7*s4p8*legMassVerticalOffset*MLeg;
      %       MM(4,1) = MM(1,4); MM(4,2) = MM(2,4); MM(4,3) = MM(3,4); MM(4,4) = IPelvis + ...
      %         c5*s6*legMassVerticalOffset*MLeg*pelvisWidth - ...
      %         c7*s8*legMassVerticalOffset*MLeg*pelvisWidth + ILegSmall*(s5*s5) + ...
      %         ILegSmall*(s7*s7) + c5*c5*(ILeg + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset)) + c7*c7*(ILeg + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset)) + ...
      %         (MLeg*(pelvisWidth*pelvisWidth))/2.; MM(4,5) = ...
      %         (s5*(legMassVerticalOffset*MLeg*pelvisWidth + 2*c5*s6*(ILeg - ILegSmall + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset))))/2.; MM(4,6) = ...
      %         (c5*s6*legMassVerticalOffset*MLeg*pelvisWidth)/2. + ILegSmall*(s5*s5) + ...
      %         c5*c5*(ILeg + MLeg*(legMassVerticalOffset*legMassVerticalOffset)); MM(4,7) = ...
      %         (s7*(-(legMassVerticalOffset*MLeg*pelvisWidth) + 2*c7*s8*(ILeg - ILegSmall + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset))))/2.; MM(4,8) = ...
      %         -(c7*s8*legMassVerticalOffset*MLeg*pelvisWidth)/2. + ILegSmall*(s7*s7) + ...
      %         c7*c7*(ILeg + MLeg*(legMassVerticalOffset*legMassVerticalOffset));
      %       MM(5,1) = MM(1,5); MM(5,2) = MM(2,5); MM(5,3) = MM(3,5); MM(5,4) = MM(4,5); ...
      %         MM(5,5) = c6*c6*(ILeg + MLeg*(legMassVerticalOffset*legMassVerticalOffset)) + ...
      %         s6*s6*(ILegSmall*(c5*c5) + s5*s5*(ILeg + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset))); MM(5,6) = ...
      %         c5*s5*s6*(ILeg - ILegSmall + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset)); MM(5,7) = 0; MM(5,8) = ...
      %         0;
      %       MM(6,1) = MM(1,6); MM(6,2) = MM(2,6); MM(6,3) = MM(3,6); MM(6,4) = MM(4,6); ...
      %         MM(6,5) = MM(5,6); MM(6,6) = ILegSmall*(s5*s5) + c5*c5*(ILeg + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset)); MM(6,7) = 0; MM(6,8) = ...
      %         0;
      %       MM(7,1) = MM(1,7); MM(7,2) = MM(2,7); MM(7,3) = MM(3,7); MM(7,4) = MM(4,7); ...
      %         MM(7,5) = MM(5,7); MM(7,6) = MM(6,7); MM(7,7) = c8*c8*(ILeg + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset)) + ...
      %         s8*s8*(ILegSmall*(c7*c7) + s7*s7*(ILeg + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset))); MM(7,8) = ...
      %         c7*s7*s8*(ILeg - ILegSmall + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset));
      %       MM(8,1) = MM(1,8); MM(8,2) = MM(2,8); MM(8,3) = MM(3,8); MM(8,4) = MM(4,8); ...
      %         MM(8,5) = MM(5,8); MM(8,6) = MM(6,8); MM(8,7) = MM(7,8); MM(8,8) = ...
      %         ILegSmall*(s7*s7) + c7*c7*(ILeg + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset));
      %
      %
      %       % righthand side terms
      %       rhs(1) = -(c5*s6*u5*u6*legMassVerticalOffset*MLeg) - ...
      %         c7*s8*u7*u8*legMassVerticalOffset*MLeg - ...
      %         s5*legMassVerticalOffset*MLeg*(u5*u5) - s7*legMassVerticalOffset*MLeg*(u7*u7) ...
      %         + g*(2*MLeg + MPelvis)*sin(groundAngle);
      %       rhs(2) = lateralPelvisForce + c4*s5*u5*u6*legMassVerticalOffset*MLeg + ...
      %         c4*s7*u7*u8*legMassVerticalOffset*MLeg + 2*u4*(c4*s5*u5 + c5*s4p6*u6 + ...
      %         c4*s7*u7 + c7*c8*s4*u8 + c4*c7*s8*u8)*legMassVerticalOffset*MLeg + (c5*s4p6 + ...
      %         c7*s4p8)*legMassVerticalOffset*MLeg*(u4*u4) + ...
      %         c5*c6*s4*legMassVerticalOffset*MLeg*(u5*u5) + ...
      %         c5*c6*s4*legMassVerticalOffset*MLeg*(u6*u6) + ...
      %         c4*c5*s6*legMassVerticalOffset*MLeg*(u6*u6) + ...
      %         c7*c8*s4*legMassVerticalOffset*MLeg*(u7*u7) + ...
      %         c7*c8*s4*legMassVerticalOffset*MLeg*(u8*u8) + ...
      %         c4*c7*s8*legMassVerticalOffset*MLeg*(u8*u8);
      %       rhs(3) = s4*s5*u5*u6*legMassVerticalOffset*MLeg + ...
      %         s4*s7*u7*u8*legMassVerticalOffset*MLeg + 2*u4*(s4*s5*u5 - c4p6*c5*u6 + ...
      %         s4*s7*u7 - c4*c7*c8*u8 + c7*s4*s8*u8)*legMassVerticalOffset*MLeg - ...
      %         2*g*MLeg*cos(groundAngle) - g*MPelvis*cos(groundAngle) - ...
      %         (legMassVerticalOffset*MLeg*(c4m5p6 + 2*c4p8*c7 + cos(q4 + q5 + ...
      %         q6))*(u4*u4))/2. - c4*c5*c6*legMassVerticalOffset*MLeg*(u5*u5) - ...
      %         c4*c5*c6*legMassVerticalOffset*MLeg*(u6*u6) + ...
      %         c5*s4*s6*legMassVerticalOffset*MLeg*(u6*u6) - ...
      %         c4*c7*c8*legMassVerticalOffset*MLeg*(u7*u7) - ...
      %         c4*c7*c8*legMassVerticalOffset*MLeg*(u8*u8) + ...
      %         c7*s4*s8*legMassVerticalOffset*MLeg*(u8*u8);
      %       rhs(4) = (-(g*MLeg*(2*c5*s4p6*legMassVerticalOffset + ...
      %         c4*pelvisWidth)*cos(groundAngle)) + g*MLeg*(-2*c7*s4p8*legMassVerticalOffset ...
      %         + c4*pelvisWidth)*cos(groundAngle) - ...
      %         c5*c6*(u5*u5)*(legMassVerticalOffset*MLeg*pelvisWidth + 2*c5*s6*(ILeg - ...
      %         ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) - ...
      %         c7*c8*(u7*u7)*(-(legMassVerticalOffset*MLeg*pelvisWidth) + 2*c7*s8*(ILeg - ...
      %         ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) + ...
      %         c5*c6*u6*(-(u6*legMassVerticalOffset*MLeg*pelvisWidth) + 2*s5*u5*(ILeg - ...
      %         ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) + ...
      %         c7*c8*u8*(u8*legMassVerticalOffset*MLeg*pelvisWidth + 2*s7*u7*(ILeg - ...
      %         ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) + ...
      %         2*u4*(-(c5*c6*u6*legMassVerticalOffset*MLeg*pelvisWidth) + ...
      %         c7*c8*(u8*legMassVerticalOffset*MLeg*pelvisWidth + 2*s7*u7*(ILeg - ILegSmall ...
      %         + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) + c6*u5*(ILeg - ...
      %         ILegSmall + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset))*sin(2*q5)))/2.;
      %       rhs(5) = (-q5 + q7)*KSwing - ...
      %         s4p6*s5*s6*g*legMassVerticalOffset*MLeg*cos(groundAngle) + c5*c6*(-2*s5*u4 + ...
      %         c5*s6*u5)*u6*(ILeg - ILegSmall + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset)) - (c6*(u4*u4 + ...
      %         u6*u6)*(ILeg - ILegSmall + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset))*sin(2*q5))/2. - ...
      %         c6*g*legMassVerticalOffset*MLeg*(c4p6*s5*cos(groundAngle) + ...
      %         c5*sin(groundAngle));
      %       rhs(6) = stanceAnkleTorque - ...
      %         c5*s4p6*g*legMassVerticalOffset*MLeg*cos(groundAngle) + ...
      %         c5*c6*((legMassVerticalOffset*MLeg*pelvisWidth*(u4*u4))/2. + s5*u5*(2*u4 + ...
      %         u6)*(ILeg - ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) ...
      %         - (c5*c5*(u5*u5)*(ILeg - ILegSmall + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset))*sin(2*q6))/2.;
      %       rhs(7) = (q5 - q7)*KSwing - ...
      %         s4p8*s7*s8*g*legMassVerticalOffset*MLeg*cos(groundAngle) + c7*c8*(-2*s7*u4 + ...
      %         c7*s8*u7)*u8*(ILeg - ILegSmall + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset)) - (c8*(u4*u4 + ...
      %         u8*u8)*(ILeg - ILegSmall + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset))*sin(2*q7))/2. - ...
      %         c8*g*legMassVerticalOffset*MLeg*(c4p8*s7*cos(groundAngle) + ...
      %         c7*sin(groundAngle));
      %       rhs(8) = (c7*(-2*s4p8*g*legMassVerticalOffset*MLeg*cos(groundAngle) + ...
      %         2*c8*(-(legMassVerticalOffset*MLeg*pelvisWidth*(u4*u4))/2. + s7*u7*(2*u4 + ...
      %         u8)*(ILeg - ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) ...
      %         - c7*(u7*u7)*(ILeg - ILegSmall + ...
      %         MLeg*(legMassVerticalOffset*legMassVerticalOffset))*sin(2*q8)))/2.;
      
      
      MM(1,1) = 2*MLeg + MPelvis; MM(1,2) = 0; MM(1,3) = 0; MM(1,4) = 0; MM(1,5) = ...
        -(c5*c6*legMassVerticalOffset*MLeg); MM(1,6) = ...
        s5*s6*legMassVerticalOffset*MLeg; MM(1,7) = ...
        -(c7*c8*legMassVerticalOffset*MLeg); MM(1,8) = ...
        s7*s8*legMassVerticalOffset*MLeg;
      MM(2,1) = MM(1,2); MM(2,2) = 2*MLeg + MPelvis; MM(2,3) = 0; MM(2,4) = ...
        (c4*(c5*c6 + c7*c8) - s4*(s6 + s8))*legMassVerticalOffset*MLeg; MM(2,5) = ...
        -(c6*s4*s5*legMassVerticalOffset*MLeg); MM(2,6) = (c4*c6 - ...
        c5*s4*s6)*legMassVerticalOffset*MLeg; MM(2,7) = ...
        -(c8*s4*s7*legMassVerticalOffset*MLeg); MM(2,8) = (c4*c8 - ...
        c7*s4*s8)*legMassVerticalOffset*MLeg;
      MM(3,1) = MM(1,3); MM(3,2) = MM(2,3); MM(3,3) = 2*MLeg + MPelvis; MM(3,4) = ...
        (c5*c6*s4 + c7*c8*s4 + c4*(s6 + s8))*legMassVerticalOffset*MLeg; MM(3,5) = ...
        c4*c6*s5*legMassVerticalOffset*MLeg; MM(3,6) = (c6*s4 + ...
        c4*c5*s6)*legMassVerticalOffset*MLeg; MM(3,7) = ...
        c4*c8*s7*legMassVerticalOffset*MLeg; MM(3,8) = (c8*s4 + ...
        c4*c7*s8)*legMassVerticalOffset*MLeg;
      MM(4,1) = MM(1,4); MM(4,2) = MM(2,4); MM(4,3) = MM(3,4); MM(4,4) = IPelvis + ...
        s6*legMassVerticalOffset*MLeg*pelvisWidth - ...
        s8*legMassVerticalOffset*MLeg*pelvisWidth + ILegSmall*(c6*c6)*(s5*s5) + ...
        ILeg*(s5*s5)*(s6*s6) + ILegSmall*(c8*c8)*(s7*s7) + ILeg*(s7*s7)*(s8*s8) + ...
        MLeg*(s5*s5)*(s6*s6)*(legMassVerticalOffset*legMassVerticalOffset) + ...
        MLeg*(s7*s7)*(s8*s8)*(legMassVerticalOffset*legMassVerticalOffset) + ...
        c5*c5*(ILeg + MLeg*(legMassVerticalOffset*legMassVerticalOffset)) + ...
        c7*c7*(ILeg + MLeg*(legMassVerticalOffset*legMassVerticalOffset)) + ...
        (MLeg*(pelvisWidth*pelvisWidth))/2.; MM(4,5) = ...
        (c6*s5*(legMassVerticalOffset*MLeg*pelvisWidth + 2*s6*(ILeg - ILegSmall + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset))))/2.; MM(4,6) = ...
        (c5*(s6*legMassVerticalOffset*MLeg*pelvisWidth + 2*(ILeg + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset))))/2.; MM(4,7) = ...
        (c8*s7*(-(legMassVerticalOffset*MLeg*pelvisWidth) + 2*s8*(ILeg - ILegSmall + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset))))/2.; MM(4,8) = ...
        (c7*(-(s8*legMassVerticalOffset*MLeg*pelvisWidth) + 2*(ILeg + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset))))/2.;
      MM(5,1) = MM(1,5); MM(5,2) = MM(2,5); MM(5,3) = MM(3,5); MM(5,4) = MM(4,5); ...
        MM(5,5) = ILegSmall*(s6*s6) + c6*c6*(ILeg + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset)); MM(5,6) = 0; MM(5,7) = ...
        0; MM(5,8) = 0;
      MM(6,1) = MM(1,6); MM(6,2) = MM(2,6); MM(6,3) = MM(3,6); MM(6,4) = MM(4,6); ...
        MM(6,5) = MM(5,6); MM(6,6) = ILeg + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset); MM(6,7) = 0; MM(6,8) = 0;
      MM(7,1) = MM(1,7); MM(7,2) = MM(2,7); MM(7,3) = MM(3,7); MM(7,4) = MM(4,7); ...
        MM(7,5) = MM(5,7); MM(7,6) = MM(6,7); MM(7,7) = ILegSmall*(s8*s8) + ...
        c8*c8*(ILeg + MLeg*(legMassVerticalOffset*legMassVerticalOffset)); MM(7,8) = ...
        0;
      MM(8,1) = MM(1,8); MM(8,2) = MM(2,8); MM(8,3) = MM(3,8); MM(8,4) = MM(4,8); ...
        MM(8,5) = MM(5,8); MM(8,6) = MM(6,8); MM(8,7) = MM(7,8); MM(8,8) = ILeg + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset);
      
      % righthand side terms
      
      
      
      % righthand side terms
      rhs(1) = -2*c5*s6*u5*u6*legMassVerticalOffset*MLeg - ...
        2*c7*s8*u7*u8*legMassVerticalOffset*MLeg - ...
        c6*s5*legMassVerticalOffset*MLeg*(u5*u5) - ...
        c6*s5*legMassVerticalOffset*MLeg*(u6*u6) - ...
        c8*s7*legMassVerticalOffset*MLeg*(u7*u7) - ...
        c8*s7*legMassVerticalOffset*MLeg*(u8*u8) + 2*g*MLeg*sin(groundAngle) + ...
        g*MPelvis*sin(groundAngle);
      rhs(2) = lateralPelvisForce - 2*s4*s5*s6*u5*u6*legMassVerticalOffset*MLeg - ...
        2*s4*s7*s8*u7*u8*legMassVerticalOffset*MLeg + 2*u4*(c4*c6*s5*u5 + (c6*s4 + ...
        c4*c5*s6)*u6 + c4*c8*s7*u7 + c8*s4*u8 + ...
        c4*c7*s8*u8)*legMassVerticalOffset*MLeg + (c5*c6*s4 + c7*c8*s4 + c4*(s6 + ...
        s8))*legMassVerticalOffset*MLeg*(u4*u4) + ...
        c5*c6*s4*legMassVerticalOffset*MLeg*(u5*u5) + ...
        c5*c6*s4*legMassVerticalOffset*MLeg*(u6*u6) + ...
        c4*s6*legMassVerticalOffset*MLeg*(u6*u6) + ...
        c7*c8*s4*legMassVerticalOffset*MLeg*(u7*u7) + ...
        c7*c8*s4*legMassVerticalOffset*MLeg*(u8*u8) + ...
        c4*s8*legMassVerticalOffset*MLeg*(u8*u8);
      rhs(3) = 2*c4*s5*s6*u5*u6*legMassVerticalOffset*MLeg + ...
        2*c4*s7*s8*u7*u8*legMassVerticalOffset*MLeg + 2*u4*(c6*s4*s5*u5 + (-(c4*c6) + ...
        c5*s4*s6)*u6 + c8*s4*s7*u7 - c4*c8*u8 + ...
        c7*s4*s8*u8)*legMassVerticalOffset*MLeg - 2*g*MLeg*cos(groundAngle) - ...
        g*MPelvis*cos(groundAngle) + (-(c4*(c5*c6 + c7*c8)) + s4*(s6 + ...
        s8))*legMassVerticalOffset*MLeg*(u4*u4) - ...
        c4*c5*c6*legMassVerticalOffset*MLeg*(u5*u5) - ...
        c4*c5*c6*legMassVerticalOffset*MLeg*(u6*u6) + ...
        s4*s6*legMassVerticalOffset*MLeg*(u6*u6) - ...
        c4*c7*c8*legMassVerticalOffset*MLeg*(u7*u7) - ...
        c4*c7*c8*legMassVerticalOffset*MLeg*(u8*u8) + ...
        s4*s8*legMassVerticalOffset*MLeg*(u8*u8);
      rhs(4) = (g*MLeg*(-2*c7*c8*s4*legMassVerticalOffset + ...
        c4*(-2*s8*legMassVerticalOffset + pelvisWidth))*cos(groundAngle) + ...
        2*c5*(stanceAnkleTorque - (c6*s4 + ...
        c4*c5*s6)*g*legMassVerticalOffset*MLeg*cos(groundAngle)) - ...
        c4*g*MLeg*cos(groundAngle)*(pelvisWidth + 2*s6*legMassVerticalOffset*(s5*s5)) ...
        + 2*s5*u5*u6*(ILeg + s6*legMassVerticalOffset*MLeg*pelvisWidth + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset) - cos(2*q6)*(ILeg - ...
        ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) + ...
        2*s7*u7*u8*(ILeg - s8*legMassVerticalOffset*MLeg*pelvisWidth + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset) - cos(2*q8)*(ILeg - ...
        ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) - ...
        c5*c6*(legMassVerticalOffset*MLeg*pelvisWidth*(u6*u6) + ...
        u5*u5*(legMassVerticalOffset*MLeg*pelvisWidth + 2*s6*(ILeg - ILegSmall + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset)))) + ...
        c7*c8*(legMassVerticalOffset*MLeg*pelvisWidth*(u8*u8) + ...
        u7*u7*(legMassVerticalOffset*MLeg*pelvisWidth - 2*s8*(ILeg - ILegSmall + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset)))) + ...
        2*u4*(c6*u6*(-(legMassVerticalOffset*MLeg*pelvisWidth) - 2*s6*(s5*s5)*(ILeg - ...
        ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) + ...
        c8*u8*(legMassVerticalOffset*MLeg*pelvisWidth - 2*s8*(s7*s7)*(ILeg - ...
        ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) + ...
        u5*(c6*c6)*(ILeg - ILegSmall + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset))*sin(2*q5) + ...
        u7*(c8*c8)*(ILeg - ILegSmall + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset))*sin(2*q7)))/2.;
      rhs(5) = extraSwingTorque + (-q5 + q7)*KSwing + s5*u4*(-(c5*u4*(c6*c6)*(ILeg ...
        - ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) - u6*(ILeg ...
        + MLeg*(legMassVerticalOffset*legMassVerticalOffset) + cos(2*q6)*(ILeg - ...
        ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset)))) + ...
        u5*u6*(ILeg - ILegSmall + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset))*sin(2*q6) - ...
        c6*g*legMassVerticalOffset*MLeg*(c4*s5*cos(groundAngle) + ...
        c5*sin(groundAngle));
      rhs(6) = stanceAnkleTorque - (c6*s4 + ...
        c4*c5*s6)*g*legMassVerticalOffset*MLeg*cos(groundAngle) + s5*u4*u5*(ILeg + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset) + cos(2*q6)*(ILeg - ...
        ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) + ...
        (c6*(-2*s6*(u5*u5)*(ILeg - ILegSmall + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset)) + ...
        u4*u4*(legMassVerticalOffset*MLeg*pelvisWidth + 2*s6*(s5*s5)*(ILeg - ...
        ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset)))))/2. + ...
        s5*s6*g*legMassVerticalOffset*MLeg*sin(groundAngle);
      rhs(7) = -extraSwingTorque + (q5 - q7)*KSwing + s7*u4*(-(c7*u4*(c8*c8)*(ILeg ...
        - ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) - u8*(ILeg ...
        + MLeg*(legMassVerticalOffset*legMassVerticalOffset) + cos(2*q8)*(ILeg - ...
        ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset)))) + ...
        u7*u8*(ILeg - ILegSmall + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset))*sin(2*q8) - ...
        c8*g*legMassVerticalOffset*MLeg*(c4*s7*cos(groundAngle) + ...
        c7*sin(groundAngle));
      rhs(8) = c7*(q4 - q8)*KSwingRoll - (c8*s4 + ...
        c4*c7*s8)*g*legMassVerticalOffset*MLeg*cos(groundAngle) + s7*u4*u7*(ILeg + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset) + cos(2*q8)*(ILeg - ...
        ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset))) + ...
        (c8*(-2*s8*(u7*u7)*(ILeg - ILegSmall + ...
        MLeg*(legMassVerticalOffset*legMassVerticalOffset)) + ...
        u4*u4*(-(legMassVerticalOffset*MLeg*pelvisWidth) + 2*s8*(s7*s7)*(ILeg - ...
        ILegSmall + MLeg*(legMassVerticalOffset*legMassVerticalOffset)))))/2. + ...
        s7*s8*g*legMassVerticalOffset*MLeg*sin(groundAngle);
      
    end
    
    function [C, CDot] = getConstraintMatrix(this, state, mode)
      %%
      state = this.getWalkerStateObjectFromVector(state);
      
      state.setQsUsAndTrigInCurrentFunction();
      this.setWalkerParamsInCurrentFunction();
      
      if (this.alwaysInFlightPhase)
        C = []; %constraintJacobianStanceFootRolling;
        CDot = []; %constraintJacobianStanceFootRollingDot;
        return;
      end
      
      switch mode
        
        case 'swingFootRolling'
          
          
          constraintJacobianSwingFootRolling(5, 8) = 0;
          constraintJacobianSwingFootRollingDot(5, 8) = 0;
          
          constraintJacobianSwingFootRolling(1,1) = 1; ...
            constraintJacobianSwingFootRolling(1,2) = 0; ...
            constraintJacobianSwingFootRolling(1,3) = 0; ...
            constraintJacobianSwingFootRolling(1,4) = 0; ...
            constraintJacobianSwingFootRolling(1,5) = 0; ...
            constraintJacobianSwingFootRolling(1,6) = 0; ...
            constraintJacobianSwingFootRolling(1,7) = c7*c8*(-1 + R) - c4*R; ...
            constraintJacobianSwingFootRolling(1,8) = s7*(-(s8*(-1 + R)) - s4*R);
          constraintJacobianSwingFootRolling(2,1) = 0; ...
            constraintJacobianSwingFootRolling(2,2) = 1; ...
            constraintJacobianSwingFootRolling(2,3) = 0; ...
            constraintJacobianSwingFootRolling(2,4) = (s4*(pelvisWidth + 2*s8*(-1 + ...
            R)))/2. - c4*c7*c8*(-1 + R) + R; constraintJacobianSwingFootRolling(2,5) = 0; ...
            constraintJacobianSwingFootRolling(2,6) = 0; ...
            constraintJacobianSwingFootRolling(2,7) = c8*s4*s7*(-1 + R); ...
            constraintJacobianSwingFootRolling(2,8) = -(c4*c8*(-1 + R)) + c7*(s4*s8*(-1 + ...
            R) + R);
          constraintJacobianSwingFootRolling(3,1) = 0; ...
            constraintJacobianSwingFootRolling(3,2) = 0; ...
            constraintJacobianSwingFootRolling(3,3) = 1; ...
            constraintJacobianSwingFootRolling(3,4) = -(c4*(pelvisWidth + 2*s8*(-1 + ...
            R)))/2. - c7*c8*s4*(-1 + R); constraintJacobianSwingFootRolling(3,5) = 0; ...
            constraintJacobianSwingFootRolling(3,6) = 0; ...
            constraintJacobianSwingFootRolling(3,7) = -(c4*c8*s7*(-1 + R)); ...
            constraintJacobianSwingFootRolling(3,8) = -((c8*s4 + c4*c7*s8)*(-1 + R));
          constraintJacobianSwingFootRolling(4,1) = 0; ...
            constraintJacobianSwingFootRolling(4,2) = 1; ...
            constraintJacobianSwingFootRolling(4,3) = 0; ...
            constraintJacobianSwingFootRolling(4,4) = (s4*(pelvisWidth + 2*s8*(-1 + ...
            R)))/2. - c4*c7*c8*(-1 + R); constraintJacobianSwingFootRolling(4,5) = 0; ...
            constraintJacobianSwingFootRolling(4,6) = 0; ...
            constraintJacobianSwingFootRolling(4,7) = c8*s4*s7*(-1 + R); ...
            constraintJacobianSwingFootRolling(4,8) = -((c4*c8 - c7*s4*s8)*(-1 + R));
          constraintJacobianSwingFootRolling(5,1) = 0; ...
            constraintJacobianSwingFootRolling(5,2) = 0; ...
            constraintJacobianSwingFootRolling(5,3) = 0; ...
            constraintJacobianSwingFootRolling(5,4) = 0; ...
            constraintJacobianSwingFootRolling(5,5) = 0; ...
            constraintJacobianSwingFootRolling(5,6) = 1; ...
            constraintJacobianSwingFootRolling(5,7) = 0; ...
            constraintJacobianSwingFootRolling(5,8) = 1;
          
          
          constraintJacobianSwingFootRollingDot(1,1) = 0; ...
            constraintJacobianSwingFootRollingDot(1,2) = 0; ...
            constraintJacobianSwingFootRollingDot(1,3) = 0; ...
            constraintJacobianSwingFootRollingDot(1,4) = 0; ...
            constraintJacobianSwingFootRollingDot(1,5) = 0; ...
            constraintJacobianSwingFootRollingDot(1,6) = 0; ...
            constraintJacobianSwingFootRollingDot(1,7) = -(c8*s7*u7*(-1 + R)) - ...
            c7*s8*u8*(-1 + R) + s4*u4*R; constraintJacobianSwingFootRollingDot(1,8) = ...
            c7*u7*(-(s8*(-1 + R)) - s4*R) + s7*(-(c8*u8*(-1 + R)) - c4*u4*R);
          constraintJacobianSwingFootRollingDot(2,1) = 0; ...
            constraintJacobianSwingFootRollingDot(2,2) = 0; ...
            constraintJacobianSwingFootRollingDot(2,3) = 0; ...
            constraintJacobianSwingFootRollingDot(2,4) = (c4*u4*(pelvisWidth + 2*s8*(-1 + ...
            R)))/2. + c7*c8*s4*u4*(-1 + R) + c4*c8*s7*u7*(-1 + R) + c8*s4*u8*(-1 + R) + ...
            c4*c7*s8*u8*(-1 + R); constraintJacobianSwingFootRollingDot(2,5) = 0; ...
            constraintJacobianSwingFootRollingDot(2,6) = 0; ...
            constraintJacobianSwingFootRollingDot(2,7) = c4*c8*s7*u4*(-1 + R) + ...
            c7*c8*s4*u7*(-1 + R) - s4*s7*s8*u8*(-1 + R); ...
            constraintJacobianSwingFootRollingDot(2,8) = c7*(c4*s8*u4*(-1 + R) + ...
            c8*s4*u8*(-1 + R)) + c8*s4*u4*(-1 + R) + c4*s8*u8*(-1 + R) - s7*u7*(s4*s8*(-1 ...
            + R) + R);
          constraintJacobianSwingFootRollingDot(3,1) = 0; ...
            constraintJacobianSwingFootRollingDot(3,2) = 0; ...
            constraintJacobianSwingFootRollingDot(3,3) = 0; ...
            constraintJacobianSwingFootRollingDot(3,4) = (s4*u4*(pelvisWidth + 2*s8*(-1 + ...
            R)))/2. - c4*c7*c8*u4*(-1 + R) + c8*s4*s7*u7*(-1 + R) - c4*c8*u8*(-1 + R) + ...
            c7*s4*s8*u8*(-1 + R); constraintJacobianSwingFootRollingDot(3,5) = 0; ...
            constraintJacobianSwingFootRollingDot(3,6) = 0; ...
            constraintJacobianSwingFootRollingDot(3,7) = c8*s4*s7*u4*(-1 + R) - ...
            c4*c7*c8*u7*(-1 + R) + c4*s7*s8*u8*(-1 + R); ...
            constraintJacobianSwingFootRollingDot(3,8) = -((c4*c8*u4 - c7*s4*s8*u4 - ...
            c4*s7*s8*u7 + c4*c7*c8*u8 - s4*s8*u8)*(-1 + R));
          constraintJacobianSwingFootRollingDot(4,1) = 0; ...
            constraintJacobianSwingFootRollingDot(4,2) = 0; ...
            constraintJacobianSwingFootRollingDot(4,3) = 0; ...
            constraintJacobianSwingFootRollingDot(4,4) = (c4*u4*(pelvisWidth + 2*s8*(-1 + ...
            R)))/2. + c7*c8*s4*u4*(-1 + R) + c4*c8*s7*u7*(-1 + R) + c8*s4*u8*(-1 + R) + ...
            c4*c7*s8*u8*(-1 + R); constraintJacobianSwingFootRollingDot(4,5) = 0; ...
            constraintJacobianSwingFootRollingDot(4,6) = 0; ...
            constraintJacobianSwingFootRollingDot(4,7) = c4*c8*s7*u4*(-1 + R) + ...
            c7*c8*s4*u7*(-1 + R) - s4*s7*s8*u8*(-1 + R); ...
            constraintJacobianSwingFootRollingDot(4,8) = -((-(c8*s4*u4) - c4*c7*s8*u4 + ...
            s4*s7*s8*u7 - c7*c8*s4*u8 - c4*s8*u8)*(-1 + R));
          constraintJacobianSwingFootRollingDot(5,1) = 0; ...
            constraintJacobianSwingFootRollingDot(5,2) = 0; ...
            constraintJacobianSwingFootRollingDot(5,3) = 0; ...
            constraintJacobianSwingFootRollingDot(5,4) = 0; ...
            constraintJacobianSwingFootRollingDot(5,5) = 0; ...
            constraintJacobianSwingFootRollingDot(5,6) = 0; ...
            constraintJacobianSwingFootRollingDot(5,7) = 0; ...
            constraintJacobianSwingFootRollingDot(5,8) = 0;
          
          C = constraintJacobianSwingFootRolling;
          CDot = constraintJacobianSwingFootRollingDot;
          
        case 'stanceFootRolling'
          
          constraintJacobianStanceFootRolling(4,8) = 0;
          constraintJacobianStanceFootRollingDot(4,8) = 0;
          
          % constraintJacobianStanceFootRolling(1,1) = 1; ...
          % constraintJacobianStanceFootRolling(1,2) = 0; ...
          % constraintJacobianStanceFootRolling(1,3) = 0; ...
          % constraintJacobianStanceFootRolling(1,4) = 0; ...
          % constraintJacobianStanceFootRolling(1,5) = c5*c6*(-1 + R) - c4*R; ...
          % constraintJacobianStanceFootRolling(1,6) = 0; ...
          % constraintJacobianStanceFootRolling(1,7) = 0; ...
          % constraintJacobianStanceFootRolling(1,8) = 0;
          % constraintJacobianStanceFootRolling(2,1) = 0; ...
          % constraintJacobianStanceFootRolling(2,2) = 1; ...
          % constraintJacobianStanceFootRolling(2,3) = 0; ...
          % constraintJacobianStanceFootRolling(2,4) = -(s4*pelvisWidth)/2. - c4p6*c5*(-1 ...
          % + R) + R; constraintJacobianStanceFootRolling(2,5) = s4*s5*(-1 + R); ...
          % constraintJacobianStanceFootRolling(2,6) = -(c4p6*c5*(-1 + R)) + R; ...
          % constraintJacobianStanceFootRolling(2,7) = 0; ...
          % constraintJacobianStanceFootRolling(2,8) = 0;
          % constraintJacobianStanceFootRolling(3,1) = 0; ...
          % constraintJacobianStanceFootRolling(3,2) = 0; ...
          % constraintJacobianStanceFootRolling(3,3) = 1; ...
          % constraintJacobianStanceFootRolling(3,4) = (c4*pelvisWidth)/2. - c5*s4p6*(-1 ...
          % + R); constraintJacobianStanceFootRolling(3,5) = -(c4*s5*(-1 + R)); ...
          % constraintJacobianStanceFootRolling(3,6) = -(c5*s4p6*(-1 + R)); ...
          % constraintJacobianStanceFootRolling(3,7) = 0; ...
          % constraintJacobianStanceFootRolling(3,8) = 0;
          % constraintJacobianStanceFootRolling(4,1) = 0; ...
          % constraintJacobianStanceFootRolling(4,2) = 1; ...
          % constraintJacobianStanceFootRolling(4,3) = 0; ...
          % constraintJacobianStanceFootRolling(4,4) = -(s4*pelvisWidth)/2. - c4p6*c5*(-1 ...
          % + R); constraintJacobianStanceFootRolling(4,5) = s4*s5*(-1 + R); ...
          % constraintJacobianStanceFootRolling(4,6) = -(c4p6*c5*(-1 + R)); ...
          % constraintJacobianStanceFootRolling(4,7) = 0; ...
          % constraintJacobianStanceFootRolling(4,8) = 0;
          %
          %
          % constraintJacobianStanceFootRollingDot(1,1) = 0; ...
          % constraintJacobianStanceFootRollingDot(1,2) = 0; ...
          % constraintJacobianStanceFootRollingDot(1,3) = 0; ...
          % constraintJacobianStanceFootRollingDot(1,4) = 0; ...
          % constraintJacobianStanceFootRollingDot(1,5) = -(c6*s5*u5*(-1 + R)) - ...
          % c5*s6*u6*(-1 + R) + s4*u4*R; constraintJacobianStanceFootRollingDot(1,6) = 0; ...
          % constraintJacobianStanceFootRollingDot(1,7) = 0; ...
          % constraintJacobianStanceFootRollingDot(1,8) = 0;
          % constraintJacobianStanceFootRollingDot(2,1) = 0; ...
          % constraintJacobianStanceFootRollingDot(2,2) = 0; ...
          % constraintJacobianStanceFootRollingDot(2,3) = 0; ...
          % constraintJacobianStanceFootRollingDot(2,4) = -(c4*u4*pelvisWidth)/2. + ...
          % c4p6*s5*u5*(-1 + R) + c5*s4p6*(u4 + u6)*(-1 + R); ...
          % constraintJacobianStanceFootRollingDot(2,5) = c4*s5*u4*(-1 + R) + ...
          % c5*s4*u5*(-1 + R); constraintJacobianStanceFootRollingDot(2,6) = ...
          % c4p6*s5*u5*(-1 + R) + c5*s4p6*(u4 + u6)*(-1 + R); ...
          % constraintJacobianStanceFootRollingDot(2,7) = 0; ...
          % constraintJacobianStanceFootRollingDot(2,8) = 0;
          % constraintJacobianStanceFootRollingDot(3,1) = 0; ...
          % constraintJacobianStanceFootRollingDot(3,2) = 0; ...
          % constraintJacobianStanceFootRollingDot(3,3) = 0; ...
          % constraintJacobianStanceFootRollingDot(3,4) = -(s4*u4*pelvisWidth)/2. + ...
          % s4p6*s5*u5*(-1 + R) - c4p6*c5*(u4 + u6)*(-1 + R); ...
          % constraintJacobianStanceFootRollingDot(3,5) = s4*s5*u4*(-1 + R) - ...
          % c4*c5*u5*(-1 + R); constraintJacobianStanceFootRollingDot(3,6) = ...
          % s4p6*s5*u5*(-1 + R) - c4p6*c5*(u4 + u6)*(-1 + R); ...
          % constraintJacobianStanceFootRollingDot(3,7) = 0; ...
          % constraintJacobianStanceFootRollingDot(3,8) = 0;
          % constraintJacobianStanceFootRollingDot(4,1) = 0; ...
          % constraintJacobianStanceFootRollingDot(4,2) = 0; ...
          % constraintJacobianStanceFootRollingDot(4,3) = 0; ...
          % constraintJacobianStanceFootRollingDot(4,4) = -(c4*u4*pelvisWidth)/2. + ...
          % c4p6*s5*u5*(-1 + R) + c5*s4p6*(u4 + u6)*(-1 + R); ...
          % constraintJacobianStanceFootRollingDot(4,5) = c4*s5*u4*(-1 + R) + ...
          % c5*s4*u5*(-1 + R); constraintJacobianStanceFootRollingDot(4,6) = ...
          % c4p6*s5*u5*(-1 + R) + c5*s4p6*(u4 + u6)*(-1 + R); ...
          % constraintJacobianStanceFootRollingDot(4,7) = 0; ...
          % constraintJacobianStanceFootRollingDot(4,8) = 0;
          
          
          
          constraintJacobianStanceFootRolling(1,1) = 1; ...
            constraintJacobianStanceFootRolling(1,2) = 0; ...
            constraintJacobianStanceFootRolling(1,3) = 0; ...
            constraintJacobianStanceFootRolling(1,4) = 0; ...
            constraintJacobianStanceFootRolling(1,5) = c5*c6*(-1 + R) - c4*R; ...
            constraintJacobianStanceFootRolling(1,6) = s5*(-(s6*(-1 + R)) - s4*R); ...
            constraintJacobianStanceFootRolling(1,7) = 0; ...
            constraintJacobianStanceFootRolling(1,8) = 0;
          constraintJacobianStanceFootRolling(2,1) = 0; ...
            constraintJacobianStanceFootRolling(2,2) = 1; ...
            constraintJacobianStanceFootRolling(2,3) = 0; ...
            constraintJacobianStanceFootRolling(2,4) = -(s4*(pelvisWidth - 2*s6*(-1 + ...
            R)))/2. - c4*c5*c6*(-1 + R) + R; constraintJacobianStanceFootRolling(2,5) = ...
            c6*s4*s5*(-1 + R); constraintJacobianStanceFootRolling(2,6) = -(c4*c6*(-1 + ...
            R)) + c5*(s4*s6*(-1 + R) + R); constraintJacobianStanceFootRolling(2,7) = 0; ...
            constraintJacobianStanceFootRolling(2,8) = 0;
          constraintJacobianStanceFootRolling(3,1) = 0; ...
            constraintJacobianStanceFootRolling(3,2) = 0; ...
            constraintJacobianStanceFootRolling(3,3) = 1; ...
            constraintJacobianStanceFootRolling(3,4) = (c4*(pelvisWidth - 2*s6*(-1 + ...
            R)))/2. - c5*c6*s4*(-1 + R); constraintJacobianStanceFootRolling(3,5) = ...
            -(c4*c6*s5*(-1 + R)); constraintJacobianStanceFootRolling(3,6) = -((c6*s4 + ...
            c4*c5*s6)*(-1 + R)); constraintJacobianStanceFootRolling(3,7) = 0; ...
            constraintJacobianStanceFootRolling(3,8) = 0;
          constraintJacobianStanceFootRolling(4,1) = 0; ...
            constraintJacobianStanceFootRolling(4,2) = 1; ...
            constraintJacobianStanceFootRolling(4,3) = 0; ...
            constraintJacobianStanceFootRolling(4,4) = -(s4*(pelvisWidth - 2*s6*(-1 + ...
            R)))/2. - c4*c5*c6*(-1 + R); constraintJacobianStanceFootRolling(4,5) = ...
            c6*s4*s5*(-1 + R); constraintJacobianStanceFootRolling(4,6) = -((c4*c6 - ...
            c5*s4*s6)*(-1 + R)); constraintJacobianStanceFootRolling(4,7) = 0; ...
            constraintJacobianStanceFootRolling(4,8) = 0;
          
          
          constraintJacobianStanceFootRollingDot(1,1) = 0; ...
            constraintJacobianStanceFootRollingDot(1,2) = 0; ...
            constraintJacobianStanceFootRollingDot(1,3) = 0; ...
            constraintJacobianStanceFootRollingDot(1,4) = 0; ...
            constraintJacobianStanceFootRollingDot(1,5) = -(c6*s5*u5*(-1 + R)) - ...
            c5*s6*u6*(-1 + R) + s4*u4*R; constraintJacobianStanceFootRollingDot(1,6) = ...
            c5*u5*(-(s6*(-1 + R)) - s4*R) + s5*(-(c6*u6*(-1 + R)) - c4*u4*R); ...
            constraintJacobianStanceFootRollingDot(1,7) = 0; ...
            constraintJacobianStanceFootRollingDot(1,8) = 0;
          constraintJacobianStanceFootRollingDot(2,1) = 0; ...
            constraintJacobianStanceFootRollingDot(2,2) = 0; ...
            constraintJacobianStanceFootRollingDot(2,3) = 0; ...
            constraintJacobianStanceFootRollingDot(2,4) = -(c4*u4*(pelvisWidth - 2*s6*(-1 ...
            + R)))/2. + c5*c6*s4*u4*(-1 + R) + c4*c6*s5*u5*(-1 + R) + c6*s4*u6*(-1 + R) + ...
            c4*c5*s6*u6*(-1 + R); constraintJacobianStanceFootRollingDot(2,5) = ...
            c4*c6*s5*u4*(-1 + R) + c5*c6*s4*u5*(-1 + R) - s4*s5*s6*u6*(-1 + R); ...
            constraintJacobianStanceFootRollingDot(2,6) = c5*(c4*s6*u4*(-1 + R) + ...
            c6*s4*u6*(-1 + R)) + c6*s4*u4*(-1 + R) + c4*s6*u6*(-1 + R) - s5*u5*(s4*s6*(-1 ...
            + R) + R); constraintJacobianStanceFootRollingDot(2,7) = 0; ...
            constraintJacobianStanceFootRollingDot(2,8) = 0;
          constraintJacobianStanceFootRollingDot(3,1) = 0; ...
            constraintJacobianStanceFootRollingDot(3,2) = 0; ...
            constraintJacobianStanceFootRollingDot(3,3) = 0; ...
            constraintJacobianStanceFootRollingDot(3,4) = -(s4*u4*(pelvisWidth - 2*s6*(-1 ...
            + R)))/2. - c4*c5*c6*u4*(-1 + R) + c6*s4*s5*u5*(-1 + R) - c4*c6*u6*(-1 + R) + ...
            c5*s4*s6*u6*(-1 + R); constraintJacobianStanceFootRollingDot(3,5) = ...
            c6*s4*s5*u4*(-1 + R) - c4*c5*c6*u5*(-1 + R) + c4*s5*s6*u6*(-1 + R); ...
            constraintJacobianStanceFootRollingDot(3,6) = -((c4*c6*u4 - c5*s4*s6*u4 - ...
            c4*s5*s6*u5 + c4*c5*c6*u6 - s4*s6*u6)*(-1 + R)); ...
            constraintJacobianStanceFootRollingDot(3,7) = 0; ...
            constraintJacobianStanceFootRollingDot(3,8) = 0;
          constraintJacobianStanceFootRollingDot(4,1) = 0; ...
            constraintJacobianStanceFootRollingDot(4,2) = 0; ...
            constraintJacobianStanceFootRollingDot(4,3) = 0; ...
            constraintJacobianStanceFootRollingDot(4,4) = -(c4*u4*(pelvisWidth - 2*s6*(-1 ...
            + R)))/2. + c5*c6*s4*u4*(-1 + R) + c4*c6*s5*u5*(-1 + R) + c6*s4*u6*(-1 + R) + ...
            c4*c5*s6*u6*(-1 + R); constraintJacobianStanceFootRollingDot(4,5) = ...
            c4*c6*s5*u4*(-1 + R) + c5*c6*s4*u5*(-1 + R) - s4*s5*s6*u6*(-1 + R); ...
            constraintJacobianStanceFootRollingDot(4,6) = -((-(c6*s4*u4) - c4*c5*s6*u4 + ...
            s4*s5*s6*u5 - c5*c6*s4*u6 - c4*s6*u6)*(-1 + R)); ...
            constraintJacobianStanceFootRollingDot(4,7) = 0; ...
            constraintJacobianStanceFootRollingDot(4,8) = 0;
          
          
          C = constraintJacobianStanceFootRolling;
          CDot = constraintJacobianStanceFootRollingDot;
          
        otherwise
          error('unknown mode for walker: %s', mode);
      end
      
    end
    
    function [energies] = getEnergyOfState(this, state)
      %%
      state = this.getWalkerStateObjectFromVector(state);
      
      state.setQsUsAndTrigInCurrentFunction();
      this.setWalkerParamsInCurrentFunction();
      
      
      energies.PE = (KSwing*((-q5 + q7)*(-q5 + q7)))/2. + g*(q3*(2*MLeg + ...
        MPelvis)*cos(groundAngle) - q1*(2*MLeg + MPelvis)*sin(groundAngle) + ...
        legMassVerticalOffset*MLeg*((-(c4*(c5*c6 + c7*c8)) + s4*(s6 + ...
        s8))*cos(groundAngle) + (c6*s5 + c8*s7)*sin(groundAngle)));
      
      energies.PEGravity = g*(q3*(2*MLeg + MPelvis)*cos(groundAngle) - q1*(2*MLeg + ...
        MPelvis)*sin(groundAngle) + legMassVerticalOffset*MLeg*((-(c4*(c5*c6 + ...
        c7*c8)) + s4*(s6 + s8))*cos(groundAngle) + (c6*s5 + c8*s7)*sin(groundAngle)));
      
      energies.PESpring = (KSwing*((-q5 + q7)*(-q5 + q7)))/2.;
      
      energies.KE = (MPelvis*(u1*u1 + u2*u2 + u3*u3))/2. + ...
        (MLeg*(-2*c5*u1*(s5*s6*u4 + c6*u5)*legMassVerticalOffset - ...
        2*s4*s5*u2*(s5*s6*u4 + c6*u5)*legMassVerticalOffset + 2*s5*s6*u1*(c5*u4 + ...
        u6)*legMassVerticalOffset + 2*(c4*c6 - c5*s4*s6)*u2*(c5*u4 + ...
        u6)*legMassVerticalOffset + 2*(c6*s4 + c4*c5*s6)*u3*(c5*u4 + ...
        u6)*legMassVerticalOffset - s4*u2*u4*pelvisWidth + s5*u4*(s5*s6*u4 + ...
        c6*u5)*legMassVerticalOffset*pelvisWidth + c5*s6*u4*(c5*u4 + ...
        u6)*legMassVerticalOffset*pelvisWidth + ...
        c4*u3*(2*c6*s5*u5*legMassVerticalOffset + u4*(pelvisWidth + ...
        2*s6*legMassVerticalOffset*(s5*s5))) + u1*u1 + u2*u2 + u3*u3 + (s5*s6*u4 + ...
        c6*u5)*(s5*s6*u4 + c6*u5)*(legMassVerticalOffset*legMassVerticalOffset) + ...
        (c5*u4 + u6)*(c5*u4 + u6)*(legMassVerticalOffset*legMassVerticalOffset) + ...
        (u4*u4*(pelvisWidth*pelvisWidth))/4.))/2. + (MLeg*(-2*c7*u1*(s7*s8*u4 + ...
        c8*u7)*legMassVerticalOffset - 2*s4*s7*u2*(s7*s8*u4 + ...
        c8*u7)*legMassVerticalOffset + 2*s7*s8*u1*(c7*u4 + u8)*legMassVerticalOffset ...
        + 2*(c4*c8 - c7*s4*s8)*u2*(c7*u4 + u8)*legMassVerticalOffset + 2*(c8*s4 + ...
        c4*c7*s8)*u3*(c7*u4 + u8)*legMassVerticalOffset + s4*u2*u4*pelvisWidth - ...
        s7*u4*(s7*s8*u4 + c8*u7)*legMassVerticalOffset*pelvisWidth - c7*s8*u4*(c7*u4 ...
        + u8)*legMassVerticalOffset*pelvisWidth + c4*u3*(2*s7*(s7*s8*u4 + ...
        c8*u7)*legMassVerticalOffset - u4*pelvisWidth) + u1*u1 + u2*u2 + u3*u3 + ...
        (s7*s8*u4 + c8*u7)*(s7*s8*u4 + ...
        c8*u7)*(legMassVerticalOffset*legMassVerticalOffset) + (c7*u4 + u8)*(c7*u4 + ...
        u8)*(legMassVerticalOffset*legMassVerticalOffset) + ...
        (u4*u4*(pelvisWidth*pelvisWidth))/4.))/2. + ((IPelvis + ILeg*(c5*c5) + ...
        ILeg*(c7*c7) + ILegSmall*(c6*c6)*(s5*s5) + ILeg*(s5*s5)*(s6*s6) + ...
        ILegSmall*(c8*c8)*(s7*s7) + ILeg*(s7*s7)*(s8*s8))*(u4*u4) + (ILeg*(c6*c6) + ...
        ILegSmall*(s6*s6))*(u5*u5) + ILeg*(u6*u6) + ILeg*(c8*c8)*(u7*u7) + ...
        ILegSmall*(s8*s8)*(u7*u7) + ILeg*(u8*u8) + u4*(2*c5*u6*ILeg + 2*c7*u8*ILeg + ...
        s5*u5*(ILeg - ILegSmall)*sin(2*q6) + s7*u7*ILeg*sin(2*q8) - ...
        s7*u7*ILegSmall*sin(2*q8)))/2.;
      
      energies.total = energies.KE + energies.PE;
    end
    
  end
  
  methods (Access = protected)
    
    %     function [c, ceq, limitCycleError, cExtra, ceqExtra] = ...
    %         fixedPointConstraint(this, x0, ...
    %         degreesOfFreedomToIgnoreInLimitCycleConstraint, ...
    %         additionalConstraintFunction, ...
    %         desiredSpeed, desiredStepLength, parametersToAlter)
    %
    %       [c, ceq, limitCycleError, cExtra, ceqExtra] = ...
    %         fixedPointConstraintUsingKinematicPoints(this, x0, ...
    %         degreesOfFreedomToIgnoreInLimitCycleConstraint, ...
    %         additionalConstraintFunction, ...
    %         desiredSpeed, desiredStepLength, parametersToAlter);
    %     end
    
    function [pointVector] = kinematicPointsToLimitCycleErrorVector(this, points)
      pointVector = [ ...
        ...points.pelvis.position(3), ...
        points.pelvis.velocity, ...(1:2)
        ...reshape(points.pelvis.R, [1, 9]), ...
        ...
        ...points.stanceLeg.position, ...
        points.stanceLeg.velocity, ...
        ...reshape(points.stanceLeg.R, [1, 9]), ...
        ...
        ...points.swingLeg.position, ...
        points.swingLeg.velocity, ...
        ...reshape(points.swingLeg.R, [1, 9]), ...
        ...
        ...points.stanceFootCenter(2:3), ...
        ...points.swingFootCenter(2:3), ...
        ...
        ...points.stanceFootContactPoint, ...
        ...points.swingFootContactPoint, ...
        ...
        ...points.stanceHipPoint(2:3), ... x coordinate here is messed up (2:3)
        ...points.swingHipPoint(2:3), ...
        ...
        points.comVelocity, ...
        ...
        ...points.centerOfMassPosition
        ];
    end
    
    
    
    function [c, ceq, limitCycleError, cExtra, ceqExtra] = ...
        fixedPointConstraintUsingKinematicPoints(this, x0, ...
        degreesOfFreedomToIgnoreInLimitCycleConstraint, ...
        additionalConstraintFunction, ...
        desiredSpeed, desiredStepLength, parametersToAlter)
      %%
      
      %       error('calling new fixed point constraint calculator');
      
      %       x0Original = x0;
      if (~isempty(parametersToAlter))
        [x0, parameterValues] = this.separateStatesAndParameters(x0, parametersToAlter);
        this = this.setParametersFromList(parametersToAlter, parameterValues);
      end
      
      initialPoints = this.getKinematicPoints(x0);
      initialLimitCyclePointVector = this.kinematicPointsToLimitCycleErrorVector(initialPoints);
      
      % try
      %       [xNext, tFinal] = this.oneStep(x0);
      [xNext, tFinal, allStates, allTimes, this] = this.oneStep(x0);
      
      finalPoints = this.getKinematicPoints(xNext);
      finalPointsTemp = finalPoints;
      
      finalPoints.stanceFootCenter = finalPointsTemp.swingFootCenter;
      finalPoints.swingFootCenter = finalPointsTemp.stanceFootCenter;
      
      %       finalPoints.stanceFootContactPoint = finalPointsTemp.swingFootContactPoint;
      %       finalPoints.swingFootContactPoint = finalPointsTemp.stanceFootContactPoint;
      
      finalPoints.stanceHipPoint = finalPointsTemp.swingHipPoint;
      finalPoints.swingHipPoint = finalPointsTemp.stanceHipPoint;
      
      finalPoints.stanceLeg = finalPointsTemp.swingLeg;
      finalPoints.swingLeg = finalPointsTemp.stanceLeg;
      
      finalLimitCyclePointVector = this.kinematicPointsToLimitCycleErrorVector(finalPoints);
      
      
      ceq = finalLimitCyclePointVector - initialLimitCyclePointVector;
      ceq = ceq';
      %       try
      %         ceq = xNext.getVector() - x0;
      %       catch e
      %         e
      %       end
      %       ceq(degreesOfFreedomToIgnoreInLimitCycleConstraint) = [];
      limitCycleError = ceq;
      
      c = [];
      
      if (~isempty(desiredSpeed))
        ceq = [ceq; desiredSpeed - this.calculateSpeed(x0, xNext.getVector(), tFinal)];
      end
      
      if (~isempty(desiredStepLength))
        ceq = [ceq; desiredStepLength - this.calculateStepLength(x0, xNext.getVector())];
      end
      
      if isempty(additionalConstraintFunction)
        cExtra = [];
        ceqExtra = [];
      else
        [cExtra, ceqExtra] = additionalConstraintFunction(x0, xNext.getVector());
        c = [c; cExtra];
        ceq = [ceq; ceqExtra];
      end
      
      %       c
      %       ceq
      
      %       fprintf('norm(ceq) = %g\n', norm(ceq));
    end
    
  end
  
end

